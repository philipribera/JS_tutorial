<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content="Free Javascript Guide with Questions" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="author" content="Philip R" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Javascript Questions</title>
    <style>
      * {
        box-sizing: border-box;
        outline: none;
        padding: 0;
        margin: 0;
      }
      body {
        font-family: "Montserrat", Helvetica, sans-serif;
        background-color: rgb(92, 92, 92);
      }
      header {
        width: 100%;
        height: 72px;
        position: fixed;
        top: 0;
        z-index: 9999;
        background-color: rgb(77, 77, 77);
        box-shadow: 1px 1px 2px 1px rgb(102, 102, 102);
      }
      .header-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: flex-end;
        align-items: center;
        padding: 0 5%;
      }
      .header-title {
        margin-right: auto;
      }
      .header-title h3 {
        font-size: 1.4rem;
        color: rgb(244, 244, 244);
      }
	  .header-menu ul {
		margin: 0;
	  }
      .header-menu li {
        padding: 14px;
      }
      .header-menu a {
        color: rgb(247, 247, 247);
      }
      .header-menu ul li {
        display: inline;
        cursor: pointer;
      }
      .header-menu ul a:hover {
        color: rgb(255, 159, 32);
      }
      .wrapper {
        display: block;
        width: 100%;
        max-width: 992px;
        background-color: rgb(251, 251, 251);
        color: rgb(35, 35, 35);
        padding: 24px;
        margin: 42px auto;
      }

      /*** GENERICS ***/
      p {
        color: rgb(17, 17, 17);
      }
      h1,
      h2,
      h3 {
        color: rgb(242, 147, 38);
      }
      h1 {
        font-size: 2.1rem;
      }
      h3 {
        font-size: 1.55rem;
      }
      h4 {
        font-size: 1.15rem;
        color: rgb(39, 39, 39);
		    margin: 32px 0 12px 0;
      }
      ul {
        padding: 4px;
        margin-left: 14px;
      }
      li {
        list-style-type: none;
        padding: 0 4px;
      }
      a {
        color: rgb(132, 132, 132);
        text-decoration: none;
      }
      p,
      span,
      b {
        color: rgb(37, 37, 37);
        line-height: 1.6rem;
      }
      code {
		font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
			monospace;
        font-size: 1rem;
        line-height: 1.72rem;
        color: rgb(20, 64, 86);
      }

      /*** CLASSES ***/
	  .expand-text {
		font-size: 1.1rem;
	  }
      .tutorial-title {
        margin: 20px 0;
      }
	  .log-list {
		margin: 22px 0;
	  }
      .log-list li {
		display: flex;        
        border-bottom: 1px solid rgb(212, 212, 212);
      }
      .log-list li:first-child {
        font-weight: 600;
      }
	  .log-list li:last-child {
		flex: 1;
	  }
      .info-list {
        display: inline-block;
        min-width: 72px;
        margin-right: 14px;
      }
      .go-top {
        padding: 4px 0;
      }
      .go-top a {
        font-size: 1rem;
        font-weight: 600;
        text-decoration: none;
        cursor: pointer;
        background: rgb(222, 222, 222);
        color: rgb(42, 96, 117);
        padding: 4px 6px;
        border: 1px solid rgb(190, 190, 190);
      }
      .go-top a:hover {
        opacity: 0.95;
      }
      .tutorial-part {
        padding: 28px 28px 30px 28px;
        border-bottom: 4px solid rgb(207, 207, 207);
      }
      .tutorial-part:not(:first-of-type) {
        margin-top: 24px;
      }
      .subject-article {
        display: inline-block;
        margin: 24px 0;
      }
      .subject-title {
        margin-bottom: 18px;
      }
      .example {
        margin-left: 14px;
      }
      .example2 {
        margin-left: 28px;
      }
	  .example3 {
		margin-left: 42px;
	  }
      .link {
        word-break: break-all;
        display: inline-block;
        color: rgb(123, 123, 123);
        font-weight: 600;
        margin: 12px 0;
      }
      .code * {
        word-break: break-all;
      }
      .code-container {
        position: relative;
        background-color: rgb(236, 236, 236);
        color: rgb(247, 247, 247);
        padding: 26px 24px;
        margin: 22px 0 24px 0;
        overflow: auto;
      }
      .code-container code,
      .code-container code span {
        color: rgb(19, 76, 105);
      }
      .code-container i {
        color: rgb(37, 63, 110);
        line-height: 2.15rem;
      }
      .code-container .comment-oneline {
        display: block;
        color: rgb(41, 54, 103);
        opacity: 0.95;
        font-weight: 600;
        margin: 14px 0 12px 0;
      }
	  .subject-article .code-container:first-child {
		margin-top: 0;
	  }	  
	  
      .code-container-mod {
        background-color: rgb(9, 9, 9);
      }
      .code-container-mod code,
      .code-container-mod code span {
        color: rgb(74, 249, 105);
      }
      .code-container-mod .comment-oneline {
        color: rgb(237, 238, 237);
      }
	  .code-container-mod span.comment-outcome {
		color: #62ff2e;
	  }
      .question {
        margin-bottom: 54px;
      }
      .btn-change-color {
        position: absolute;
        right: 0;
        top: 0;
        cursor: pointer;
        background: rgb(45, 45, 45);
        color: rgb(222, 222, 222);
        padding: 6px;
        border: 1px solid rgb(102, 102, 102);
      }
      #fundamentals,
      #es6,
      #questions-part {
        display: block;
        position: relative;
        top: -120px;
        visibility: hidden;
      }	 
	  
		code span.comment-outcome {
			font-weight: 600;
			color: rgb(82,101,167);
		}
	    .note-comment {
		    display: inline-block;
			width: 100%;
		    background-color: rgb(255,226,168);
		    padding: 16px 12px;
		    margin: 18px 0;
	    }
	    .first-word {
		    color: rgb(37,37,37);
		    font-weight: 600;
	    }

      /*** MEDIA QUERIES ***/
      @media only screen and (max-width: 990px) {
        .tutorial-part {
          padding: 20px;
        }
        .code-container {
          width: 99%;
          padding: 20px;
        }
        h1 {
          font-size: 2rem;
        }
        h3 {
          font-size: 1.45rem;
        }
      }
      @media only screen and (max-width: 767px) {
        .wrapper {
          padding: 9px;
          margin: 94px 0 0 0;
        }
        .tutorial-part {
          padding: 6px;
        }
        .example {
			margin-left: 10px;
		}
		.example2 {
			margin-left: 22px;
		}
		.example3 {
			margin-left: 32px;
		}
        .code-container {
          width: 99%;
          padding: 20px 14px;
        }
        h1 {
          font-size: 1.95rem;
        }
        h3 {
          font-size: 1.4rem;
        }
        i {
          line-height: 1.6rem;
        }
      }
      @media only screen and (max-width: 600px) {
        .header-container {
          display: flex;
          flex-wrap: wrap;
          text-align: center;
          justify-content: center;
          height: auto;
          padding: 20px 14px 8px 14px;
        }
        .header-title {
          display: block;
          margin-bottom: 10px;
        }
        .header-title h3 {
          font-size: 1.15rem;
        }

        .header-menu {
          justify-content: center;
        }
        .header-menu ul,
        .header-menu li {
          padding: 10px;
        }

        .collapsed-menu {
          display: block;
        }
        .wrapper {
          width: initial;
        }
        .code-container {
          padding: 18px 12px;
        }
        h1 {
          font-size: 1.8rem;
        }
        h3 {
          font-size: 1.37rem;
        }
        .example {
          margin-left: 0;
        }
      } 	  
    </style>
  </head>

  <body>
    <header class="header-container">
      <div class="header-title">
        <h3>JAVASCRIPT FUNDAMENTALS WITH QUESTIONS</h3>
      </div>
      <div class="header-menu">
        <ul>
          <li><a href="#fundamentals">Fundamentals</a></li>
          <li><a href="#es6">ES6</a></li>
          <li><a href="#questions-part">Questions</a></li>
        </ul>
      </div>
    </header>

    <div class="wrapper">
      <br />
      <span id="fundamentals"></span>
      <div class="tutorial-part">
        <h1 class="tutorial-title">Javascript Fundamentals</h1>

        <article class="subject-article">
          <h3 class="subject-title">Dynamically typed</h3>
          <div class="example">
            <p>
			 Javascript is what we call <i>dynamically typed</i> meaning the type of an variable is interpreted by the compiler. The opposite to dynamic typed is <i>static typed</i>. Sometime Javascript is also called a <i>weakly typed</i> language in contrast to languages that are <i>strongly typed</i> where a variable has to be given a type when it's declared.  
			 </p><br />
			 <p>
			 Javascript being dynamically typed means that types will be intrepreted and if necessary even change implicitly at runtime. With runtime meaning when the program executes the commands. The type and its value can be changed at any time, both explicitly or implicitly by the Javascript engine. This behaviour can be confusing and give unexpected outcomes if not understood fully. Before looking deeper into this tough we will start by looking at different types- and their behaviour in Javascript      
			</p>
			</div>
		</article>
        
        <article class="subject-article">
          <h3 class="subject-title">Primitive Types</h3>
          <div class="example">		  
			  <p>
			  Data types in Javascript are either objects or primitives. While
              there is only one <i>object</i> data type there are 7 primitive
              data types:
              <i>string, number, boolean, null, undefined, bigInt</i> and
              <i>symbol</i>.<br />
            </p>
            <br />
            <p>
              Primitive values can not have properties and methods since they
              are not objects. But Javascript will still treat primitive values
              as objects, meaning that properties and methods can be applied on them. Javascript does this by wrapping the value in an object kind of entity. One example is the 'length' property that can be applied on strings. But even if primitives can behave as objects there are differences that are important to keep in mind. Firstly; primitive values are non-mutable, assigning a value to a variable gives it a new value it does not mutate the original value as the case with objects. Primitive types are in other words <i>immutable</i>. Secondly; primitive values are passed by <i>copying the value</i>. This means that if the value is assigned to a new variable it's copied and can be changed without affecting the value of the original variable. Objects on the other hand <i>pass value by reference</i>.
            </p>

            <div class="code-container">
                <button class="btn-change-color">Change Theme</button>

                <span class="comment-oneline">
                We can use properties on a string
                </span>
                <code>
                let str = "Hello World"<br />
                console.log(str.length) <span class="comment-outcome">--> 11</span>// We get the numbers of characters<br />
                <br />
                 </code> 
                <span class="comment-oneline">
                Primitive values do not mutate
                </span>
                <code>
                let foo = "Hello World" <br />
                foo.toUpperCase() <span class="comment-outcome">--> 'HELLO WORLD'</span> // we use a method on foo<br />
                console.log(foo) <span class="comment-outcome">--> 'Hello World'</span> // the original value is
                unchanged<br /> </code
              ><br />

              <span class="comment-oneline">// We can do this</span>
              <code>
                console.log(foo[0]) <span class="comment-outcome">--> H</span> // we get the 1st character<br /> </code
              ><br />
              <span class="comment-oneline">// But not this...</span>
              <code>
                foo[0] = "T" // We try to assign foo[0] a new value<br />
                console.log(foo) <span class="comment-outcome">--> Hello World</span> // value of 'foo' doesn't change <br />
              </code>
            </div>
			
            <span class="note-comment">
              <span class="first-word">Note:</span> Primitives being immutable is the reason we can't use
              mutator methods on strings. For example push, reverse and sort. 
			  </span><br />
			
            <i class="link"
              >See more;
              <a
                href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive"
                >https://developer.mozilla.org/en-US/docs/Glossary/Primitive</a
              ></i
            ><br />
            
            <h4><i>string</i></h4>
            <p>String values consists of normal characters. Special characters can be encoded using the escape character '\'. In Javascript strings can be denominated with both single and double quotes. As already mentioned Javascript will treat strings as objects making it possible to use object properties and methods.</p>
                       
            <h4><i>number</i>, <i>NaN</i> and the <i>Math</i> object</h4>         
            <p>
              In Javascript we only have one type for numbers. There is no
              distinction for decimals etc. The Math object in Javascript is
              used to perform mathematical tasks on numbers. If a Math function can't convert an argument to a number it returns <i>NaN</i>.
				To check for <i>NaN</i> do <b>not</b> compare; NaN === NaN, this returns false since type of NaN is number!. Instead the <i>isNaN</i> function is used; isNaN === NaN.
			</p>

			<span class="note-comment">
              <span class="first-word">Note: </span>
			  With ES6 we can use <i>Number.isNaN(value)</i> to check for <i>NaN</i>.</span>
			  
            <span class="link"
              >See more;
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN"
                >https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN</a
              ></span
            >
            
            <div class="code-container">
			<span class="comment-oneline">Some common methods of the Math object: </span>
              <code>
                let floatNumber = 1.55 <br />
                Math.round(floatNumber) <span class="comment-outcome">--> 2</span> // will round to closest integer
                <br /><br />
                let num1 = 2.3 <br />
                let num2 = 1.4 <br />
                Math.floor(num1 + num2) <span class="comment-outcome">--> 3</span> // will round downwards to closest
                integer <br /><br />
                Math.max(4,7,9,11) <span class="comment-outcome">--> 11</span><br />
                Math.min(4,7,9,11) <span class="comment-outcome">--> 4</span><br />
                let numbers = [4,7,9,11]; <br />
                Math.max(numbers) <span class="comment-outcome">--> NaN</span> // Math max/min do not work with
                arrays.<br />
              </code>

              <div class="comment-oneline">
                To solve this we can use ES6 features as spread or reduce
              </div>
              <code>
                Math.max(...numbers) <span class="comment-outcome">--> 11</span><br /><br />
                let rand; <br />
                Math.random(rand) <span class="comment-outcome">--> ?</span> // returns a floating-point between 0
                and 1.
              </code>
            </div>

            <h4><i>undefined</i></h4>
            <p>
              <i>undefined</i> is a primitive datatype of type 'undefined'. It's a so
              called <i>falsy</i> value. Important: 'falsy' is not the same as
              'false'. The latter being of datatype Boolean. Javascript will
              automatically assign <i>undefined</i> to a variable that are not
              initialized. In other words a variable that has been declared but not given a value will always return undefined. 
              A function with no return statement will always return <i>undefined</i> as well. To check for <i>undefined</i> we use the
              <b>typeof</b> operator.<br />              
            </p>

            <div class="code-container">
              <div class="comment-oneline">
                // If we try to use a variable before being declared
              </div>
              <code> console.log(a); // Gives a reference error <br /> </code>
              <div class="comment-oneline">
                // If we don't initialize a variable
              </div>
              <code> let a; // This will give 'a' the value undefined. </code
              ><br />
              <div class="comment-oneline">// But we can also do this</div>
              <code>
                let a = undefined; // we assign the value 'undefined'<br />
                typeof a <span class="comment-outcome">--> 'undefined'</span> <br />
                if ( typeof a === 'undefined') <span class="comment-outcome">--> true</span> // We check for
                'undefined' </code
              >
			  </div>
			  
			<span class="note-comment">
              <span class="first-word">Note: </span><i>undefined</i> has its own type and is not to be considered an error, tough it's often the cause of bugs.
			</span>	            
           
            <h4><i>null</i></h4>
            <p>
              <i>null</i> is a primitive value and a keyword in JavaScript that means
              ‘no value’ or nonexistence of any value. The type of null is
              object while <i>undefined</i> has its own type. If the purpose is to give a variable an empty value is can be done by assign it the value null, representing no value. You could say that <i>null</i> has the same purpose/meaning for objects as <i>undefined</i> for primitives with the difference that the latter has its own type while <i>null</i> hasn't.
            </p>
            
            <div class="code-container">
              <code>
                let b = null; <br />
                typeof b <span class="comment-outcome">--> object</span> // null basically means empty object
                <br />
                if (b === null) <span class="comment-outcome">--> true </span>// We check for null </code
              >
            </div>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Operators</h3>
          <div class="example">
            <p>
              JavaScript has <i>operators</i> that perform some operation on a single or multiple <i>operands</i> (data value). 
              There are at least 10 different kinds of operators in Javascript, one being the assignment operator (=) which assign a value to a variable, another being arithmetic operators as (+,-,/), that performs arithmetic operations.
              In this tutorial we will look deeper into a few of these, among them <i>Comparison</i> operators due to their importance for understanding how Javascript handles <i>type coercion</i>.     
            </p>
            
            <h4>Comparison Operators</h4>
            <p>
              The rules for type conversions in Javascript can be confusing and give unexpected outcomes if not understood fully.               
              It's not least important to understand the difference between the
              double equality operator (<b>==</b>) and the tripple equality
              operator (<b>===</b>) when comparing operands(values).               
              Javascript have different rules for using the double equality operator often called
              'loose' equality operator' versus the tripple one being the 'strict'
              equivalent. The loose equality operator compares the value but not
              the data type vs. the latter that compares both. There are no formal rule for
              which comparison to use in your code but to ensure strict comparison the
              tripple equality operator is to be preferred. That said there can
              be situations where a non-strict comparison operator can have it's
              benefits. No matter which one is used it's important to understand
              how they work and the implications of using one over the other.
              The already mentioned operators can also be combined as follows; not equal to <b>!= !==</b>,
              greater or less than <b> &gt; &lt;, &gt;= &lt;=.</b>
            </p>

            <div class="code-container">
              <code>
                if(1 == "1") <span class="comment-outcome">--> true</span> // will make a comparison after type
                conversion of "1" to 1 <br />
                <br />
                if(1 === "1") <span class="comment-outcome">--> false</span> // strict equality will check for both
                value and type.
                <br />
              </code>
            </div>
            
            <h4>Logical Operators</h4>
            <p>
              Logical operators are used to determine the logic between
              variables or values.
              ....
            </p>
            <ul class="log-list">
              <li>
                <span class="info-list">Operator</span
                ><span class="info-list"> </span>
				<span class="info-list"> Description</span>
              </li>
              <li>
                <span class="info-list">&&</span
                ><span class="info-list">and</span>
				<span class="info-list">Both values has to evaluate to true</span>
              </li>
              <li>
                <span class="info-list">||</span
                ><span class="info-list">or</span>
				<span class="info-list">One value has to evaluate to true</span>
              </li>
              <li>
                <span class="info-list">!</span
                ><span class="info-list">not</span>
              </li>
            </ul>
			<div class="code-container">			
			<span class="comment-oneline">The <span class="expand-text">||</span> (or) operator will return true if either operand is true</span>
			<code>
				var a = true;	<br />
				var b = false; 	<br />
				( a || b ) <span class="comment-outcome">--> true</span><br />   
			</code>
			<span class="comment-oneline">The <span class="expand-text">&&</span> (and) operator will return true if both operands are true</span>
			<code>
				var a = true;	<br />
				var b = false; 	<br />
				( a && b ) <span class="comment-outcome">--> false</span><br />   
			</code>
			<span class="comment-oneline">Logical (&&) operator will return second operand if both operands are true</span>			
			<code>
				var age = 20;	<br />
				var allowedAge = 15; <br />
				( (age > allowedAge) && "You can enter")<span class="comment-outcome">--> "You can enter."</span>
			</code>
			</div>
			
			<h4>Conditional Operator, <i>Ternary</i></h4>			
			<p>The ternary operator assigns a value to a variable based on some condition. If the condition is true the first value is assigned to the variable else the second one. Ternary operators can be seen as a leaner way to write code than the if/else conditionally approach.</p>
			<div class="code-container">
			<code>
				var age = 12	<br />
				var message = age > 15 ? "Horror movie." : "It's Disney for you." <br />
				message <span class="comment-outcome">--> "It's Disney for you."</span>
			</code>		
			<span class="comment-oneline">Ternary operator combined wth logical operator</span>
			<code>
			var age = 20;		<br />
			var allowedAge = 15	<br />
			var result = allowedAge ? ( age && "Welcome!" ) : null				<br />	
			result	<span class="comment-outcome">--> "Welcome" </span><br />
			</code>			
			</div>
			
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Type Coercion</h3>
          <div class="example">
            <p>
              Type coercion is an important concept in Javascript not least
              considering that JavaScript is a loosely typed programming
              language, sometimes also described as a dynamic language.
              Javascript being loosely typed means that a variable can be
              assigned and reassigned any value of an existing data type. It can
              be a string to number, object to boolean, and so on. The process
              of converting a value from one type to another is called 'type
              coercion'.
            </p>
            
            <h4>Implicit vs. explicit coercion</h4>
            <p>
              Type conversion can be done implicit and explicit. An example of
              implicit(automatic) type conversion is when using the loose
              equality operator. Since it only compares the values and not the
              type Javascript will seek to make a type coercion so both values
              also share the same type. As a developer such code should be
              avoided since it's often the reason for bugs. Explicit coercion on
              the other hand is done on purpose, for example by using
              Number(value) that seeks to convert the value to the type
              'number'.
            </p>
            <br />
            <span class="link"
              >See more:
              <a
                href="https://www.freecodecamp.org/news/js-type-coercion-explained-27ba3d9a2839/"
                >https://www.freecodecamp.org/news/js-type-coercion-explained-27ba3d9a2839/</a
              >
            </span>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Pass by Value vs. Reference</h3>
          <div class="example">
            <p>
              When we assign an object to new variable we copy the reference to
              where that object or array is stored in memory.<br />The reference
              works in other words as a pointer to where the object is stored,
              it doesn't copy the value as is the case with primitive types.
              This means that if we change the value of a property/element it
              impacts all variables with a reference to the same spot in memory.
            </p>

            <div class="code-container">
			<span class="comment-oneline">Primitive types, pass value by copying</span>
              <code>
                let a = "KYH" <br />
                let b = a <br />
                a = "Hello" // We assign a new value to a <br />
                b <span class="comment-outcome">--> "KYH"</span> // We retain the copied value <br />
              </code>
            </div>
			
            <div class="code-container">
			<span class="comment-oneline">Objects, pass value by reference</span>
              <code>
                let objectA = {name: "Kal", lastname: "Doe"} <br />
                let objectB = objectA <br />
                objectA.name = "Ada" // we change the value of prop name<br>
				</code>				
				<span class="comment-oneline">objectB points to the location of the original object.
              It's not a copy of objectA.</span>
			  <code>
                objectB.name <span class="comment-outcome">--> "Ada"</span> // prop name has changed <br />
              </code>
            </div>
            <span class="note-comment">
              <span class="first-word">Note: </span>Function arguments are always passed by value and are copied
              into the function.
			  </span>
            <br />
			<span class="note-comment"><span class="first-word">Note: </span>
            To make a real copy of an object/array we
              can use the spread operator(see more under ES6 features).
            </span>
            <br />

            <span class="link"
              >See more:
              <a
                href="https://stackoverflow.com/questions/16880418/javascript-pas"
                >https://stackoverflow.com/questions/16880418/javascript-pas</a
              ></span
            >
          </div>
        </article>

		<article class="subject-article">
          <h3 class="subject-title">Hoisting</h3>
          <div class="example">
            <p>
              The definition of hoisting in Javascript is that declarations of
              variables and functions are moved to the top of the code when
              compiled. This means that a variable or function can be used even
              before it has been initialized. This feature can be the source for
              confusion since the written code is only moved in the memory, not
              physically. It is important to remember that it's only the declaration
              that is hoisted not the value of a variable or a function expression.
            </p>
            <br />
            <p>
              If we call a variable before it has been initialized it's value will be undefined, even if it's given a value after it has been called. <i>undefined</i> being a valid value, it even has it's own data type, will not result in an error.               
            </p>
            <br />
            <span class="link"
              >See more;
              <a
                href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting"
                >https://developer.mozilla.org/en-US/docs/Glossary/Hoisting</a
              >
            </span>

            <div class="code-container">
              <span class="comment-oneline">
                Variable declarations are hoisted inside functions as well
              </span>
              <code>
                var testScope = function() { <br />
                <span class="example">console.log(y);</span><br />
                <span class="example">var y = 1; </span><br />
                } <br />
                testScope(); <span class="comment-outcome">--> undefined</span><br /> </code
              ><br />

              <span class="comment-oneline">
                Anonymous function expressions are not hoisted
              </span>
              <code>
                var y = 2; <br />
                var testScope = function() { <br />
                <span class="example">console.log(y); </span><br />
                <span class="example">var y = 1; </span><br />
                } <br />
                testScope(); <span class="comment-outcome">--> undefined </span><br />
              </code>

              <br />
              <code>
                3)<br />
                var y = 2; <br />
                var testScope = function() { <br />
                <span class="example"> console.log(y);</span><br />
                } <br />
                testScope(); <span class="comment-outcome">--> 2</span><br />
              </code>			  
            </div>
			<span class="note-comment">
              <span class="first-word">Note: </span>Variables declared with the <i>let</i> keyword are not hoisted (see more under ES6 features).
			  </span>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Variable Scope</h3>
          <div class="example">
            <p>
              When talking about variable scope we are in essence referring to
              which scope a variable is accessible. In other words where we can look/access variables or
              functions.
              For a long time Javascript variable declarations were either
              global or function scoped. The latter sometimes also called local
              scope. A variable accessible anywhere in our code is said to exist
              in the global scope while a variable accessible inside a function
              exist in the local scope of the function where it was declared.
            </p>
            <br />
            <p>
              With ES6 support was added for block level scopes, this is done by
              declaring variables with the keyword <i>let</i>. A variable declared
              with let will only be accessible inside the block where it was
              declared. This can for example be inside the block restricted by a for loop that exist
              inside a function.
			</p>            
            <br />
            <p>
              When it comes to function scope it's also important to understand
              the concept of lexical scope sometimes also called Static
              scope. Lexical scope is the concept of a variable being accessible
              inside nested blocks, typically function or block scopes inside an outer function. 
              </p>
			  <div class="code-container">
              <span class="comment-oneline"></span>
			  <code>
                function outerFunction() { 							<br />
				<span class="example2">	var a = "I'm from outside";					</span><br />
				<span class="example2">	function innerFunction() {					</span><br />
				<span class="example3">		console.log(a)	<span class="comment-outcome">-->	I'm from outside	</span></span><br />
				<span class="example2"> }</span><br />
				}									<br />	
              </code>
			</div>
		  </div>
        </article>        

        <article class="subject-article">
          <h3 class="subject-title">Closures</h3>
          <div class="example">
            <p>
			A closure is to use a few words a function enclosed in lexical scope. As such a closure gives the enclosed function access to an outer function’s scope. In JavaScript, closures are created every time a function is created, at function creation time.
			</p>
			<br />
			<p>
			Closures in practice are used for creating object data privacy. It's commonly used for event handlers and callback functions. When using closures the enclosed variables are only in scope within the containing function making them non-accessible from the outside.
			</p>
            <span class="link"
              >More about closures:
              <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures</a></span
            ><br />
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">
            Usage of common String and Array methods
          </h3>
          <div class="example">
            <b>Explain and show how to use these methods.</b>
            <p>push, split, slice, join, sort, indexOf, charAt</p>
            <br />
            <i><b>What does this gives us?</b></i>

            <div class="code-container">
              <code>
                let greet = new String("Hello") <br />
                greet.charAt(greet.length-1) <br /><br />

                let str = "KYH Frontend" <br />
                typeof str <br />
                str.indexOf("F") <br /><br />

                let foo = str.split(" ") <br />
                typeof foo <br />
                foo.sort() <br /><br />

                let first = foo.slice(0,1) <br />
                foo.push(first.join()) <br />
                console.log(foo) <br /><br />

                foo.constructor </code
              ><br />
            </div>
            <span class="note-comment"
              ><span class="first-word">Note: </span>push and sort are so called mutator methods since they
              change the original array. Push for example adds item/s to the end
              of the array while returning the new length of the array. Mutator
              methods can't be used with strings because...? (well, you know
              why!)
              <i>...since primitive types are immutable.</i>
            </span>
            <span class="note-comment"><span class="first-word">Note: </span>We can use console.dir() to get more info about the
              constructor </span
            ><br />
            <br />
            <span class="link"
              >See more:
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Methods_2"
                >https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Methods_2</a
              ><br />
              <a
                href="https://www.tutorialrepublic.com/javascript-reference/javascript-array-object.php"
                >https://www.tutorialrepublic.com/javascript-reference/javascript-array-object.php</a
              ></span
            >
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Promises</h3>
          <div class="example">
            <p>
              A promise in Javascript is just as in real life; a promise or commitment to do something at some point in the future. The
              promise will then be resolved, or rejected. In programming context
              the Promise object represents the eventual completion (or failure)
              of an asynchronous operation and its resulting value. Promises in
              Javascript is a way to avoid what often is called 'callback hell'
              where callbacks are nested in an ever growing code structure.
            </p>
            <br />
            <p>
              A Promise consist of an resolved and rejected callback. Depending
              on if the promise is resolved or not the corresponding callback i
              executed. The resolve and reject functions, when called, resolve
              or reject the promise. With Promises we can organize our code with
              chained then() and catch() methods depending on if the promise is
              resolved or rejected.
            </p>

            <div class="code-container">
              <code>
                var myPromise = new Promise(function(resolve, reject) { <br />
              </code>
              <span class="comment-oneline">// Here the promise will be either resolved or rejected</span>
              <code>
                <span class="example">let studied = true; </span><br />
                <span class="example">if(studied) { </span><br />
                <span class="example2">resolve("Success"); </span><br />
                <span class="example">} else { </span><br />
                <span class="example2">reject('Failed') </span><br />
                <span class="example"> } </span><br />
                }) <br />
              </code>
              <span class="comment-oneline">// If the promise is fullfilled we pass the resolved argument
                  'value'</span>
              <code>
                myPromise.then(function(value) { <br />
                <span class="example"
                  >console.log(`It's done: ${value}`); <span class="comment-outcome">--> It's done: Study
                  Javascript</span></span
                ><br />
              </code>
              <span class="comment-oneline">// If the promise is rejected we use a catch </span>
              <code>
                }).catch(function(rejected) { <br />
                <span class="example"
                  >console.log(`It's not done: ${value}`); <span class="comment-outcome">--> It's not done:
                  Study Javascript </span></span
                ><br />
                }) <br />
              </code>
            </div>
            
            <span class="link">
              See more:
              <a  href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises">
                https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises</a>
                </span>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">fetch API</h3>
          <div class="example">
            <p>
              The Fetch API is a Javascript built in new standard for making
              server request. It provides a JavaScript interface for accessing
              and manipulating parts of the HTTP pipeline, such as requests and
              responses. It also provides a global fetch() method that provides
              an easy, logical way to fetch resources asynchronously across the
              network.
            </p>
            <br />
            <p>
              The fetch() method takes one mandatory argument, the
              <b>path(url)</b> to the resource you want to fetch. By default it
              will make a 'get request' and return a <b>Promise</b> containing a
              response object. We then have to extract the actual body content,
              can for example be the json() method to extract JSON body content.
              The fetch() method can optionally accept a second parameter
              consisting of an init object that gives the possibility to add
              configuration options for the request object.
            </p>

            <div class="code-container">
              <span class="comment-oneline">// We make a fetch request from API Open Weather Data</span>
              <code>
                const url =
                <a
                  href="http://api.openweathermap.org/data/2.5/weather?q=London&APPID=8674cbad0da4e9ccd435f2442a4dcda7&units=metric"
                  >API OPEN WEATHER DATA</a
                >;
                <br />
                fetch(url).then(response => { <br />
                <span class="example">return response.json() </span><br />
                <span class="example">.then(response => { </span><br />
                <span class="example2">console.log(response.main.temp) </span
                ><br />
                <span class="example">}) </span><br />
                <span class="example">.catch(error => { </span><br />
                <span class="example2">console.log('Error') </span><br />
                <span class="example2">console.error(error) </span><br />
                <span class="example">}); </span><br />
                }); <br /><br />
              </code>
              <span class="comment-oneline">// We configure the options for a POST request</span>  
				<code>			  
				const urlPost =
                <a href="https://jsonplaceholder.typicode.com/posts"
                  >JSON PLACEHOLDER</a
                >;
                <br />
                const options = { <br />
                <span class="example">method:"POST", </span><br />
                <span class="example">headers: { </span><br />
                <span class="example2"
                  >"Accept": "application/json; text/plain, */*",</span
                ><br />
                <span class="example2">"Content-type": "application/json" </span
                ><br />
                <span class="example">}, </span><br />
                <span class="example">body: JSON.stringify({ </span><br />
                <span class="example2">title: 'New Post', </span><br />
                <span class="example2">body: 'Lorem ipsum...!', </span><br />
                <span class="example2">id: 1 </span><br />
                <span class="example">}) </span><br />
                } <br />

                <br />
                fetch(urlPost, options) <br />
                <span class="example">.then(response => response.json()) </span
                ><br />
                <span class="example"
                  >.then(jsonResponse => console.log(jsonResponse)) </span
                ><br />
                <span class="example">.catch(error => { </span><br />
                <span class="example2">console.log(error) </span><br />
                <span class="example">}); </span><br />
              </code>
            </div>
            <span class="link"
              >See more:
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch"
                >API OPEN WEATHER DATA</a
              >
            </span>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">async/await</h3>
          <div class="example">
            <p>
              A special syntax is required to work with promises called
              “async/await”. It can be seen as a more easy to understand syntax
              compared to the then()/catch() methods. Using the keyword 'async'
              before a function means that the function always will return a
              promise. This is also required to be able to use 'await' inside
              async functions. The keyword await makes JavaScript wait until the
              promise is settled and first thereafter returns its result.
            </p>
            
            <div class="code-container">
              <code>
                const url =
                <a
                  href="http://api.openweathermap.org/data/2.5/weather?q=London&APPID=8674cbad0da4e9ccd435f2442a4dcda7&units=metric"
                  >API OPEN WEATHER DATA</a
                >; <br /><br />

                const getWeatherData = async function() { <br />
                <span class="example">const response = await fetch(url); </span
                ><br />
                <span class="example"
                  >const weatherData = await response.json();</span
                ><br />
                <span class="example">console.log(weatherData.main.temp) </span
                ><br />
                } <br />
                <br />
                getWeatherData().catch(error => { <br />
                <span class="example">console.error(error); </span><br />
                <span class="example">console.log('Error'); </span><br />
                }) <br />
              </code>
            </div>
            <span class="link"
              >See more:
              <a href="https://javascript.info/async-await"
                >https://javascript.info/async-await</a
              ></span
            ><br />
          </div>
        </article>
      </div>

      <!-- END TUTORIAL PART 1 -->

      <span id="es6"></span>
      <div class="tutorial-part">
        <h1 class="tutorial-title">ECMAScript 2015(ES6) features</h1>
        <br />

        <article class="subject-article">
          <h3 class="subject-title">Variable declaration; let and const</h3>
          <div class="example">
            <br />
            <p>
              With the introduction of ES6 support was added for the key words <i>const</i> and <i>let</i> when declaring variables.
            </p>

            <h4><i>const</i></h4>
            <p>
              const is used for declaring variables where the intention is to
              not change its value. It could be said that the value will be read
              only. It's important tough to understand that it works different
              depending on the data type. For primitive types the value is set
              once and becomes read only. For objects it works differently since
              for example an array stored with const can still receive new
              elements tough it is impossible to change the data type of the
              value.
            </p>
            
            <h4><i>let</i> vs. <i>var</i></h4>
            <p>
              The main difference between <i>var</i> and <i>let</i> is that
              <i>var</i> has function scope and <i>let</i> has block scope. 
			  Meaning that block level variables can be created, for example inside an if branch or a for loop. Another difference is that <i>let</i> declaration is not hoisted unlike the case with <i>var</i>. This means that a variable declared with let will not be accessible before it has been initialized, this will result in a reference error while doing the same with a variable declared with <i>var</i> will return as <i>undefined</i>. Another difference is that a variable declared with <i>let,</i> unike <i>var</i> will not create a property on the global object. 
            </p>
			
			<div class="code-container">
              <span class="comment-oneline">The iterator is declared with let meaning it's only accessible in its scope while variable b is accessible everywhere inside the function.</span>
			  <code>
			  function blockScope(num) {									<br />
				<span class="example">for(let i = 1; i &lt; num; i++) {		</span><br /> 
				<span class="example2">console.log(i) <span class="comment-outcome">--> 1,2,3,4</span></span><br />
				<span class="example2">var b = "I exist in function scope"	</span><br />
				<span class="example">	}									</span><br />
				<span class="example">console.log(b) <span class="comment-outcome">--> 	I exist in function scope		</span></span><br />
				<span class="example">console.log(i) <span class="comment-outcome">--> 	ReferencError, i is not defined</span></span><br />
				}	<br />
				blockScope(5);	<br />
              </code>
			  </div>
			
            <span class="note-comment">
              <span class="first-word">Note: </span><i>var</i> will allow you to re-declare a variable in the same scope while a variable declared with <i>let</i> raises a SyntaxError.
            </span>
            <br />
            <p>
              <span class="link"
                >See more:
                <a
                  href="https://stackoverflow.com/questions/762011/whats-the-difference-between-using-let-and-var"
                  >https://stackoverflow.com/questions/762011/whats-the-difference-between-using-let-and-var</a
                >
              </span>
            </p>

            <div class="code-container">
              <code>
                function checkScope() { <br />
                <span class="example"
                  >console.log(foo) <span class="comment-outcome">--> ReferenceError</span> // foo is not hoisted </span
                ><br />
                <span class="example"
                  >console.log(bar) <span class="comment-outcome">--> undefined </span>// variable declaration is
                  hoisted </span
                ><br />
                <span class="example">let foo = "Hello" </span><br />
                <span class="example">var bar = "World" </span><br />
                <br />
                <span class="example">for(var i = 0; i &lt; 5; i++) {</span
                ><br />
                <span class="example2">console.log(i) <span class="comment-outcome">--> 0,1,2,3,4</span></span><br />
                <span class="example">}</span><br />
                <span class="example">for(let j = 0; j &lt; 5; j++) {</span
                ><br />
                <span class="example2">
                  console.log(j) <span class="comment-outcome">--> 0,1,2,3,4</span></span
                ><br />
                <span class="example">}</span><br />

                <span class="example"
                  >console.log(i); <span class="comment-outcome">--> 5</span></span
                ><br />
                <span class="example"
                  >console.log(j); <span class="comment-outcome">--> ReferenceError</span> //
                  can not be accessed outside its scope</span
                ><br />
                } 
                checkScope();
              </code>
            </div>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Arrow functions</h3>
          <div class="example">
            <p>
              Arrow functions are anonymous functions that allows us to write
              shorter more leaner code. An arrow function can omit the
              parenthesis if there is no more than one argument. It can also
              omit the square brackets and the keyword 'return' if the function
              only consist of an return statement.
            </p>

            <div class="code-container">
              <span class="comment-oneline">
                  // A named function, the pre ES6 way to declare a function</span>
              <code>
                function doSmth(a) { <br />
                <span class="example"> return a * 2 </span><br />
                } <br />
              </code>
              <span class="comment-oneline">// The same function refactored as an arrow function</span>
              <code> const doSmth = a => a * 2 <br /> </code>
            </div>

            <h4>Arrow functions and keyword 'this'</h4>
            <p>
              One of the reasons for introducing arrow functions was the
              behaviour of the keyword 'this'. By default in a function 'this'
              will refer to the object that called the function. In other words
              'this' in a standalone function will refer to the window object
              since it was called in the global scope. The exception being in
              strict mode where 'this' will return undefined. To set the value
              of 'this' and by such alter its default behavior inside a
              function, the bind() method has to be used.
            </p>
            <br />
            <p>
              Arrow functions does not have its own this, it inherits this from
              the enclosing lexical scope. So when this is not present in its
              current scope it looks for it in the enclosing scope. In other
              words 'this' will always represent the object that defined the
              arrow function. If 'this' is used in a nested function or for
              example in a method of a class it will look for the value of this
              in the parent scope. That is in the parent function or the class
              where the method has been defined. With arrow functions the
              behaviour of 'this' will therefore be consistent and not change
              depending on where it is called.
            </p>
            <br />
            <span class="link"
              >See more:
              <a
                href="https://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work"
                >https://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work</a
              ></span
            >
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Default values</h3>
          <div class="example">
            <p>
              With ES6 support was added for the use of default values. To assign a default value we just assign a value to a function
              parameter. If no argument/s is given when calling the function it will be given its default value.
              This also works for destructuring where we can assign default values for variables.
            </p>

            <div class="code-container">
              <span class="comment-oneline">// We assign default values to the parameters</span><br />
              <code>
                function withDefaultValues(a=10, b=20) { <br />
                  <span class="example">let sum = a + b; </span><br />
                  <span class="example">return sum;</span><br />
                  <span>}</span><br />
                  <span>withDefaultValues() <span class="comment-outcome">--> 30</span></span><br />
              </code><br />
              <span class="comment-oneline">// We add an empty array as default value</span>
              ><br />
              <code>
                function addNumbers(numArr = []) { <br />
                <span class="example">let sum = 0; </span><br />
                <span class="example">numArr.forEach( num => { </span><br />
                <span class="example2"> sum += num; </span><br />
                <span class="example">}) </span><br />
                <span class="example">return sum; </span><br />
                } <br />

                addNumbers() <span class="comment-outcome">--> 0</span> // We get no error despite calling the
                function with no arguments.
              </code>
            </div>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Higher order functions</h3>
          <div class="example">
            <p>
              When a function receives another function as an argument that
              function is called a <b>higher order function</b>. And the
              function you pass in is called a <b>callback</b>. With ES6 several
              new higher order functions were introduced. With this the
              Javascript language got more flexible and developers got access to
              some new effective tools. Noteworthy; These methods do not
              mutate/change the orignal array (in general a good thing!).
            </p>
            <h4><i>map()</i></h4>
			<p>...</p>
            <h4><i>filter()</i></h4>
			<p>...</p>
            <h4><i>reduce()</i></h4>
			<p>...</p>
            <h4><i>sort()</i></h4>
            <p>...</p>
            <h4><i>find()</i></h4>
            <p>...</p>
            <h4><i>includes()</i></h4>
            <p>...</p>
            <span class="link"
              >See more:
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#"
                >https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#</a
              ></span
            >
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Loops & Iteration</h3>
          <div class="example">
            <h4><i>forEach</i></h4>
            <p>
              forEach() executes a provided function once for each array
              element. It will always returns the value undefined and is not
              chainable. ForEach can take tree arguments, the value of the
              current elment, what is required as well as two optional
              arguments, the index for each element and the array object it
              self. As with other high order methods it does not mutate the
              array on which it is called.
            </p>

            <div class="code-container">
                <span class="comment-oneline">// Basic syntax </span>
                <code>
                array.forEach(function(currentValue, index, arr), thisValue)
                <br /><br />
                </code>
                <span class="comment-oneline">// We loop through each name and add 'Doe'</span>
                <code>
                const myArr = ["John", "Lisa", "Tom"] <br /><br />
                myArr.forEach( name => { <br />
                <span class="example"
                  >console.log(`${name} Doe`) <span class="comment-outcome">--> John Doe, Lisa Doe...</span></span
                ><br />
                })
              </code>
            </div>

            <h4><i>for/in</i></h4>
            <p>
              The for/in statement/loop iterates over all non-symbol properties
              of an object. The loop will iterate over all enumerable properties
              of the object itself and those the object inherits from its
              constructor's prototype as well. If the intention is to only
              consider properties of the object itself and not its prototypes,
              use getOwnPropertyNames() or perform a hasOwnProperty() check.
            </p>

            <div class="code-container">
              <code>
                const myObj = { name: "John", surname: "Doe" } <br /><br />

                for(let prop in myObj) {<br />
                <span class="example">console.log(prop) <span class="comment-outcome">--> name, surname </span></span
                ><br />
                }
              </code>
            </div>

            <h4><i>for/of</i></h4>
            <p>
              The for/of statement loops over iterable objects. The loops
              through data structures that are iterable such as Strings, Arrays
              and array-like objects such NodeLists, Maps, Set etc. In every
              iteration the value of the next property is assigned to the
              variable. for/of is in general the preferred way to loop through
              iterable objects. It is more concise than a conventional for loop
              but can't be chained like forEach().
            </p>

            <div class="code-container">
              <code>
                const myNumbers = [11,22,33,44,55]<br /><br />

                for(let number of myNumbers) {<br />
                <span class="example">console.log(number) <span class="comment-outcome">--> 11,22,33...</span></span>
                <br />
                } <br /><br />
              </code>
              <i><b>// To access the index we have to use entries() </b></i
              ><br />
              <code>
                const myArr = [a,b,c] <br /><br />
                for (const [index, val] of myArr.entries()) { <br />
                <span class="example"
                  >console.log(index +": "+ val`); // Prints "0: a", "1: b", "2:
                  c" </span
                ><br />
                } <br />
              </code>
            </div>

            <h4>Summary for loops and iteration</h4>
            <p>
              There are many ways to iterate over arrays and loops and they all
              have there strengths and tradeof:s. The standard for and for/in
              loop constructs gives access to the index in the iterable object
              but not the actual element. To access the element we have to print
              out the, item[index]. With forEach() and for/of we get access to
              the element itself. In general the most robust/safe way to loop
              through an array/object will be the for/of loop. If the intention
              is to manipulate every element in an array the for/each loop is
              the best choice. The for/in loop should only be used to iterate
              through the properties of an object.
            </p>
            <br />
            <span class="link">
              See more:
              <a
                href="https://thecodebarbarian.com/for-vs-for-each-vs-for-in-vs-for-of-in-javascript"
                >https://thecodebarbarian.com/for-vs-for-each-vs-for-in-vs-for-of-in-javascript</a
              >
            </span>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Template Literals</h3>
          <div class="example">
            <p>
              Template Literals allows us to work with strings in a more agile
              and less ugly way. Not least the ability to use expressions gives
              lot of room for creating more dynamic code. Instead of quotes we
              use `backticks` to write string within it. We use ${variable or
              expression} instead of concatenation. Among the new features we
              also get a more agile syntax to define multiline strings.
            </p>

            <div class="code-container">
              <code>
                let firstName = "John" <br />
                let surName = "Doe" <br />
                const fullName = "John" + " " + "Doe" <span class="comment-outcome">--> John Doe</span> // The pre ES6
                way to do it.<br />
                <br />
                let firstName = "Lisa" <br />
                let surName = "Doe" <br />
                const fullName = `${firstName} ${surName}` <span class="comment-outcome">--> Lisa Doe</span> // Using
                template literals<br />
                <br />

                let divNumbers = `15 divided by 3 is ${15/3}` <span class="comment-outcome">--> 5</span> // We insert
                an expression
              </code>
            </div>
            <span class="link"
              >See more:
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals"
                >https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals</a
              ></span
            >
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Classes</h3>
          <div class="example">
            <p>
              With ES6 we got classes in Javascript. In reality it is only
              syntactical sugar or an alternative syntax to prototype-bases
              inheritance or in other words; Javascript constructor functions. A
              class is a special type of funtions that uses the keyword class.
              As with constructor functions the name is capitalized by
              convention.
            </p>
            <br />
            <p>
              A constructor method for creating and initializing an object can
              be specified. If this is not done a default constructor method -
              basically an empty function - is used. This is an empty object for
              a base class.
            </p>

            <h4>'constructor functions' vs classes</h4>
            <p>
              In most cases they are quite similar and they do the same thing
              but there are a some things that differs. A constructor requires
              the keyword <i>new</i> to work. While we still can call a
              constructor function without the keyword new this will throw an
              error when trying to do the same with a class. A class will in
              contrast to constructor functions create a constructor method by
              default if not given one. While constructor functions are hoisted
              this is not the case with class declarations. Another important
              difference is that everything that is written inside a class is
              typed in strict mode. With ES2019 we also got a few new important
              features when it comes to classes. It is now possible to create
              private properties and methods inside classes using the # prefix.
              There is also the possibility to initialize public properties at
              the top of a class before specifying a constructor. There are some
              important benefits to this that I will not go deeper in to here,
              for those that are interested to dwell more into all that classes
              offers I have added some links down here that explains the concept
              more in depth.
            </p>
            <br />

            <span class="link"
              >See more:
              <a
                href="https://www.sitepoint.com/javascript-private-class-fields/"
                >https://www.sitepoint.com/javascript-private-class-fields/</a
              >
              <br />
              See more:
              <a
                href="https://dmitripavlutin.com/javascript-classes-complete-guide/"
              >
                https://dmitripavlutin.com/javascript-classes-complete-guide/ </a
              ><br /> </span
            ><br /><br />

            <i
              >Rewrite the constructor function with ES6 alt ES7 class syntax</i
            >
            <i>+ Add a method that returns all the class properties</i>
            <div class="code-container">
              <code>
                let Person = function(name,gender,age) { <br />
                <span class="example">this.name = name; </span><br />
                <span class="example">this.gender = gender; </span><br />
                <span class="example">this.age = age; </span><br />
                }; <br />
              </code>
            </div>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Spread & Rest Operator</h3>
          <div class="example">
            <p>
              The spread operator will essentially take either an array or an
              object and expands it into its set of items.<br />
              The rest operator is used to create an array from a collection of
              arguments passed to a function.<br />
              It works similar to the built in arguments object used to get all
              arguments passed to a function.
            </p>

            <h4>
              Understanding the impact of the spread operator when copying an
              object
            </h4>
            <p>
              When using the spread operator to copy an objects properties to a
              new object we make a real copy of the original.<br />It's
              important to understand the same goes for arrays, in other words
              spread can be used to make a real copy of an array. We do not copy
              the pointer/reference as is the case when we assign an object or
              array to a new variable.<br />With spread we can avoid the issue
              of an object that is manipulated affecting another object stored
              in a variable with the same pointer/reference. In other words;
              with the spread operator we copy an object in a immutable way and
              not just the pointer/reference to the same.
            </p>

            <div class="code-container">
              <code>
                const myArr = [1,2,3]; <br />
                const newArr = [...myArr,4,5] // newArray will consist of
                [1,2,3,4,5]
                <br /><br />
                myObj = { name: "John" } <br />
                newObj = { ...myObj, surname: "Doe" } // We add props from myObj
                to new Obj <br />
                <br />
                const myFunc = (...args) => { <br />
                <span class="example">return `All arguments ${args}`; </span
                ><br />
                } <br />
                <br />
                console.log(myFunc(1,2,3,4)) <span class="comment-outcome">--> All arguments 1,2,3,4</span>
              </code>
            </div>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Destructuring</h3>
          <div class="example">
            <p>
              When using destructuring we can pull out elements from arrays or
              properties from objects and assign them to variables.<br />
              When it comes to arrays it is very straight forward and we we can
              use any variable name. The order matters tough.<br />
              When it comes to objects the order doesn't matter since we use the
              corresponding property name as variable name.
            </p>

            <div class="code-container">
              <code>
                const personArray = ["John", "Lisa"]<br />
                const [a, b] = ["John", "Lisa"] // We assign the array items to
                variables a and b
                <br /><br />
                const person = { name: "John", age: 28 }<br />
                const {name} = { name: "John", age: 28} // We destructure 'John' to name variable
              </code>
            </div>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Array constructor methods</h3>
          <div class="example">
            <br />
            <h4>Array.from()</h4>
            <p>
              The Array.from() method returns an Array object from any object
              with a length property or an iterable object.
            </p>
            <br />

            <h4>Array.isArray()</h4>
            <span class="link"
              >More about <b>shallow</b> vs <b>deep</b> copy:
              <a
                href="https://www.freecodecamp.org/news/copying-stuff-in-javascript-how-to-differentiate-between-deep-and-shallow-copies-b6d8c1ef09cd/"
                >https://www.freecodecamp.org/news/copying-stuff-in-javascript-how-to-differentiate-between-deep-and-shallow-copies-b6d8c1ef09cd/</a
              ></span
            >
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Object constructor methods</h3>
          <div class="example">
            <i><b>Get the keys and values from the object</b></i
            ><br />
            <i>myObj = { str1: "Hello", str2: "World" }</i><br />

            <i>Extra 1; Good, now show an alternative solution.</i>
            <i
              >Extra 2; Extend your original answer and get the length(quantity)
              of the properties.</i
            >
            <i
              >Extra 3; For what can you use the constructor method
              'hasOwnProperty' and what will it return?</i
            ><br />

            <span
              >Notes: The Object.keys/values will return an array.<br />
              The Object.entries returns an array of arrays.<br />
              An easy way to check if an object is empty is to check the length
              of the 'keys' property in the Object constructor<br />
              You can define how/if a prop can be accessed/changed by using the
              corresponding Object constructor method. </span
            ><br />

            <span
              >Note: 1) Can be done with for/in as well but then it will also
              show props that are inherited by the prototype.</span
            ><br />
            <span
              >Note: 2) The length property on the Object constructor will
              return undefined.</span
            ><br />
            <span
              >Note: 3) It will return(true) for all declared properties even
              those with no value.</span
            >
            <span class="link"
              >See more:
              <a
                href="https://stackoverflow.com/questions/7757337/defining-read-only-properties-in-javascript"
                >https://stackoverflow.com/questions/7757337/defining-read-only-properties-in-javascript</a
              ><br />
              See more:
              <a
                href="https://stackoverflow.com/questions/5515310/is-there-a-standard-function-to-check-for-null-undefined-or-blank-variables-in"
                >https://stackoverflow.com/questions/5515310/is-there-a-standard-function-to-check-for-null-undefined-or-blank-variables-in</a
              >
            </span>
          </div>
        </article>
      </div>
      <!-- End Tutorial part 2 -->

      <span id="questions-part"></span>
      <div class="tutorial-part">
        <h1 class="tutorial-title">Interview Questions</h1>
        <br />

        <div class="question">
          <h3>Fundamentals</h3>
          <br />
          <div class="example">
            <h4>Explain the concepts:</h4>
            <div class="example">
              <p>primitive datatypes</p>
              <p>
                How come we can use properties and methods on primitives as with
                objects?
              </p>
              <p>'undefined'</p>
              <p>Difference between undefined and null</p>
              <p>hoisting</p>
              <p>
                Explain the behaviour of function -expressions vs -declarations
                when it comes to hoisting
              </p>
              <p>global scope vs functional scope</p>
              <p>lexical scope</p>
            </div>
            <br /><br />

            <h4>Variable declaration</h4>
            <div class="example">
              <p>Explain the difference of 'let' vs. 'var'</p>
              <p>When do we use 'const'?</p>
            </div>
            <br /><br />

            <h4>Type coercion and comparison</h4>
            <br />
            <div class="example">
              <p>What do we get?</p>
              
			  <div class="code-container">
                <code>
                  4 + "2" <br />
                  8-"2"*3 <br />
                  (4 + true + "2")/5 <br />
                  4*(3-2)/false <br />
                  Boolean("") <br />
                  true == "1" <br />
                  14%10 > 2 <br />
                  10 - "KYH" <br />
                  "0" == false <br />
					</code>
				<span class="comment-oneline">// "0" is converted to a 'falsy' value but what does it
                    mean?</span><br />
				<code>
					NaN == NaN <br />
                  isNaN("Hello World") <br />
                  (true &lt; 3 &lt; 5) <br />
                  (8 &gt; 5 &gt; 3) <br />
                  (false || Boolean) <br />
                  (33 || false && true) <br />
                  (1 === 1 && "Hello") <br />
                </code>
                <span class="comment-oneline">// 33 and "Hello" are converted to 'truthy' values but what
                    does it mean?</span>
              </div>
            </div>
          </div>
          <br />

          <article class="subject-article">
            <h3 class="subject-title">'use strict'</h3>
            <div class="example">
              <p>
                Why would we use 'use strict' statement in a Javascript file and
                what are the consequences/benefits?
              </p>
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Reverse a String</h3>
            <div class="example">
              <i
                >Return the following string in reverse "Frontend Developer".</i
              >
              <br />
              <i
                >Extra: Show another way to achieve the same result. If not done
                already don't use the reverse method.</i
              >
              <i>Extra: Reverse a collection of type number.</i>
              <br />
              <span>Tip: reverse method only works with arrays.</span><br />
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Arrow functions</h3>
            <div class="example">
              <p>Explain arrow functions</p>
              <i
                >Convert the function to an arrow function and display the
                shortest possible version.</i
              >
              <div class="code-container">
                <code>
                  function doSomething(arg) { <br />
                  <span class="example">return arg * 2</span><br />
                  } <br />
                </code>
              </div>
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Remove Duplicates from an Array</h3>
            <div class="example">
              <i
                >Show if possible two ways to remove duplicates from an
                array.</i
              >
              <i
                >Extra: If not done already, use an object constructor method to
                remove the duplicates.</i
              ><br />
              <span>Note: All results most consist of an array.</span
              ><br /><br />
              <span>Tip: ES6 datatype 'Set' can only hold unique values.</span
              ><br />
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Sort an Array</h3>
            <div class="example">
              <p>
                Sort the array so the lowest number comes first and the highest
                last.
              </p>
			  
              <div class="code-container">
                <code> let numbers = [114,22,4,5,11,41]<br /> </code>
              </div>
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Duplicate an Array</h3>
            <div class="example">
              <i>Duplicate the array, both in pre ES6 as well as ES6.</i>
              <div class="code-container">
                <code> const numbers = [2,4,6,8] <br /> </code>
              </div>
              <i
                >Explain the importance/difference of using the spread operator
                to copy the props of an object -or the elements in an array- vs
                just assigning the object to a new variable?</i
              ><br />
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Keyword this</h3>
            <div class="example">
              <i
                >Explain how 'this' work when used in a stand-alone function
                (not; obj.method).</i
              >
              <i>How does 'this' work when used inside an arrow function?</i
              ><br />
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Destructuring</h3>
            <div class="example">
              <i><b>Destructure (solely) the last item from the array</b></i>
              
			  <div class="code-container">
                <code>
                  <span>const letters = ["A","B","C"] </span>
                </code>
                <br />
              </div>

              <i><b>What is the value of variables; a,c,d ?</b></i>
              <div class="code-container">
                <code>
                  <span>numberArr = [12,4,7] </span><br />
                  <span>const [a=5,, c, d=12] = [...numberArr] </span>
                </code>
              </div>
              <i><b>What do we get?</b></i>
              <div class="code-container">
                <code>
                  <span>const add = (a, b=5, c) => a + b</span><br />
                  <span>add(4)</span>
                  <br />
                </code>
              </div>
              <i><b>How can this be fixed without declaration?</b></i>
              <div class="code-container">
                <code>
                  {a, b} = { a: "Hello", b: "World" } <br />
                  console.log(a,b) // unexpected token... <br />
                </code>
              </div>
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Objects and Object Constructor</h3>
            <div class="example">
              <p>Array.from() ...</p>
              <i
                >Extra 1: Use the Array.from() callback/mapfunction to
                manipulate each item.</i
              >
              <i>Extra 2: How can you check if a passed value is an array?</i>
              <i
                >Extra 3: What does it mean when you do a 'shallow copy' of an
                existing array or object?</i
              ><br />

              <p>
                <b
                  >What could cause a problem when using typeof foo === "object"
                  to determine if foo is an object?</b
                >
              </p>
              <p>Show how to resolve the problem/s</p>
              <br />

              <p>
                <b>Pass the values of the car object to the showCar function</b>
              </p>
              <p>
                Note: the function needs to cope with an unknown numbers of
                arguments
              </p>
			  
              <div class="code-container">
                <code>
                  car = { model: "Volvo", color: "blue", year: "2018" }
                  <br /><br />
                  ??? <br />
                  showCar = (???)=> { <br />
                  <span class="example">return ???; </span><br />
                  } <br />
                  console.log(showCar(???)); // Display car features/values
                </code>
              </div>
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">FizzBuzz</h3>
            <div class="example">
              <i
                >Pretty common question(worth to google it...) present if
                possible 2 solutions</i
              >
              <p>
                Iterate over a 100 numbers.<br />
                When modulus 3 (remainder 0) return Buzz and when modulus 5
                return Fizz.<br />
                If both modulus 3 and 5 return FizzBuzz.
              </p>
            </div>
          </article>
        </div>
      </div>
      <div class="go-top"><a href="#top">To the Top</a><br /></div>
    </div>
    <script>
	
      // Toggles code color
      const btnChangeColor = document.querySelector(".btn-change-color");
      const codeContainers = document.querySelectorAll(".code-container");
      const changeCodeColor = () => {
        Array.from(codeContainers, container => {
          container.classList.toggle("code-container-mod");
        });
      };
      btnChangeColor.addEventListener("click", changeCodeColor);
		
	/*
	function blockScope(num) {
		for(let i = 1; i < num; i++) {
		console.log(i) //--> 1,2,3,4,5
		var b = "I exist in function scope"
		}
		console.log(b) //--> I exist in function scope
		console.log(i) //--> ReferencError, i is not defined
	}
	blockScope(5);
		*/
		
    </script>
    <noscript>Your browser does not support JavaScript!</noscript>
  </body>
</html>
