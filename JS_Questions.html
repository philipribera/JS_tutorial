<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="description" content="Free Javascript Guide with Questions" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="author" content="Philip R" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Javascript Questions</title>
    <!-- GOOGLE FONTS -->
	<link href="https://fonts.googleapis.com/css?family=Montserrat&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Poppins&display=swap" rel="stylesheet">
    <!-- END FONTS -->
    <style>
        * {
            box-sizing: border-box;
            outline: none;
            padding: 0;
            margin: 0;
        }
        
        body {
            font-family: helvetica, roboto, sans-serif;
            background-color: rgb(222, 221, 221);
        }
        
        header {
            width: 100%;
            height: 68px;
            position: fixed;
            top: 0;
            background-color: rgb(232, 141, 82);
            background-color: rgb(189, 189, 189);
            box-shadow: 1px 1px 1px 1px rgb(157, 157, 157);
            z-index: 9999;
        }
        
        .header-container {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            padding: 0 5%;
        }
        
        .header-title {
            margin-right: auto;
            flex: 1 0 472px;
        }
        
        .header-title h3 {
            font-size: 1.4rem;
            color: rgb(109, 109, 109);
            color: rgb(254, 254, 254);
            text-shadow: 1px 1px rgb(167, 167, 167);
        }
        
        .header-menu {
            display: flex;
            justify-content: flex-end;
            flex: 1 0 310px;
        }
        
        .header-menu a {
            font-family: "Montserrat", roboto, sans-serif;
            color: rgb(47, 47, 47);
            font-weight: 600;
        }
        
        .header-menu ul li {
            display: inline;
            cursor: pointer;
            padding: 14px;
            margin: 0;
        }
        
        .header-menu ul a:hover {
            color: rgb(255, 159, 32);
            color: rgb(255, 255, 255);
        }
        
        .wrapper {
            position: relative;
            display: block;
            width: 100%;
            max-width: 950px;
            background-color: rgba(255, 255, 255, 1);
            color: rgb(35, 35, 35);
            padding: 30px 3.5rem;
            margin: 42px auto;
        }
        /*** GENERICS ***/
        
        p {
            font-family: 'Merriweather Sans', roboto, helvetica, sans-serif;
            font-family: roboto, helvetica, sans-serif;
            font-family: 'Poppins', roboto, helvetica, sans-serif;
            font-family: "Montserrat", roboto, sans-serif;
			font-family: 'open-sans', poppins, roboto, helvetica, sans-serif;
            color: rgb(43,43,43);
            margin: 2px 0;
        }
        
        h1,
        h2,
        h3 {
            font-family: 'Montserrat', roboto, helvetica, sans-serif;
            color: rgb(242, 147, 38);
        }
        
        h1 {
            font-size: 2rem;
        }
        
        h3 {
            font-family: 'Merriweather Sans', 'Montserrat', roboto, helvetica, sans-serif;
            font-size: 1.5rem;
        }
        
        h4 {
            font-family: 'Poppins', 'Merriweather Sans', 'Montserrat', roboto, helvetica, sans-serif;
            font-size: 1.2rem;
            color: rgb(27, 27, 27);
            margin: 32px 0 12px 0;
        }
        
        ul {
            padding: 4px;
            margin-left: 14px;
        }
        
        li {
            list-style-type: none;
            padding: 0 4px;
        }
        
        a {
            color: rgb(133, 133, 133);
            text-decoration: none;
        }
        
        p,
        span,
        b {
            color: rgb(37, 37, 37);
            line-height: 1.55rem;
        }
        
        code {
            font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New', monospace;
            font-size: 1rem;
            line-height: 1.72rem;
            color: rgb(20, 61, 81);
        }
        /*** CLASSES ***/
        
        .expand-text {
            font-size: 1.1rem;
            color: rgb(41, 54, 103);
        }
        
        .tutorial-title {
            margin: 22px 0 24px 0;
        }
        
        .log-list-title {
            font-weight: 600;
        }
        
        .log-list {
            margin: 22px 0 30px 0;
        }
        
        .log-list li {
            display: flex;
            padding: 3px;
            border-bottom: 1px solid rgb(212, 212, 212);
        }
        
        .log-list li:first-child {
            font-weight: 600;
            padding-bottom: 6px;
        }
        
        .log-list li:last-child {
            flex: 1;
        }
        
        .info-list {
            display: inline-block;
            min-width: 102px;
            margin-right: 14px;
        }
        
        .go-top {
            position: absolute;
            bottom: 0;
            left: 0;
            padding: 4px 0;
        }
        
        .go-top a {
            font-size: 1rem;
            font-weight: 600;
            text-decoration: none;
            cursor: pointer;
            background: rgb(222, 222, 222);
            color: rgb(42, 96, 117);
            padding: 4px 6px;
            border: 1px solid rgb(190, 190, 190);
        }
        
        .go-top a:hover {
            opacity: 0.95;
        }
        
        .tutorial-part {
            padding: 28px 28px 30px 28px;
        }
        
        .tutorial-part:not(:first-of-type) {
            margin-top: 24px;
        }
        
        .tutorial-part:not(:nth-last-child(2)) {
            border-bottom: 4px solid rgb(207, 207, 207);
        }
        
        .subject-article {
            display: inline-block;
            width: 100%;
            margin: 18px 0 20px 0;
        }
        
        .subject-title {
            margin-bottom: 18px;
        }
        
        .example {
            margin-left: 14px;
        }
        
        .example2 {
            margin-left: 28px;
        }
        
        .example3 {
            margin-left: 42px;
        }
        
        .link {
            font-family: roboto, helvetica, sans-serif;
            word-break: break-all;
            display: inline-block;
            background-color: rgb(253, 247, 237);
            color: rgb(123, 123, 123);
            font-weight: 600;
            padding: 2px;
            margin: 12px 0 10px 0;
        }
        
        .code * {
            word-break: break-all;
        }
        
        .code-container {
            position: relative;
            background-color: rgb(238, 238, 238);
            padding: 20px 24px 24px 24px;
            margin: 20px 0 24px 0;
            overflow: auto;
        }
        
        .code-container i {
            color: rgb(37, 63, 110);
            line-height: 2.15rem;
        }
        
        .code-container .comment-oneline {
            display: block;
            color: rgb(41, 54, 103);
            opacity: 0.95;
            font-weight: 600;
            margin: 22px 0 12px 0;
        }
        
        .subject-article .code-container:first-child {
            margin-top: 0;
        }
        
        .emphasize-gray {
            background-color: rgb(228, 228, 228);
            background-color: rgb(241, 241, 229);
            font-weight: 500;
            padding: 0 4px;
        }
        
        .emphasize-gray-wide {
            background-color: rgb(224, 224, 224);
            font-weight: 600;
            letter-spacing: 0.25em;
            padding: 0 2px;
        }
        
        .code-container .code-comment {
            color: rgb(109, 109, 112);
            padding-left: 18px;
        }
        
        .code-container-mod {
            background-color: rgb(9, 9, 9);
        }
        
        .code-container-mod code,
        .code-container-mod code span {
            color: rgb(74, 249, 105);
            color: rgb(240, 158, 255);
            color: rgb(84, 231, 255);
        }
        
        .code-container-mod .comment-oneline,
        .code-container-mod i,
        .code-container-mod .expand-text {
            color: rgb(237, 238, 237);
            color: rgb(255, 175, 75);
        }
        
        .code-container-mod .code-comment {
            color: rgb(228, 199, 63);
        }
        
        .code-container-mod span.comment-outcome {
            color: #62ff2e;
            color: rgb(212, 200, 80);
        }
        
        .question {
            margin-bottom: 54px;
        }
        
        .btn-change-color {
            position: absolute;
            right: 0;
            top: 0;
            cursor: pointer;
            background: rgb(45, 45, 45);
            color: rgb(222, 222, 222);
            padding: 6px;
            border: 1px solid rgb(102, 102, 102);
        }
        
        #fundamentals,
        #es6,
        #questions-part {
            display: block;
            position: relative;
            top: -120px;
            visibility: hidden;
        }
        
        code span.comment-outcome {
            white-space: nowrap;
            font-weight: 600;
            color: rgb(82, 101, 167);
            padding-left: 6px;
        }
        
        .note-comment {
            line-height: 1.3em;
            background-color: rgb(255, 226, 168);
            padding: 16px 12px;
            margin: 30px 0;
        }
        
        .note-comment,
        .code-container {
            border-radius: 3px;
        }
        
        .first-word {
            color: rgb(37, 37, 37);
            font-weight: 600;
        }
        
        .standard-list {
            width: 30%;
            padding: 12px 4px;
            margin: 4px 0;
        }
        
        .standard-list li {
            background-color: rgb(250, 250, 250);
            padding: 8px;
            border-left: 1px solid rgb(222, 222, 222);
            border-bottom: 1px solid rgb(241, 241, 241);
        }
        
        .standard-list li:nth-child(odd),
        .log-list li:nth-child(even) {
            background-color: rgb(240, 240, 240);
        }
        
        .list-comment {
            padding-left: 12px;
        }
        /*** MEDIA QUERIES ***/
        
        @media only screen and (max-width: 990px) {
            header {
                height: auto;
            }
            .header-container {
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 12px;
                margin: 0;
            }
            header .header-menu,
            header .header-title {
                flex: 1 0 100%;
                margin: 0;
                text-align: center;
                justify-content: center;
            }
            .header-title h3 {
                margin: 10px 8px;
            }
            .wrapper {
                width: inherit;
                padding: 30px 2.5rem;
                margin: 92px 0 0 0;
            }
            .tutorial-part {
                padding: 20px;
            }
            .code-container {
                padding: 20px;
            }
            h1 {
                font-size: 2rem;
            }
            h3 {
                font-size: 1.45rem;
            }
        }
        
        @media only screen and (max-width: 767px) {
            .wrapper {
                padding: 16px;
            }
            .tutorial-part {
                padding: 6px;
            }
            .subject-article {
                margin: 20px 0;
            }
            .example {
                margin-left: 10px;
            }
            .example2 {
                margin-left: 22px;
            }
            .example3 {
                margin-left: 32px;
            }
            .code-container {
                padding: 20px 14px;
            }
            .note-comment {
                padding: 12px;
                margin: 24px 0;
            }
            .info-list {
                min-width: 70px;
            }
            h1 {
                font-size: 1.95rem;
            }
            h3 {
                font-size: 1.4rem;
            }
            h4 {
                font-size: 1.15rem;
            }
            i {
                line-height: 1.6rem;
            }
            .info-list {
                margin-right: 6px;
            }
            .falsy-list {
                width: 70%;
                padding: 10px 2px;
                margin: 0;
            }
            .code-container .code-comment {
                padding-left: 8px;
            }
        }
        
        @media only screen and (max-width: 600px) {
            .wrapper {
                padding: 10px;
                margin: 110px 0 0 0;
            }
            .header-container {
                display: flex;
                flex-wrap: wrap;
                text-align: center;
                justify-content: center;
                height: auto;
                padding: 10px;
            }
            .header-title {
                display: block;
                margin-bottom: 10px;
            }
            .header-title h3 {
                font-size: 1.15rem;
                margin: 6px;
            }
            .header-menu {
                justify-content: center;
            }
            .header-menu ul,
            .header-menu li {
                padding: 12px 7px 4px 7px;
            }
            .collapsed-menu {
                display: block;
            }
            .wrapper {
                width: initial;
            }
            .code-container {
                padding: 18px 12px;
            }
            h1 {
                font-size: 1.8rem;
            }
            .example {
                margin-left: 0;
            }
        }
    </style>
</head>

<body>
    <header class="header-container">
        <div class="header-title">
            <h3>JAVASCRIPT FUNDAMENTALS WITH QUESTIONS(WIP)</h3>
        </div>
        <div class="header-menu">
            <ul>
                <li><a href="#fundamentals">Fundamentals</a></li>
                <li><a href="#es6">ES6</a></li>
                <li><a href="#questions-part">Questions</a></li>
            </ul>
        </div>
    </header>

    <div class="wrapper">
        <span id="fundamentals"></span>
        <div class="tutorial-part">
            <h1 class="tutorial-title">Javascript Fundamentals</h1>

            <article class="subject-article">
                <h3 class="subject-title">About this Tutorial</h3>
                
              	<p>				
                    This tutorial will not focus on syntax rules or describe the basic terminology for a programming language. There are already good tutorials that explains the core basic in detail. If you feel that your knowledge is lacking when it comes to the core basic please make sure to start with learning that before looking in to this tutorial. 
										
					This tutorial will explain some key concepts to get a better understanding on how Javascript works under the hood. There is also a chapter dedicated to the ECMAScript 2015(ES6) update and the new features that was introduced with it. The ES6 update was probably the most important development of Javascript since its introduction making Javascript significantly more powerful and versatile.					
                </p>

                <div class="note-comment">
                    <span class="first-word">Note: </span> The <i>var</i> keyword will be used in code examples until the section 'Variable Scope' where variable declarations are explained more in depth.
                </div>
            </article>

            <article class="subject-article">
                <h3 class="subject-title">Introduction</h3>
				<p>
                    Javascript is the language of the web, it is an interpreted language that runs directly on the clients browser meaning that no compiler is needed. This is the core of Javascript; It was designed to be easy to use and easy to learn. It also explains some
                    of its characteristics, strengths and drawbacks, that differentiate it from some of the most common programming languages. But Javascript has evolved a lot since its introduction and with the latest updates it has become a much more
                    versatile language. Now days Javascript isn't limited to the browser neither. With the help of <em>Node</em>, runtime environment, we can run Javascript on the server side as well. 
                </p>
				<!--
				<h4>The Callstack and the Event Loop</h4>
                <p>Javascript is a single threaded programming language, meaning it can handle one task at a time. All instructions are stored in a single call stack where everything is placed in a queue. This is what constitutes the Javascript Concurrency Model...  We are not going to dwelve deeper into this here but the important thing to take with you is that Javascript executes one piece of code at a time according to the order in the callstack. If you are interested in reading more on this I have a link to an article that explains it in detail here below.
                </p>
				<div class="link"
              >See more;
              <a
                href="https://medium.com/@gaurav.pandvia/understanding-javascript-function-executions-tasks-event-loop-call-stack-more-part-1-5683dea1f5ec"
                >https://medium.com/@gaurav.pandvia/understanding-javascript-function-executions-tasks-event-loop-call-stack-more-part-1-5683dea1f5ec</a
              ></div>
				--> 
				
                <h4>Dynamically typed</h4>
                <p>	
					Javascript is what we call a <em>dynamically typed</em> programming language meaning that the type of a variable will be interpreted by the compiler. The types will be interpreted and if necessary even change implicitly when the program executes the commands, what is known as <em>runtime</em>. The type and value of a variable can be changed at any time in a process known as <em>type conversion</em>. This can be both explicitly in the code or implicitly by the Javascript engine.
									
					Programming languages where the type of a variable is not specified when declared is also said to be <em>weakly</em> typed. The contrary being known as <em>strongly</em> or <em>static</em> typed languages where a variable has to be given a type when it's declared. 
					</p><br />
					
					<p>
					The behaviour of type conversion can be confusing if not understood fully and lead to unexpected outcomes due to what is called <em>logical mistakes</em>. Meaning there are no technical errors at runtime but the outcome is still buggy and does not correspond to what was to be expected. But before looking deeper into these concepts we need to get a better understanding on data types and how they behave in Javascript.					
					</p>               

                <h4>Data Types</h4>
                <p>
                    Data types specify what kind of data can be stored and manipulated in the Javascript memory. In Javascript types are either objects or primitives. When learning JavaScript you might have heard that everything in Javascript is an object. The truth is that
                    most things in Javascript are objects, the exception being primitive types. Tough they can still be treated as objects, albeit with some restrictions. While there is only one <em>object</em> data type there are
                    7 primitive data types. The fundamental difference between primitives and objects is that primitives can hold a single value while objects can hold a collection of values.
                    <!--The concept of data types and how they work in a boolean context and Type Coercion is central to understand how Javascript works.-->
                </p>
				
				<div class="note-comment">
                    <span class="first-word">Note: </span> The <em>typeof</em> operator is used to check the type of an operand. It's used without parenthesis and will return the type as a string.
                </div>				
                
            </article>

            <article class="subject-article">
                <h3 class="subject-title">Primitive Types</h3>
                <p>
                    In Javascript we have 7 primitive types: <em>string, number, boolean, null, undefined, bigInt</em> and <em>symbol</em>. Primitives can only hold a single value unlike objects that can hold a collection of data and values. Neither can
                    they have properties and methods. But Javascript can treat primitives as objects, making it possible to apply properties and methods on primitive values. Javascript does this by wrapping the primitive value in an object-kind of entity.
                    One example is the <em>length</em> property that can be applied on strings. But even if primitives can behave as objects there are some important differences. Apart from only being able to hold a single value they are also non-mutable.
                    Meaning that assigning a value to a variable that already holds a value replaces this value with a new value, it doesn't mutate/change the original value. This is the reason mutator methods - <em>methods that change the original value</em>                    - can not be applied on primitives. Another important distinction is that primitive values are passed by <em>copying the value</em> unlike objects that <em>pass value by reference</em>. Meaning that if a primitive variable is assigned
                    to a new variable the orginal value is copied to the new variable. The copied value can then be changed without affecting the value of the original variable.
                </p>

                <div class="code-container">
                    <button class="btn-change-color">Change Theme</button>
                    <div class="comment-oneline">Values are passed by copying</div>
                    <code>
				var a = "Hello"								<br />
				var b = a 	<span class="code-comment">// we assign 'a' to 'b'	</span><br />
				b = "World"	 <span class="code-comment">// we assign a new value to 'b' </span><br />
				console.log(a) <span class="comment-outcome"> --> Hello </span><span class="code-comment">// the value of 'a' doesn't  change	</span><br />			  
              </code>
                    <div class="comment-oneline">
                        We use the length property on a primitive
                    </div>
                    <code>
                var str = "Hello World"<br />
                console.log(str.length) <span class="comment-outcome"> --> 11</span> <span class="code-comment">// we get the numbers of characters</span><br />
                 </code>
                    <div class="comment-oneline">
                        Primitive values do not mutate
                    </div>
                    <code>
                var foo = "Hello World" <br />
                console.log(foo.toUpperCase()) <span class="comment-outcome"> --> HELLO WORLD</span> <span class="code-comment">// we use a method on foo</span><br />
                console.log(foo) <span class="comment-outcome"> --> Hello World</span> <span class="code-comment"> // the original value is
                unchanged</span><br /> </code
              >				
              
  				<div class="comment-oneline">We can do this</div>
				<code>
               foo[0] <span class="comment-outcome"> --> H</span> <span class="code-comment">// we get the 1st character</span><br /> 
			   </code>
                    <div class="comment-oneline">But not this...</div>
                    <code>
                foo[0] = "T" <span class="code-comment">// we try to assign foo[0] a new value</span><br />
                console.log(foo) <span class="comment-outcome"> --> Hello World</span><span class="code-comment">// value of 'foo' doesn't change </span><br />
				</code>				

                <div class="comment-oneline">We check for the datatype</div>
                    <code>			
					var age = 44	<br />
					console.log(typeof age) <span class="comment-outcome">--> 'number'</span><br />
				</code>				
                </div>

                <div class="link">See more;
                    <a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive">https://developer.mozilla.org/en-US/docs/Glossary/Primitive</a
              ></div><br />
            
            <h4>string</h4>
            <p>The string type holds data that can be represented as text. String values consists of normal characters, special characters can be encoded using the escape character '<span class="emphasize-gray-wide"> \</span>'. In Javascript strings can be denominated with both single and double quotes. With ES6 support was also added for 'template literals'. Template literals adds versatility and allows for variables and expressions to be embedded with string literals. (we will cover template literals further in the next chapter). 
			</p>
			
			<div class="code-container">			
				<div class="comment-oneline">Some common methods used with strings</div>
				<code>
                var greet = "Hello World"		 				<br />                
				greet.charAt(0) <span class="comment-outcome">--> H</span>	<br />
				greet[0] <span class="comment-outcome">--> H </span><span class="code-comment">// we use bracket notation</span><br />
				greet.indexOf("W")<span class="comment-outcome"> --> 6</span><br /><br />

                var str = new String("KYH Frontend") <span class="code-comment">// we use the string object constructor  				</span><br />
            </code>
			</div>			
			
			<div class="note-comment">
              <span class="first-word">Note: </span>Strings being primitives means we can't use them with mutator methods (methods that changes the original value).
			</div>
			
            <h4>number</h4>         
            <p>
              In Javascript we only have one type for numbers. There is no
              distinction for integers, floats etc. 
			  Besides numbers the number data type also consist of so called, special numeric values as <i>NaN</i>, <i>Infinity</i> and <i>-infinity</i>.  
			</p>			
	          		
            <div class="code-container">
			<div class="comment-oneline">The Math object in Javascript is
              used to perform mathematical tasks on numbers</div>
              <code>
                var floatNumber = 1.55 <br />
                Math.round(floatNumber) <span class="comment-outcome">--> 2</span> <span class="code-comment">// will round to closest integer</span>
                <br /><br />
                var num1 = 2.3 <br />
                var num2 = 1.4 <br />
                Math.floor(num1 + num2) <span class="comment-outcome">--> 3</span> <span class="code-comment">// will round downwards to closest integer </span><br /><br />
                Math.max(4,7,9,11) <span class="comment-outcome">--> 11</span><br />
                Math.min(4,7,9,11) <span class="comment-outcome">--> 4</span><br />
                var numbers = [4,7,9,11]; <br />
                Math.max(numbers) <span class="comment-outcome">--> NaN</span> <span class="code-comment">// Math max/min do not work with arrays</span><br />
              </code>

              <div class="comment-oneline">
                To solve this we can use ES6 features as spread or reduce
              </div>
              <code>
                Math.max(...numbers) <span class="comment-outcome">--> 11</span><br /><br />
                var rand; <br />
                Math.random(rand) <span class="comment-outcome">--> ?</span> <span class="code-comment">// returns a floating-point between 0 and 1</span>
              </code>
			  </div>			  
			  
				<p>
			   If a Math function can't convert an argument to a number and/or a required type coercion to number fails the return value is <strong><em>NaN</em></strong>, meaning; not a number.
				To check for NaN do <strong>not</strong> compare; <span class="emphasize-gray">NaN === NaN</span>, this returns false since type of NaN is number. The <em>isNaN</em> function has to be used instead, <span class="emphasize-gray">isNaN(argument) === NaN</span>.
				 With ES6 we can use <span class="emphasize-gray">Number.isNaN(value)</span> to check if a value is NaN. Be aware that this will only return true if the value already is NaN, unlike isNaN that will return true if the value can't be converted to a number.   
			</p>
				<div class="link"
              >See more;
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN"
                >https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN</a
              ></div>
			
			<div class="code-container">
				<code>
					var number = 12			<br />
					var str = "Hello"		<br />
					console.log(number * str) <span class="comment-outcome">--></span> NaN <span class="code-comment">// str can't be coerced to type number	</span><br />
					</code>
					<div class="comment-oneline">We check for NaN</div>
					<code>
					if( isNaN(str) ) {					<br />
					<span class="example">	str = 4		<span class="code-comment">// if NaN we assign the value 4 to str</span></span><br />
					}									<br />
					console.log(number * str) <span class="comment-outcome">--> 48</span><br />
				</code>			
			</div>            

            <h4>undefined</h4>
            <p>
              <em>undefined</em> is a primitive datatype and a so
              called <em>falsy</em> value. It's important to not confuse <em>falsy</em> as
              'false', the latter being of type Boolean. Javascript will
              automatically assign <em>undefined</em> to a variable that are not
              initialized. In other words a variable that has been declared but not given a value will always return undefined. 
              A function that doesn't return a value will always return <em>undefined</em>. To check for <em>undefined</em> we use the <em>typeof</em> operator.
            </p>

            <div class="code-container">
              <div class="comment-oneline">
                If we try to use a variable before being declared
              </div>
              <code> console.log(a); <span class="comment-outcome">--> referenceError </span><br /> 
			  </code>
              <div class="comment-oneline">
                If we don't initialize a variable
              </div>
              <code> var a; <span class="code-comment">// assign the value 'undefined' </span></code
              ><br />
              <div class="comment-oneline">But we can also do this</div>
              <code>
                var a = undefined; <span class="code-comment">// we assign 'a' the value 'undefined'</span><br />
                </code>
			  <div class="comment-oneline">We check for <em>undefined</em></div>
                <code>
				if ( typeof a === 'undefined') <span class="comment-outcome">--> true</span> <span class="code-comment">// remember to use quotes!</span></code
              >
			  </div>
			<div class="note-comment">
              <span class="first-word">Note: </span><em>undefined</em> is not an error in it self but it's often the cause of bugs in the code.
			</div>	            
           
            <h4>null</h4>
            <p>
              <em>null</em> is a primitive value and a keyword in JavaScript that means
              ‘no value’ or nonexistence of any value. null is also considered a <em>falsy</em> value. The type of null tough is
              object while <em>undefined</em> has its own type. The fact that null is considered a primitive value and its type is object (non-primitive) is a bug from the time Javascript was designed. The best way to understand null is to interpret it as something that does not exist. If the purpose is to give a variable an empty value it can be done by assign it the value null, representing no value. It could be said that null has the same purpose/functionality for objects as undefined for primitives with the difference that the latter has its own type while null hasn't.
            </p>
            
            <div class="code-container">
              <code>
                var b = null; <br />
                typeof b <span class="comment-outcome">--> object</span> <span class="code-comment">// null basically means empty object </span><br />
                if (b === null) <span class="comment-outcome">--> true </span><span class="code-comment">// we check for null </span></code
              >
            </div>
			
			<h4>Boolean</h4>
			<p>
			Boolean type has only two values <em>true</em> or <em>false</em>. Its primary use is for controlling program flow using conditional statements. Noteworthy; Any object that is not <em>undefined</em> or <em>null</em> will always evaluate to true. 			
			</p>			
			<div class="code-container">
			<div class="comment-oneline">A simple expression that evaluates to true</div>
				<code>
					if (10 > 5) {		<br />
					<span class="example">console.log('This is true')</span> // code block will execute	<br />
					}	<br />	
				</code>
				<div class="comment-oneline">We pass an object with a <em>falsy</em> value</div>
				<code>					
					const myObj = new Object(false)	<br />
					if(myObj) {													<br />
					<span class="example">console.log("I'm true") <span class="comment-outcome">--> "I'm true"  </span></span><br />
					}														<br />
				</code>
				<div class="comment-oneline">We pass a primitive with a false value</div>
				<code>
					const foo = 0	<span class="code-comment">// we assign a <i>falsy</i> value to 'foo'</span><br />
					if(foo) {						<br />
					<span class="example">console.log("nothingHappens") 	<span class="code-comment">// will not execute	
					</span></span><br />
					} else {													<br />
						<span class="example">console.log("I'm false")	<span class="comment-outcome">--> "I'm false"</span><span class="code-comment">// will execute</span></span><br />
					}				
				</code>				
			</div>
        </article>
		
		<article class="subject-article">
          <h3 class="subject-title"><em>truthy</em> and <em>falsy</em></h3>
			<p>
			All values in Javascript can be said to be either <em>truthy</em> or <em>falsy</em> i a Boolean context. This should not be confused with <em>true</em> or <em>false</em> that are of type Boolean. <em>truthy</em> and <em>falsy</em> have no data type in its own, a string for example is of type string no matter its inherent boolean value. To simplify there are six falsy values and all other values are considered to be truthy.
			</p><br />
			
				<p class="log-list-title">Values considered falsy:</p> 
				<ul class="standard-list">
				<li><i>false</i></li>
				<li><i>0</i></li>
				<li><i>undefined</i></li>
				<li><i>' '</i> or <i>" "</i><span class="list-comment">// empty string</span> </li> 
				<li><i>NaN</i></li>
				<li><i>null</i></li>
				</ul>
				
			<p>
			So why do we have <em>truthy</em> and <em>falsy</em> in Javascript?  
			In JavaScript all values, no matter its type, will be considered either true or false when encountered in a Boolean context. In other words; A condition where one or more values are set in a boolean context will result in either a true or false outcome. The typical situation being an if statement where a block of code will be excecuted depending on if the condition will be considered true or false. The boolean context can consist of values of any type but they will always have an inherent boolean value as either <em>truthy</em> or <em>falsy</em> and the condition where they are set will evaluate to either true or false.  
			</p>
			
			<div class="code-container">
				<code>
					if(1) {		<br />
							<span class="example">console.log("Hello") <span class="comment-outcome">--> Hello</span> <span class="code-comment">// 1 will be considered <i>truthy</i> </span></span><br />
					}				<br />	
					<br />
					var a;	<span class="code-comment">// 'a' is not initialized and will get the <i>falsy</i> value 'undefined'</span><br />
					if(a) {		<br />
					<span class="example">	console.log("I'm true");  </span>	 <br />
					} else {	<br />
					<span class="example">console.log("I'm false")</span> <span class="comment-outcome">--> I'm false </span><span class="code-comment">// the condition evaluates to false</span><br />
					} <br />
				</code>
			</div>			
		</article>		 
		
		<article class="subject-article">
          <h3 class="subject-title">Hoisting</h3>
            <p>
              The definition of hoisting in Javascript is basically that functions and declarations of
              variables are moved to the top of the code when
              compiled. This means that a variable can be used  even before it has been initialized. It's important to remember that variables declared with <em>let</em> will not be hoisted.
			One of the benefits with hoisting is that functions being hoisted as well makes it possible to use them anywhere in your code. 			  
			  The concept of Hoisting can be the source for confusion, not least since the written code is only moved in the memory not physically. 
            </p><br />
            <p>
              If we call a variable declared with <em>var</em> before it has been initialized it's value will be <em>undefined</em> and <em>undefined</em> being a valid value, even having its own type, will not result in an error. The same applies for function expressions being an expression assigned to a variable since it's only the declaration that is hoisted.           
            </p>
            <div class="link"
              >See more;
              <a
                href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting"
                >https://developer.mozilla.org/en-US/docs/Glossary/Hoisting</a
              >
            </div>

            <div class="code-container">
              <div class="comment-oneline">
                Variable declarations are hoisted inside functions as well
              </div>
              <code>
                var testScope = function() { <br />
                <span class="example">console.log(y);</span><br />
                <span class="example">var y = 1; </span><br />
                } <br />
                testScope(); <span class="comment-outcome">--> undefined</span><br /> </code
              ><br />

              <div class="comment-oneline">
                Anonymous function expressions are not hoisted
              </div>
              <code>
                var y = 2; <br />
                var testScope = function() { <br />
                <span class="example">console.log(y); <span class="code-comment">// we try to access y before it has been initialized</span></span><br />
                <span class="example">var y = 1; </span><br />
                } <br />
                testScope(); <span class="comment-outcome">--> undefined </span><br />
              </code>

              <br />
			  <div class="comment-oneline">
                Here y is not redeclared inside the function
              </div>
              <code>			  
                var y = 2; <br />
                var testScope = function() { <br />
                <span class="example"> console.log(y);</span><br />
                } <br />
                testScope(); <span class="comment-outcome">--> 2</span><br />
              </code>			  
            </div>
        </article>
		
		<article class="subject-article">
          <h3 class="subject-title">Variable Scope</h3>
            <p>
              When talking about variable scope we are in essence referring to
              which scope a variable is accessible. In other words where we can look/access variables or functions.
              For a long time Javascript variable declarations were either
              global or function scoped. The latter sometimes also called local
              scope. A variable accessible anywhere in our code is said to exist
              in the global scope while a variable accessible inside a function
              exist in the local scope of the function where it was declared. With the ES6 update and the introduction of the keyword <em>let</em> for declaring variables we now also have <em>block scope</em>. A variable declared with <em>let</em> will only be accessible inside the block where it was declared. This can for example be inside the block restricted by a for loop that exist inside a function.
			</p><br />            
            <p>
              When it comes to function scope it's also important to understand
              the concept of lexical scope sometimes also called Static
              scope. Lexical scope is the concept of a variable being accessible
              inside nested blocks, typically function or block scopes inside an outer function. 
              </p>
			  <div class="code-container">
			  
			  <div class="comment-oneline">Global Scope</div>
				<code>
				let a = "Hello"	<span class="code-comment">// we create a global variable	</span><br />
				
				function() {			<br />
				<span class="example">	console.log(a)	<span class="comment-outcome">--> "Hello"</span> <span class="code-comment">// a is accessible everywhere in our code </span></span><br />
				}	<br />
				</code>
				
				<div class="comment-oneline">Block Scope</div>
				<code>
				let numbers = [1,2,3,4,5]											<br />
				for(let i = 0; i &lt; numbers.length; i++) {						<br />
				<span class="example2">	console.log(numbers[i]) <span class="comment-outcome">--> 1,2,3,4,5		</span></span><br />	
				}											<br />
				console.log(i) <span class="comment-outcome">--> referenceError </span><span class="code-comment">// i does not exist outside its block scope </span><br />
				</code>
			  
			  <div class="comment-oneline">Lexical Scope</div>
			  <code>
                function outerFunction() { 							<br />
				<span class="example2">	var a = "I'm from outside";					</span><br />
				<span class="example2">	function innerFunction() {					</span><br />
				<span class="example3">		console.log(a)	<span class="comment-outcome">-->	I'm from outside	</span></span><br />
				<span class="example2"> }</span><br />
				}	
				</code>	
			</div>
        </article>     

		<!--
         <article class="subject-article">
          <h3 class="subject-title">Operators</h3>
		  <p>
              JavaScript has <em>operators</em> that perform some operation on a single or multiple <em>operands</em> (data value). 
              There are at least 10 different kinds of operators in Javascript, one being the assignment operator <span class="emphasize-gray">=</span> which assign a value to a variable, another being arithmetic operators as <span class="emphasize-gray">+</span><span class="emphasize-gray">-</span><span class="emphasize-gray">/</span> that performs arithmetic operations.
              In this tutorial we will look deeper into a few of these, among them <em>Comparison</em> operators due to their importance for understanding how Javascript handles <em>type coercion</em>.     
            </p>-->
            
			<article class="subject-article">
          <h3 class="subject-title">Comparison & Logical Operators</h3>
            <p>
			JavaScript has <em>operators</em> that perform some operation on a single or multiple <em>operands</em> (data value). 
              There are at least 10 different kinds of operators in Javascript, In this tutorial we will look deeper into a comparison and logical operators due to their importance for understanding how Javascript handles <em>type coercion</em>.
			</p>		  
			
			<h4>Comparison Operators</h4>
			<p>			  
              The rules for type conversions in Javascript can be confusing and give unexpected outcomes if not understood fully.               
              It's not least important to understand the difference between the
              double equality operator <span class="emphasize-gray">==</span> and the tripple equality
              operator <span class="emphasize-gray">===</span> when comparing values. Javascript have different rules for using the double equality operator often called 'loose' equality operator' versus the tripple one being the 'strict' equivalent. The loose equality operator compares the value but not
              the data type vs. the latter that compares both. There are no formal rule for
              which comparison to use but most safe is to use the tripple comparison. 
			  That said there can
              be situations where a non-strict comparison operator can have it's
              benefits. No matter which one is used it's important to understand
              how they work and the implications of using one over the other. We will look deeper into how Javascript behaves when implicitly changing the type of an value in the section about <em><a href="#type-coercion">type coercion</a></em>.
                    </p><br />

                    <p class="log-list-title">All Comparison Operators</p>
                    <ul class="log-list">
                        <li>
                            <span class="info-list">Operator</span>
                            <span class="info-list">Description</span>
                        </li>
                        <li>
                            <span class="info-list">==</span>
                            <span class="info-list">Loose Equality</span>
                        </li>
                        <li>
                            <span class="info-list">===</span>
                            <span class="info-list">Strict Equality</span>
                        </li>
                        <li>
                            <span class="info-list">!=</span>
                            <span class="info-list">Not Equal</span>
                        </li>
                        <li>
                            <span class="info-list">!==</span>
                            <span class="info-list">Strict not Equal</span>
                        </li>
                        <li>
                            <span class="info-list">&gt;</span>
                            <span class="info-list">Greater than</span>
                        </li>
                        <li>
                            <span class="info-list">&lt;</span>
                            <span class="info-list">Less than</span>
                        </li>

                        <li>
                            <span class="info-list">&gt;=</span>
                            <span class="info-list">Greater or equal to</span>
                        </li>
                        <li>
                            <span class="info-list">&lt;=</span>
                            <span class="info-list">Less or equal to</span>
                        </li>
                    </ul>

                    <div class="code-container">
                        <code>
                if(1 == "1") <span class="comment-outcome">--> true</span> <span class="code-comment">// will first type coerce from type string to type number and then makes the comparison</span><br />
                <br />
                if(1 === "1") <span class="comment-outcome">--> false</span> <span class="code-comment">// strict equality will check for both value and type
                </span><br />
              </code>
                    </div>

                    <h4>Logical Operators</h4>
                    <p>
                        Logical operators are used to determine the logic between variables or values.
                    </p>
                    <ul class="log-list">
                        <li>
                            <span class="info-list">Operator</span
                ><span class="info-list"> </span>
                            <span class="info-list"> Description</span>
                        </li>
                        <li>
                            <span class="info-list">&&</span
                ><span class="info-list">and</span>
                            <span class="info-list">Both values has to evaluate to true</span>
                        </li>
                        <li>
                            <span class="info-list">||</span
                ><span class="info-list">or</span>
                            <span class="info-list">One value has to evaluate to true</span>
                        </li>
                        <li>
                            <span class="info-list">!</span
                ><span class="info-list">not</span>
                        </li>
                    </ul>
                    <div class="code-container">
                        <div class="comment-oneline">The <span class="expand-text">||</span> (or) operator will return true if either operand is true</div>
                        <code>
				let a = true;	<br />
				let b = false; 	<br />
				( a || b ) <span class="comment-outcome">--> true</span><br />   
			</code>
                        <div class="comment-oneline">The <span class="expand-text">&&</span> (and) operator will return true if both operands are true</div>
                        <code>
				let a = true;	<br />
				let b = false; 	<br />
				( a && b ) <span class="comment-outcome">--> false</span><br />   
			</code>
                        <div class="comment-oneline">Logical (&&) operator will return second operand if both operands are true</div>
                        <code>
				let age = 20;	<br />
				let allowedAge = 15; <br />
				( (age > allowedAge) && "You can enter")<span class="comment-outcome">--> "You can enter."</span>
			</code>
                    </div>

                    <h4>Conditional Operator, <em>Ternary</em></h4>
                    <p>The ternary operator assigns a value to a variable based on some condition. If the condition is true the first value is assigned to the variable else the second one. Ternary operators can be seen as a leaner way to write code than
                        the if/else conditionally approach.</p>
                    <div class="code-container">
                        <code>
				let age = 12	<br />
				let message = age > 15 ? "Horror movie." : "It's Disney for you." <br />
				message <span class="comment-outcome">--> "It's Disney for you."</span>
			</code>
                        <div class="comment-oneline">Ternary operator combined wth logical operator</div>
                        <code>
			let age = 20;												<br />
			let allowedAge = 15											<br />
			let result = allowedAge ? ( age && "Welcome!" ) : null		<br />	
			result	<span class="comment-outcome">--> "Welcome" 		</span><br />
			</code>
                    </div>
            </article>

            <article class="subject-article">
                <h3 class="subject-title">Type Conversion in Javascript</h3>
                <p>
				Converting a value from one type to another is what in Javascript is known as <em>type coercion</em> when it's done implicitly and <em>type casting</em> when done explicitly. 
				
				When converting a value explicitly we will most probably get the expected outcome from our code. Implicit type coercion on the other hand will be the source of unexpected outcomes and problems if not understood fully.			
                </p>

                <h4 id="type-coercion">Type Coercion</h4>
                <p>
                    Javascript being weakly typed signifies that a variable can be assigned and reassigned any value of an existing data type. It can be a string to number, object to boolean, and so on. The process of implicitly converting a value from one type to another
                    is what in Javascript is known as 'type coercion'.
                </p>

                <h4>Type Casting</h4>
                <p>
                    When converting values explicitly in Javascript we use a process known as <em>type casting</em>.
                </p>
                <p>We have three type casts in Javascript</p>
                <ul>
                    <li>Boolean()</li>
                    <li>Number()</li>
                    <li>String()</li>
                </ul>
                <br />
                <p>Some methods for casting</p>
                <p>There are several methods for casting types. If we cast to string or number this is no issue but there are some potential problems if the intention is to cast a value to a boolean.
                </p>
                <br />
                <p>
                    <em>toString</em> from the name we can derive this method will cast a value to a string. We simply <span class="emphasize-gray">toString(ourValue)</span>.
                    <br />
                    <p><em>Number</em> and <em>parseInt</em> cast a value to a number but there are a difference. Number will try to convert the entire value to a number while parseInt will parse the value up to the first non-digit.
                    </p>
                    <div class="code-container">
                        <code>
				
				</code>
                    </div>


                    <h4>Implicit vs. explicit conversion</h4>
                    <p>
                        An example of implicit(automatic) type coercion is when using the loose equality operator to compare a string and a number. Since it only compares the values and not the type Javascript will seek to make a type coercion so both values shares the same
                        type. If this wasn't the intention the result will be what is known as a logical error. The javascript engine will not return an error tough signifying that the mistake might be difficult to identify and debug.
						Another example can be a function that is called with arguments of the 'wrong' type. For example a function that will make an arithmetic calculation but instead of numbers is called with a string.
					</p>					
					
                    <div class="code-container">
					<div class="comment-oneline">The operand to the right will be converted to a string before making the comparison</div>
                        <code>
						("5" == 5) <span class="comment-outcome">--> true</span><br /><br />
						</code>
						<div class="comment-oneline">Here we call a function with a number and a string</div>
						<code>
						let x = 10;		<br />
						let y = "2"		<br /><br />
						function addNumbers(num1, num2) {	<br />
						<span class="example">return num1 + num2</span><br />
						}	<br />
						console.log(add(x,y)) <span class="comment-outcome">--> 102</span><br /> 
					</code>
                    </div>
					
					<p>
						
						There are mitigation strategies to avoid logical errors as checking the type of the operands. We could also use the superset <em>TypeScript</em> to catch errors before compilation and helping us write better code. But no matter what strategy we use it is crucial to have a solid understanding on how the concept of type conversion works in Javascript. 
					</p><br />

                    <p>
                        Explicit coercion on the other hand is done on purpose as in the example below where we use <em>type casting</em> to convert the string variable to a number before making the comparison.
                    </p>
                    <div class="code-container">
					<div class="comment-oneline">We <em>type cast</em> the operand before making the comparison </div>
                        <code>
						(Number("5") === 5) <span class="comment-outcome">--> true	</span><br />
					</code><br />
					<div class="comment-oneline">We can also <em>type cast</em> to a number by using the + operator</div>
					<code>
					(+("5") === 5) <span class="comment-outcome">--> true	</span><br />
					</code>
                    </div>

                    <div class="link">See more:
                        <a href="https://developer.mozilla.org/en-US/docs/Glossary/Type_coercion">https://developer.mozilla.org/en-US/docs/Glossary/Type_coercion</a
              >
            </div>
        </article>			

		
		
		<article class="subject-article">
          <h3 class="subject-title">Objects and <em>Derived Types of Objects</em></h3>
		  <p>
		  All values in Javascript, except primitives, are objects. Objects can store collection of values while primitives are restricted to hold a single value. The easiest way to understand objects are to see them as a collection of key value pairs. In Javascript the correct term for keys are properties. Properties being the 'key' in a key value pair can also be seen as variable names inside objects. If the property holds a function expression we would call it a <em>method</em>.		  	  
		  </p>		  
						  
		  <h4>Constructor functions</h4>
			<p>
			Javascript has for a long time used constructor functions to create an object data type, basically a 'blueprint' for creating objects. With constructors we can create an object type that can be the base for creating an unlimited quantity of instances without having to redefine the same object. 	
			</p>		  
			<p>In general the properties and values have something in common as for example all car objects can be expected to have the properties color and model. It therefore makes sense to create a function that can be used to create an unlimited quantity of instances of a certain object type. Using the <em>new</em> operator we can create new instances of the base constructor. 	
			</p>
			<div class="code-container">
				<div class="comment-oneline">We create a <em>car</em> constructor</div>
				<code>
					function Car(model, color, year, doors) {		<br />	
						<span class="example">this.model = model	</span><br />
						<span class="example">this.color = color	</span><br />
						<span class="example">this.year = year		</span><br />
						<span class="example">this.doors = doors	</span><br />
					}	<br />
					</code>
					<div class="comment-oneline">We add a method to the constructor prototype</div>
					<code>
					Car.prototype.allData = function() {	<br />
						<span class="example">car_data = "The car model is " + this.model + " and was built " + this.year + " and has the color " + this.color;	</span><br />
						return car_data		<br />				
					}						<br />						
					</code>
					<div class="comment-oneline">We use the <em>new</em> operator to create a car object</div>
					<code>
						var coolCar = new Car('Super', 'black', 2020, 2) 	<br />						
						console.log(coolCar.allData()) <span class="comment-outcome">--> The car model is Super... 	</span><br />
					
					</code>
			</div>
			
			 <div class="note-comment"><span class="first-word">Note: </span>We can use console.dir() to get more info about the
              constructor </div
            >
			
			<div class="note-comment">
        <span class="first-word">Note: </span>With the ES6 update classes was introduced to Javascript that performs basically the same operations as constructor functions. We will look more at classes in the next chapter.
		</div>	

		<h4>Arrays</h4>
			<p>Arrays are basically a variable consisting of a collection of values. The values are accessible by referring to its index number. That said it's important to remember that arrays are technically objects, using the typeof operator on an array will also return <em>object</em>. To check for array we use <span class="emphasize-gray">Array.isArray(array)</span>.    
			</p><br />
						
			<p>When it comes to use methods on arrays it's important to differentiate between mutator- and non-mutable methods. The toString method for example will return a string based on the elements of an array but it will not change the original array. The converted value will have to be stored in a variable that will of type string. In other cases the method might return a completely new array not changing the orignal array as for example with slice. Mutator methods on the other hand will change the orignal array, as with push that will add a new element at the end of the orignal array. 
			</p>
  			
			<ul class="log-list">
				<li><span class="info-list">Non-mutable</span><span class="info-list">Short description</span></li>
				<li><span class="info-list"><em>toString</em></span><span class="info-list">Converts elements in an array to a comma separated string</span></li>		
				<li><span class="info-list"><em>slice</em></span><span class="info-list">Slices a part of an array and returns a new array</span></li>
				<li><span class="info-list"><em>splice</em></span><span class="info-list">Assigned parameters can both add and remove elements in an array</span></li>
				<li><span class="info-list"><em>indexOf</em></span><span class="info-list">Returns the index of the searched character</span></li>
				</ul>
				
				<ul class="log-list">
				<li><span class="info-list">Mutable</span><span class="info-list">Short description</span></li>	
				<li><span class="info-list"><em>push</em></span><span class="info-list">Adds a new element at the end of an array </span></li>
				<li><span class="info-list"><em>pop</em></span><span class="info-list">Removes the last element of an array</span></li>
				<li><span class="info-list"><em>unshift</em></span><span class="info-list">Adds a new element at the start of an array</span></li>
				<li><span class="info-list"><em>shift</em></span><span class="info-list">Removes the first element of an array</span></li>
				<li><span class="info-list"><em>sort</em></span><span class="info-list">Sorts an array in alphabetical order</span></li>
				<li><span class="info-list"><em>reverse</em></span><span class="info-list">Reverse the order of the elements in an array</span></li>
				</ul>			

            <div class="code-container">
				<code>
				var myArr = ['H','E','L','L']		<br />
				myArr.push('O')			<br />	
				console.log(myArr)	<span class="comment-outcome">--> ['H'E'L'L'O']			</span><br />	
				</code>
				<div class="comment-oneline">We use array methods on a string</div> 
			
              <code>			  
                var greet = new String("Hello") 		<br />
                greet.charAt(greet.length-1) 			<br /><br />

                var str = "KYH Frontend" 				<br />
                console.log(str.indexOf("F")) <span class="comment-outcome">--> 4</span><br /><br />

                var foo = str.split(" ") 				<br />
                console.log(typeof foo) <span class="comment-outcome">--> Object </span><br />
                foo.sort() 								<br /><br />

                var first = foo.slice(0,1)				<br />
                foo.push(first.join()) 					<br />
                console.log(foo) 		<span class="comment-outcome">--> 'Frontend'</span><br /><br />
				</code>				
            </div>
			
            <div class="note-comment"
              ><span class="first-word">Note: </span>push and sort are so called mutator methods since they
              change the original array. Push for example adds item/s to the end
              of the array while returning the new length of the array. 
            </div>
           
            <span class="link"
              >See more:
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Methods_2"
                >https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Methods_2</a
              ><br />
              <a
                href="https://www.tutorialrepublic.com/javascript-reference/javascript-array-object.php"
                >https://www.tutorialrepublic.com/javascript-reference/javascript-array-object.php</a
              ></span
            >		
	  </article>

		<article class="subject-article">
          <h3 class="subject-title">Pass by Value vs. Reference</h3>
            <p>
              When we assign an object to new variable we copy the reference to
              where that object or array is stored in memory. The reference
              works in other words as a pointer to where the object is stored,
              it doesn't copy the value as is the case with primitive types.
              This means that if we change the value of a property/element it
              will impact all variables with a reference to the same location in memory. In other words an object that is assigned to another variable will have its value changed if the value of the original object is changed. 
            </p>

            <div class="code-container">
			<div class="comment-oneline">Primitive types, pass value by copying</div>
              <code>
                var a = "KYH" <br />
                var b = a <br />
                a = "Hello" <span class="code-comment">// we assign a new value to a </span><br />
                console.log(b) <span class="comment-outcome">--> "KYH"</span> <span class="code-comment">// we retain the copied value </span><br />
              </code>           
			<div class="comment-oneline">Objects, pass value by reference</div>
              <code>
                var objectA = {name: "Kal", lastname: "Doe"} <br />
                var objectB = objectA <br />
                objectA.name = "Ada" <span class="code-comment">// we change the value of prop name</span><br>
				</code>				
				<div class="comment-oneline">objectB points to the location of the original object.
              It's not a copy of objectA.</div>
			  <code>
                objectB.name <span class="comment-outcome">--> "Ada"</span> <span class="code-comment">// prop name has changed </span><br />
              </code>
            </div>
            <div class="note-comment">
              <span class="first-word">Note: </span>Function arguments are always passed by value and are copied
              into the function.
			  </div>
            
			<div class="note-comment"><span class="first-word">Note: </span>
            To make a real copy of an object/array we
              can use the spread operator(see more under ES6 features).
            </div>

            <div class="link"
              >See more:
              <a
                href="https://stackoverflow.com/questions/16880418/javascript-pas"
                >https://stackoverflow.com/questions/16880418/javascript-pas</a
              ></div
            >
        </article>      		
		
		
        <article class="subject-article">
          <h3 class="subject-title">Functions as Callbacks</h3>
		  <p>In Javascript functions are first class objects meaning that functions can be stored in a variable and passed as arguments into other functions just as any other object. 		  
		  When a function receives another function as an argument that function is called a higher order function. And the function you pass in is called a callback. The callback will execute after that the function from where it's called has finished its execution. The callback can access the containing functions variables meaning that callbacks works as closures. Javascript being <em>event driven</em> is one reason to use callbacks. With the help of callbacks it can be ensured that functions are executed at certain order. Noteworthy; It's good praxis to check if the passed in callback is a function.   
			  </p>
			  <div class="note-comment">
              <span class="first-word">Note: </span>To check if a callback indeed is a function we use the typeof operator; (typeof callBack === 'function'). Remember the <em>quotes</em>.
            </div>
			
			  <div class="code-container">
			  <div class="comment-oneline">We pass a function into another function</div>
				<code>
					const greet = ()=> "Hello"								<br /><br />
					
					const doSmth = (callback)=> {								<br />
					<span class="example">if(typeof callback === 'function') {	</span><br />
					<span class="example2">	console.log(`${callback()} World`)	</span><br />
					<span class="example">} else {							</span><br />
					<span class="example2">	return false;					</span><br />
					<span class="example">}									</span><br />
					}														<br />
					doSmth(greet)		<span class="comment-outcome">--> "Hello World" </span><br />
				</code>
			  </div>		  
		  </article>

        <article class="subject-article">
          <h3 class="subject-title">Closures</h3>
		     <p>
			A closure is technical when a function is using a variable outside its own function scope, Usually we refer to a nested function having access to variables in its parent scope. This is also what is called Lexical Scope. As such a closure gives the enclosed function access to an outer function’s scope. Closures in practice are used for creating object data privacy. When using closures the enclosed variables are only in scope within the containing function making them non-accessible from the outside. As such they are 'enclosed' and made private. In a few words; Closures can be seen as functions with preserved data.  
			</p>		
			
			<div class="code-container">
              <div class="comment-oneline">We create a closure</div>
				<code>
					let add = function(num) {							<br />
					<span class="example">	let b = 2					</span><br />
					<span class="example">	function addTo() {			</span><br />
					<span class="example2">console.dir(addTo) <span class="code-comment">// access the closure object	</span></span><br />					
					<span class="example2">		return num + b			</span><br />		
					}													<br />
					<span class="example">return addTo()				</span><br />
				}														<br />
				add()	<span class="code-comment">// we call 'add' creating a closure for 'num' and 'b'	</span><br />
				</code>
			</div>
			
			<div class="note-comment">
              <span class="first-word">Note: </span>To access the closure object, use; console.dir(add)
            </div>
			
            <div class="link"
              >See more:
              <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures</a></div><br />
            </article>

            <article class="subject-article">
                <h3 class="subject-title">The Document Object Model (DOM)</h3>
                <p>
                    The DOM is a hierarchic map/model for a HTML document. It's created by the browser when the page is loaded and only exist for as long the page is up. The DOM could also be explained as a programming interface for HTML. The DOM can be used to access and
                    manipulate any part or element in a HTML page. It is important to remember that any changes to the DOM will only exist for as long the page is up and running, there are no persistent changes to the code or markup. If there is the need
                    to make dynamic data persistent there are options as cookies that allows data to be stored on a server. But that's a topic we will not touch in this tutorial.
                </p>

                <div class="note-comment">
                    <span class="first-word">Note: </span>The DOM has evolved from being closely related to Javascript to be programmatically independent and available for any language.
                </div>

                <h4>Why do we need the DOM?</h4>
                <p>
                    Being able to access any element on a HTML document and manipulate the same is what the DOM makes possible. As such the DOM is essential for creating dynamic content and add interactivity. To acchieve this we have a rich set of methods and properties
                    to our disposal.
                </p>

                <h4>Events</h4>
                <p>
                    Any interaction with the DOM is related or caused to some kind of <em>event</em>. There are lots of different kind of events, it can for example be a user clicking on a button or submitting a form. Events can be triggered by a number
                    of reasons not only user action but also programmatically or some asynchronous process. We use the DOM to 'listen' for events allowing the handling of some kind of action related to it. To be able to do this we will look at different
                    ways on how to access elements in the DOM hierarchy.
                </p>

                <div class="link">
                    See more:
                    <a href="https://developer.mozilla.org/en-US/docs/Web/Events">
                https://developer.mozilla.org/en-US/docs/Web/Events</a>
                </div>

                <h4>Accessing the DOM</h4>
                <p>
                    All the elements in the DOM are represented as <em>nodes</em>. There are <em>element nodes</em>, <em>text nodes</em> and <em>attribute nodes</em>. There are different methods to access and manipulate an element depending on what kind
                    on node it is.
                </p><br />

                <p class="log-list-title">Methods for acccessing the DOM</p>
                <ul class="standard-list">
                    <li>getElementById()</li>
                    <li>getElementsByTagName()</li>
                    <li>getElementsByClassName()</li>
                    <li>querySelector()</li>
                    <li>querySelectorAll()</li>
                </ul><br />

                <ul class="standard-list">
                    <li>parentElement()</li>
                    <li>childElement()
                        <li>
                </ul>

                <p>
                    <div class="code-container">
                        <code>
				
				</code>
                    </div>

                    <h4>DOM Manipulation</h4>
                    <p class="log-list-title">Methods for DOM manipulation</p>
                    <ul class="standard-list">
                        <li>setAttribute()</li>
                        <li>getAttribute()</li>
                        <li>createElement()</li>
                        <li>appendChild()</li>
                        <li>createElement()</li>
                    </ul><br />

            </article>

            <article class="subject-article">
                <h3 class="subject-title">Event Handling</h3>
                <p>
                    We know how to access and manipulate different elements in the DOM the next step is to understand how handle an event. The first step in all event handling is to know when an event happens. Javascript uses <em>listeners</em> for this.
                    For many years HTML event-handler attributes was the only way to attach listeners. Meaning that listeners are embedded directly in the mark-up. Apart from deviating from the principles of <em>separation of concerns</em> this also limits
                    the numbers of listeners to max one for any element.
                </p><br />

                <h4>AddEventListener()</h4>
                <p>
                    With the introduction of the <span class="emphasize-gray">AddEventListener method</span> there is no need for inline listeners. Meaning that we now can stay true to the principle of; <em>separation of concerns</em>, not bloating our
                    mark-up with javascript. There isn't either any limit for the numbers of listeners on a single element. The listener is attached/connected to the element using one of the standard DOM-access methods. Not having to use HTML attributes
                    to create listeners also allows for a single listener to be attached to a collection of elements, for example all elements with a certain class. With the introduction of addEventListener we also got a method for removing them;
                    <span
                        class="emphasize-gray">removeAddEventListener()</span> that simply removes the listener.
                </p>

                <div class="code-container">
                    <code>
					
				</code>
                </div>

                <em>The Event Object</em>
                <p>...</p>


                <h4>Bubbling and Capturing</h4>
                <p>...</p>

                <h4>Event Propagation</h4>
                <p>...</p>

                <div class="code-container">
                    <code>
				
				</code>
                </div>
            </article>

            <article class="subject-article">
                <h3 class="subject-title">Promises</h3>
                <p>
                    Javascript is 'single threaded' meaning that only one thing/task can happen at a time. This leads often to what is known as <i>blocking code</i> where the Javascript engine is processing some task while the main thread is blocked.
                    The solution to blocking code is asynchronous code that can run on multiple threads at the same time. To write asynchronus code is getting easier and modern browsers will allow certain operations to be run asynchronously. One way of
                    writing asynchronous code is to use <i>promises</i> that allow processing of another operation while waiting for the <em>promise</em> to resolve.
                </p><br />
                <p>
                    A <em>promise</em> in Javascript is just as in real life; a promise/commitment to do something at some point in the future. The promise will then be resolved, or rejected. In programming context the <em>promise object</em> represents
                    the eventual completion (or failure) of an asynchronous operation and its resulting value. Promises in Javascript is a way to avoid what often is called 'callback hell' where callbacks are nested in an ever growing code structure.
                </p><br />
                <p>
                    A <em>promise</em> consist of an resolved and rejected callback. Depending on if the promise is resolved or not the corresponding callback i executed. The resolve and reject functions, when called, resolve or reject the promise. With
                    <em>promises</em> we can organize our code with chained then() and catch() methods depending on if the promise is resolved or rejected.
                </p>

                <div class="code-container">
                    <code>
                const myPromise = new Promise(function(resolve, reject) { <br />
              </code>
                    <div class="comment-oneline">The promise will be either resolved or rejected</div>
                    <code>
                <span class="example">let studied = true; </span><br />
                <span class="example">if(studied) { </span><br />
                <span class="example2">resolve("Success"); </span><br />
                <span class="example">} else { </span><br />
                <span class="example2">reject('Failed') </span><br />
                <span class="example"> } </span><br />
                }) <br />
              </code>
                    <div class="comment-oneline">If the promise is fullfilled we pass the resolved argument 'value'
                    </div>
                    <code>
                myPromise.then(function(value) { <br />
                <span class="example"
                  >console.log(`It's done: ${value}`); <span class="comment-outcome">--> It's done: Study
                  Javascript</span></span
                ><br />
              </code>
                    <div class="comment-oneline">If rejected we use a catch </div>
                    <code>
                }).catch(function(rejected) { <br />
                <span class="example"
                  >console.log(`It's not done: ${value}`); <span class="comment-outcome">--> It's not done:
                  Study Javascript </span></span
                ><br />
                }) <br />
              </code>
                </div>

                <div class="link">
                    See more:
                    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises">
                https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises</a>
                </div>
            </article>

            <article class="subject-article">
                <h3 class="subject-title">fetch API</h3>
                <p>
                    The Fetch API is a Javascript built in new standard for making server requests. It provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses. It also provides a global fetch() method that
                    provides an easy, logical way to fetch resources asynchronously across the network.
                </p><br />
                <p>
                    The fetch() method takes one mandatory argument, the
                    <em>path(url)</em> to the resource you want to fetch. By default it will make a 'get request' and return a <em>promise</em> containing a response object. We then have to extract the actual body content, can for example be the json()
                    method to extract JSON body content. The fetch() method can optionally accept a second parameter consisting of an init object that gives the possibility to add configuration options for the request object.
                </p>

                <div class="code-container">
                    <div class="comment-oneline">We make a fetch request from API Open Weather Data</div>
                    <code>
                const url =
                <a
                  href="http://api.openweathermap.org/data/2.5/weather?q=London&APPID=8674cbad0da4e9ccd435f2442a4dcda7&units=metric"
                  >API OPEN WEATHER DATA</a
                >;
                <br />
                fetch(url).then(response => { <br />
                <span class="example">return response.json() </span><br />
                <span class="example">.then(response => { </span><br />
                <span class="example2">console.log(response.main.temp) </span
                ><br />
                <span class="example">}) </span><br />
                <span class="example">.catch(error => { </span><br />
                <span class="example2">console.log('Error') </span><br />
                <span class="example2">console.error(error) </span><br />
                <span class="example">}); </span><br />
                }); <br /><br />
              </code>
                    <div class="comment-oneline">We configure the options for a POST request</div>
                    <code>			  
				const urlPost =
                <a href="https://jsonplaceholder.typicode.com/posts"
                  >JSON PLACEHOLDER</a
                >;
                <br />
                const options = { <br />
                <span class="example">method:"POST", </span><br />
                <span class="example">headers: { </span><br />
                <span class="example2"
                  >"Accept": "application/json; text/plain, */*",</span
                ><br />
                <span class="example2">"Content-type": "application/json" </span
                ><br />
                <span class="example">}, </span><br />
                <span class="example">body: JSON.stringify({ </span><br />
                <span class="example2">title: 'New Post', </span><br />
                <span class="example2">body: 'Lorem ipsum...!', </span><br />
                <span class="example2">id: 1 </span><br />
                <span class="example">}) </span><br />
                } <br />

                <br />
                fetch(urlPost, options) <br />
                <span class="example">.then(response => response.json()) </span
                ><br />
                <span class="example"
                  >.then(jsonResponse => console.log(jsonResponse)) </span
                ><br />
                <span class="example">.catch(error => { </span><br />
                <span class="example2">console.log(error) </span><br />
                <span class="example">}); </span><br />
              </code>
                </div>
                <div class="link">See more:
                    <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch</a
              >
            </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">async/await</h3>
            <p>
              A special syntax is required to work with promises called
              “async/await”. It can be seen as a more easy to understand syntax
              compared to the then()/catch() methods. Using the keyword 'async'
              before a function means that the function always will return a
              promise. This is also required to be able to use 'await' inside
              async functions. The keyword await makes JavaScript wait until the
              promise is settled and first thereafter returns its result.
            </p>
            
            <div class="code-container">
              <code>
                const url =
                <a
                  href="http://api.openweathermap.org/data/2.5/weather?q=London&APPID=8674cbad0da4e9ccd435f2442a4dcda7&units=metric"
                  >API OPEN WEATHER DATA</a
                >; <br /><br />

                const getWeatherData = async function() { <br />
                <span class="example">const response = await fetch(url); </span
                ><br />
                <span class="example"
                  >const weatherData = await response.json();</span
                ><br />
                <span class="example">console.log(weatherData.main.temp) </span
                ><br />
                } <br />
                <br />
                getWeatherData().catch(error => { <br />
                <span class="example">console.error(error); </span><br />
                <span class="example">console.log('Error'); </span><br />
                }) <br />
              </code>
            </div>
            <div class="link"
              >See more:
              <a href="https://javascript.info/async-await"
                >https://javascript.info/async-await</a
              ></div
            ><br />
        </article>
      </div>

      <!-- END TUTORIAL PART 1 -->

      <span id="es6"></span>
      <div class="tutorial-part">
        <h1 class="tutorial-title">ECMAScript 2015(ES6)</h1>

        <article class="subject-article">
          <h3 class="subject-title">Variable Declaration</h3>
            <br />
            <p>
              With the introduction of ES6 support was added for the key words <i>const</i> and <i>let</i> when declaring variables.
            </p>

            <h4>const</h4>
            <p>
              const is used for declaring variables where the intention is to
              not change its value. It could be said that the value will be read
              only. 
			  A const variable must be initialized when declared. 	  
			  It's important tough to understand that it works different
              depending on the data type. For primitive types the value is set
              once and becomes read only. For objects it works differently since
              for example an array stored with const can still receive new
              elements, or have them removed, tough it is impossible to redeclare it or change its type. 
            </p>
			<div class="code-container">
				<div class="comment-oneline">We try to re-assign a const variable</div>
				<code>
					const PI = 3.14				<br />
					PI = 2.12 <span class="comment-outcome">--> TypeError 		</span><br />
				</code>
				<div class="comment-oneline">We can manipulate objects</div>
				<code>
					const persons = ['John', 'Lisa']		<br />
					persons.push('Tom')						<br />
					console.log(persons) <span class="comment-outcome">--> ['John', 'Lisa', 'Tom']	</span><br />
					</code>
			</div>
			<div class="note-comment">
              <span class="first-word">Note: </span>By convention, <em>const</em> identifiers are capitalized. 
            </div>
            
            <h4>let vs. var</h4>
            <p>
              The main difference between <i>var</i> and <i>let</i> is that
              <i>var</i> has function scope and <i>let</i> has block scope. 
			  Meaning that <i>let</i> allows for block level variables to be created, for example inside an if branch or a for loop. Another difference is that <i>let</i> declarations are not hoisted unlike variables declared with <i>var</i>. Therefore a variable declared with <i>let</i> will not be accessible before it has been initialized, trying to will result in a reference error. While doing the same with a variable declared with <i>var</i> will return as <i>undefined</i>. Another difference is that a <i>let</i> declaration will not create a property on the global object as the case with <i>var</i> declarations. 
            </p>
			
			<div class="code-container">
              <div class="comment-oneline">The <i>iterator</i> is only accessible in its own scope while <i>b</i> is accessible everywhere inside the function.</div>
			  <code>
			  function blockScope(num) {									<br />
				<span class="example">for(let i = 1; i &lt; num; i++) {		</span><br /> 
				<span class="example2">console.log(i) <span class="comment-outcome">--> 1,2,3,4</span></span><br />
				<span class="example2">var b = "I exist in function scope"	</span><br />
				<span class="example">	}									</span><br />
				<span class="example">console.log(b) <span class="comment-outcome">--> 	I exist in function scope		</span></span><br />
				<span class="example">console.log(i) <span class="comment-outcome">--> 	ReferenceError	</span></span><br />
				}	<br />
				blockScope(5);	<br />
              </code>
			  </div>
			
            <div class="note-comment">
              <span class="first-word">Note: </span><i>var</i> will allow you to re-declare a variable in the same scope while doing the same with a <em>let</em> declaration raises a SyntaxError.
            </div>
            <p>
              <span class="link"
                >See more:
                <a
                  href="https://stackoverflow.com/questions/762011/whats-the-difference-between-using-let-and-var"
                  >https://stackoverflow.com/questions/762011/whats-the-difference-between-using-let-and-var</a
                >
              </span>
            </p>

            <div class="code-container">
              <code>
                function checkScope() { <br />
                <span class="example"
                  >console.log(foo) <span class="comment-outcome">--> ReferenceError</span> <span class="code-comment">// foo is not hoisted </span></span
                ><br />
                <span class="example"
                  >console.log(bar) <span class="comment-outcome">--> undefined </span><span class="code-comment">// var declarations are
                  hoisted </span></span
                ><br />
                <span class="example">let foo = "Hello" </span><br />
                <span class="example">var bar = "World" </span><br />
                <br />
                <span class="example">for(var i = 0; i &lt; 5; i++) {</span
                ><br />
                <span class="example2">console.log(i) <span class="comment-outcome">--> 0,1,2,3,4</span></span><br />
                <span class="example">}</span><br />
                <span class="example">for(let j = 0; j &lt; 5; j++) {</span
                ><br />
                <span class="example2">
                  console.log(j) <span class="comment-outcome">--> 0,1,2,3,4</span></span
                ><br />
                <span class="example">}</span><br />

                <span class="example"
                  >console.log(i); <span class="comment-outcome">--> 5</span></span
                ><br />
                <span class="example"
                  >console.log(j); <span class="comment-outcome">--> ReferenceError</span> <span class="code-comment">//
                  can not be accessed outside its scope</span></span
                ><br />
                } 	<br />
                checkScope();
              </code>
            </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Arrow Functions</h3>
            <p>
              Arrow functions are anonymous functions that allows us to write
              shorter more leaner code. An arrow function can omit the
              parenthesis if there is no more than one argument. It can also
              omit the square brackets and the keyword 'return' if the function
              only consist of an return statement.
            </p>

            <div class="code-container">
              <div class="comment-oneline">
                  A named function, the pre ES6 way to declare a function</div>
              <code>
                function doSmth(a) { <br />
                <span class="example"> return a * 2 </span><br />
                } <br />
              </code>
              <div class="comment-oneline">The same function refactored as an anonymous arrow function</div>
              <code> const doSmth = a => a * 2 <br /> </code>
            </div>

            <h4>Arrow functions and the keyword <em>this</em></h4>
            <p>
             One of the reasons for introducing arrow functions was the behaviour of the keyword <em>this</em>. 
			If not using arrow functions the value of <em>this</em> will depend on how the function is called. 
			To set the value of <em>this</em> and alter its default behavior inside a function, the bind() method has to be used.
            </p>
            <p>
              Arrow functions inherits <em>this</em> from the enclosing lexical scope. Meaning if <em>this</em> is not present in its current scope it will look for it in the enclosing scope. 			  
			  If <em>this</em> is used in a nested function or for example in a method of a class it will look for the value of this
              in the parent scope meaning the parent function or the class where the method was defined. 
			  In other words <em>this</em> will always represent the object that defined the
              arrow function. 
			  
			  With arrow functions the behaviour of <i>this</i> is consistent and do not change
              depending on where it is called.
            </p>
            <div class="link"
              >See more:
              <a
                href="https://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work"
                >https://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work</a
              ></div
            >
        </article>

		<article class="subject-article">
          <h3 class="subject-title">Template Literals</h3>
            <p>
              Template Literals allows us to work with strings in a more agile and leaner way. Among other things we got a more agile way to write multiline strings. But its main features lies in the ability to embed variables and expressions directly in the template. This gives a lot of room for creating more dynamic code. 
			  </p><br />
			  <p>
			  For the template syntax we replace the quotes with <em>backticks</em>; <span class="emphasize-gray">`Hello World!`</span>. Variables are embedded with a dollar sign and curly braces; <span class="emphasize-gray">`Hello ${variableName)`</span>. Template literals also allows us to embed expressions inside the curly braces; <span class="emphasize-gray">`I'm ${24 + 2} years old.`</span>.  
			  Another feature we got with template literals are <em>tagged templates</em>. The syntax consist simply of the tag-name before the opening backtick; <span class="emphasize-gray">taggedName`templateContent`</span>. This allows us to execute a template literal with the help of a function. The tag-name has to be the same as the function. 
            </p>

            <div class="code-container">
			<div class="comment-oneline">
                  The pre ES6 way</div>
              <code>
                let firstName = "John" <br />
                let surName = "Doe" <br />
                const fullName = "John" + " " + "Doe" <span class="comment-outcome">--> John Doe</span> <span class="code-comment">// we use concatenation</span><br />
				</code>
				<br />
				<div class="comment-oneline">We use <em>template literals</em> for the same effect</div>
                <code>
				let firstName = "Lisa" <br />
                let surName = "Doe" <br />
                const fullName = `${firstName} ${surName}` <span class="comment-outcome">--> Lisa Doe</span><br />
				</code>	
				<br />
				
				<div class="comment-oneline">We embed an expression</div>
				<code>
                let divNumbers = `15 divided by 3 is ${15/3}` <span class="comment-outcome">--> 5</span><br />
				</code>
				<br />
				
				<div class="comment-oneline">
                  We parse a tagged template to a function</div>
				  <code>
				  function doSmth(arg) {			<br />
				  <span class="example">return arg </span><br />
				}			<br />
					let taggedTemplate = doSmth`This is a tagged template ${2+2}`	<br />
					taggedTemplate()					<br />
              </code>
            </div>
			
            <div class="link"
              >See more:
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals"
                >https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals</a
              ></div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Loops & Iteration</h3>
            <h4><i>forEach</i></h4>
            <p>
              <span class="emphasize-gray">forEach()</span> is a higher order function that executes a callback for each element in an array. ForEach can take tree arguments, the value of the
              current elment, what is required as well as two optional
              arguments, the index for each element and the array object it
              self. The forEach method will always return undefined and is not chainable. It does not mutate the array on which it is called.
            </p>		 

            <div class="code-container">
                <span class="comment-oneline">Basic syntax </span>
                <code>
                array.forEach(function(currentValue, index, arr), thisValue)
                <br /><br />
                </code>
                <span class="comment-oneline">We loop through each name and add 'Doe'</span>
                <code>
                const myArr = ["John", "Lisa", "Tom"] <br /><br />
                myArr.forEach( name => { <br />
                <span class="example"
                  >console.log(`${name} Doe`) <span class="comment-outcome">--> John Doe, Lisa Doe...</span></span
                ><br />
                })
              </code>
            </div>
			
			<div class="note-comment">
              <span class="first-word">Note: </span>There is no way to break out from a forEach() loop, except throwing an exception.
            </div>

            <h4><i>for/in</i></h4>
            <p>
              The for/in statement iterates over all non-symbol properties of an object. The loop will iterate over all enumerable properties and those the object inherits from its constructor's prototype as well. If the intention is to only
              consider properties of the object itself and not its prototypes, use <span class="emphasize-gray">getOwnPropertyNames()</span> or make sure to perform a <span class="emphasize-gray">hasOwnProperty()</span> check.
            </p>
			<p>
			Tough the for/in statement can be used on arrays it's not recommended. The reason is that there is no guarantee that a for/in loop will return the values in certain order. When it comes to arrays the order of access is important unlike objects where the value is assigned to a certain property. 
			</p>
			
            <div class="code-container">
              <code>
                const myObj = { name: "John", surname: "Doe" } <br /><br />
                for(let prop in myObj) {<br />
                <span class="example">console.log(prop) <span class="comment-outcome">--> name, surname </span></span
                ><br />
                }
              </code>
			  <div class="comment-oneline">A nested for/in</div>
			  <code>
               const myObj = { test: {name: 'John Doe', age: 34 }};		<br /><br />
				for(let prop in myObj) {								<br />
				<span class="example">let innerObj = myObj[prop]		</span><br />
				<span class="example">for(let innerProp in innerObj) {	</span><br />
				<span class="example2">console.log(innerObj[innerProp])	<span class="comment-outcome">--> John Doe 34</span></span><br />
				<span class="example">	}								</span><br />
				}
              </code>
			  <div class="comment-oneline">forEach combined with for/in</div>
			  <code>
			  const employees = [							<br />			  
			  <span class="example">{name: "Lisa", role: "Adminstrator", salary: 8000},</span><br />
			  <span class="example">{name: "Tom", role: "Janitor", salary: 7000},</span><br />
			  <span class="example">{name: "John", role: "Accountant", salary: 10000},</span><br />
			  <span class="example">{name: "Patty", role: "Manager", salary: 14000},</span><br />
			  <span class="example">{name: "Sally", role: "Sale", salary: 9000}</span><br />
			];	<br /><br />
		
		employees.forEach(employee => {	<br />
		<span class="example">for(let prop in employee) {					</span><br />
		<span class="example2">let data = `${prop}: ${employee[prop]}`		</span><br />
		<span class="example2">	console.log(`${data}`)						</span><br />
		<span class="example2">	}											</span><br />
		<span class="example">	console.log('')								</span><br />
		})																	<br />
			  </code>
            </div>

            <h4><i>for/of</i></h4>
            <p>
              The for/of statement loops over iterable objects. It loops
              through data structures that are iterable such as Strings, Arrays and array-like objects such NodeLists, Maps, Set etc. In every
              iteration the value of the next property is assigned to the
              variable. for/of is in general the preferred way to loop through iterable objects. It is more concise than a conventional for loop but can't be chained like <span class="emphasize-gray">forEach()</span>.
            </p>

            <div class="code-container">
              <code>
                const myNumbers = [11,22,33,44,55]<br /><br />

                for(let number of myNumbers) {<br />
                <span class="example">console.log(number) <span class="comment-outcome">--> 11,22,33...</span></span>
                <br />
                } <br />
              </code>
              <div class="comment-oneline">To access the index we have to use entries() </div>
              <code>
                const myArr = [a,b,c] <br /><br />
                for (const [index, val] of myArr.entries()) { <br />
                <span class="example"
                  >console.log(index +": "+ val`); <span class="comment-outcome">--> "0: a", "1: b", "2: c" </span
                ></span><br />
                } <br />
              </code>
            </div>

            <h4>Summary; which loop to use and when</h4>
			  <p>
			  There are many ways to iterate over arrays and loops and they all have there strengths and tradeof:s. 
			  The standard <em>for</em> and <em>for/in</em> loop constructs gives access to the index in the iterable object but not the element. To access the element we have to print
              out the, item[index]. With for/of and <span class="emphasize-gray">forEach()</span> on the other hand we get access to the element itself and with the latter we can also invoke an optional index argument. Accessing the index with a for/of loop requires more effort but can be done by combining destructuring with the entries method. 	  
			  </p><br />
            <p>			
              In general tough the most safe way to loop through an array/object will be the <em>for/of</em> loop. If, on the other hand, the intention is to manipulate every element in an array the <em>for/each</em> loop is the best choice. The <em>for/in</em> loop should only be used to iterate through the properties of an object and avoided for arrays where the index order is of importance. If the intention is to manipulate or filter data from an array consisting of objects a built in callback function should do the job most effectively (see section; 'Higher order functions'). 
            </p>
            <div class="link">
              See more:
              <a
                href="https://thecodebarbarian.com/for-vs-for-each-vs-for-in-vs-for-of-in-javascript"
                >https://thecodebarbarian.com/for-vs-for-each-vs-for-in-vs-for-of-in-javascript</a
              >
            </div>
        </article>
		
		<article class="subject-article">
          <h3 class="subject-title">Higher Order Functions</h3>
			  <p>
			  When a function receives another function as an argument that function is called a higher order function. And the function you pass in is called a callback. 			  
			  With ES6 several new higher order methods were added introducing new powerful tools for handling array-based data. A typical scenario where these methods can be used are when handling JSON data from a database. We can also chain them making them even more versatile. Noteworthy; These methods do not mutate/change the orignal array, this is the behaviour we in general desire. Many situations might require a combination of different methods to achieve the desired result. In the end, as with so much more, knowing what tool/s to use and how to use them will become easier with more experience.   
			  </p>
            <h4>The <em>map</em> method</h4>
			<p>
			The map method will return a new array with the result of the callback function. The callback will be called for every element in the array and the returned value will be added to the new array. 
			The callback function can take three parameters, the element, index and the array object. Only the element is required the others are optional.		
			The map method should only be used if the intention is to create a new array, if the intention is to alter the elements in the existing array the forEach function should be used instead.	
			</p>
			<div class="code-container">
					<div class="comment-oneline">We <em>map</em> the elements and double each value</div>	
				<code>					
					let numbers = [2,4,6,8,10]	<br />
	
					let numbersDoubled = numbers.map(number => {				<br />
					<span class="example">return number * 2						</span><br />
					})													<br />	
				console.log(numbersDoubled)	<span class="comment-outcome"> --> [4,8,12,16,20] </span><span class="code-comment">// we get a new array with all numbers doubled						</span><br />					
				</code>
				<div class="comment-oneline">Refactored short-hand version</div>
				<code>
					let numbersDoubleShort = numbers.map(number => number * 2)	<br />
					console.log(numbersDoubledShort)	<span class="comment-outcome"> --> [4,8,12,16,20]	</span><span class="code-comment">// we get the same result	</span><br />
				</code>
			</div>
			
            <h4>The <i>filter</i> method</h4>
			<p>			
			The filter method provides a callback that test each element in an array and creates a new array of all the values that passes the test. In other words returns as true as result of the test. provided by the callback function. Just as the map method it accepts three arguments. The element, the index and the array object. Only the element is required the others are optional.
			</p>	
			<div class="code-container">
				<code>
					let numbers = [10, 11, 22, 33, 44, 55]		<br />
					let filteredNumbers = filter.numbers( number => {					<br />
					<span class="example">	return number > 25		<span class="code-comment">// return all numbers larger than 25</span></span><br /> 
					})	<br /><br />
					console.log(filteredNumbers) <span class="comment-outcome">--> [33,44,55]</span>
				</code>
			</div>
            <h4><em>reduce()</em></h4>
			<p>
			The reduce method reduce the array to a single value. Reduce requires two arguments the accumulator and the current value. The accumulator is the total value accumulated from the elements in the array and the current value is the value for each element when the callback is executed. The reduce method will in other words return the total value from all the elements in the array. Reduce also have three optional arguments, index, array and an initial value. If no initial value is added the callback starts its loop at <span class="emphasize-gray">index 1</span>, in practice meaning that the accumulator starts with the value 0.    
			</p>
			
			<div class="note-comment">
              <span class="first-word">Note: </span>It's good praxis to provide an initial value, <i>even if its 0</i>, to avoid unexpected outcomes.
            </div>
			<div class="code-container">
				<code>
				let numbers = [10, 11, 22, 33, 44]	<br />
				let accNumbers = numbers.reduce( (accumulator, currentValue) =>  {	<br />
				<span class="example">return accumulator + currentValuem, 0	<span class="code-comment">// we add initial value of 0	</span></span><br />
				}) 														<br /><br />
				console.log(accNumbers) <span class="comment-outcome">--> 120 </span><br />	
				</code>
				
			</div>
            <h4><em>Sort()</em></h4>
				<p>The <em>sort</em> method will sort the elements in an array in a descending order.</p> 
				<div class="code-container">
					<code>
						let letters = ['f','g','w','t','a']				<br />
						let sortedLetters = letters.sort()				<br />
						console.log(sortedLetters) --> [a,f,g,t,w]		<br />
					</code>
				</div>				
			
            <h4><em>find()</em></h4>
            <p>The <span class="emphasize-gray">find()</span> method will return the value of the first element in an array that passes the condition set by the callback. If the intention is to find the index of the first value that passes the condition use <span class="emphasize-gray">findIndex()</span> method. If no value satisfies the set condition undefined will be returned.
			<div class="code-container">
				<code>
					const persons = ['John', 'Lisa', 'Patty', 'Tom']	<br />
					let personFound = persons.find(person => {	<br />
						<span class="example">return person === 'Lisa' // <span class="code-comment">returns the first name that passes the condition</span></span><br />
					})							<br />
					<br />					
					console.log(personFound)	<br />					
				</code>
			</div>
			
            <h4><i>includes()</i></h4>
            <p>...</p>
			
			<h4>Handle array-based data containing objects</h4>
			<div class="code-container">
			
				<div class="comment-oneline">ARRAY CONTAINING OBJECTS</div>
				<code>
				const employees = [																	<br />
				<span class="example">  {name: "Tom", role: "Accountant", age: 44, salary: 10000},	</span><br />
				<span class="example">  {name: "Lisa", role: "Adminstrator", age: 22, salary: 8000},</span><br />
				<span class="example">  {name: "John", role: "Janitor", age: 53, salary: 7000},		</span><br />
				<span class="example">  {name: "Patty", role: "Manager", age: 37, salary: 14000},	</span><br />
				<span class="example">  {name: "Sally", role: "Sale", age: 23, salary: 9000},		</span><br />
				<span class="example">  {name: "Helen", role: "IT", age: 31, salary: 11000},		</span><br />
				<span class="example">  {name: "Rex", role: "Guard", age: 3, salary: 'T-Bone'}		</span><br />
				];																					<br />
			</code>
			<br />
			<div class="comment-oneline">We <i>map</i> the employees names</div>					
				<code>
					const employeeNames = employees.map(employee => employee.name)	<br />
					console.log(employeeNames) <span class="comment-outcome">--> ['John', 'Lisa', ...]</span> <span class="code-comment">// new array consisting of names					</span><br />
			</code>			
			
			<div class="comment-oneline">We use <i>filter</i> to filter out those with high salaries and older age</div>
			<code>
				let happyEmployees = employees.filter( employee => employee.salary > 9000)	<br />	
				console.log(happyEmployees)	<span class="comment-outcome"> --> [...]</span>	<span class="code-comment">// will return an array with 3 employees(objects) 	</span><br /><br />
				
				let olderEmployees = employees.filter(employee => employee.age > 30)	<br />
				console.log(olderEmployees)	<span class="comment-outcome">--> [...] </span> <span class="code-comment">// will return an array with 4 employees(objects) 								</span><br />
			</code>
			
			<div class="comment-oneline">We chain <i>map</i> and <i>reduce</i> to get total salaries</div>
			<code>				
				let allSalaries = 	employees	<br />
							<span class="example">.map(employee => employee.salary) </span><br />
							<span class="example">.reduce( (acc, cv) => !isNaN(cv) ? acc + cv : acc + 0, 0)	</span><br />								
				console.log(allSalaries) <span class="comment-outcome">--> 48000	</span>				
			</code>
			
			<div class="comment-oneline">We add <i>filter</i> to remove the condition inside <i>reduce</i></div>
			<code>
				let salariesMapFilterReduce = employees	<br />
							<span class="example">.map(employee => employee.salary) </span><br />
							<span class="example">.filter(salary => !isNaN(salary))	</span><br />
							<span class="example">.reduce((acc, cv) => acc + cv, 0)	</span><br />			
				console.log(salariesMapFilterReduce) <span class="comment-outcome">--> 48000</span>
			</code>
			
			<div class="comment-oneline">Here we use <em>sort</em> with a comparefunction to sort the employees in alphabetical order</div>	
			<code>
				let sortedEmployees = employees.sort( employee => employee.name )	<br />
				console.log(sortedEmployees) <span class="comment-outcome">--> [John, Lisa...]	</span><br />
			</code>				
			<div class="comment-oneline"><em>find()</em> method</div>
			<code>
				...
			</code>
			
			<div class="comment-oneline"><em>includes()</em> method</div>
			<code>
				...
			</code>			
			</div>
			
            <div class="link"
              >See more:
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#"
                >https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#</a
              ></div
            >
			<div class="link">
			See more: <a href="https://www.youtube.com/watch?v=rRgD1yVwIvE">JavaScript Higher Order Functions & Arrays (Youtube: Traversy Media)</a>
                </div>
            </article>

            <article class="subject-article">
                <h3 class="subject-title">Object Constructor Methods</h3>
                <p>
                    We already now that to create an instance of an object we have to use an object constructor function. This is done by calling the constructor function with the <em>new</em> keyword. This will at the same time create a constructor property
                    for the Object. Referencing this property will return the Object constructor that created the instance object.
                    <div class="code-container">
                        <code>
				
			</code>
                    </div>

                    <h4>Built in Object constructor methods</h4>

                    <p><em>Object.keys()</em> and <em>Object.values()</em></p>
                    <p>....</p>

                    <h5>Object.entries()</h5>
                    <p>...</p>

                    <h5>hasOwnProperty()</h5>
                    <p>...</p>

                    <div class="link">See more:
                        <a href="https://stackoverflow.com/questions/7757337/defining-read-only-properties-in-javascript">https://stackoverflow.com/questions/7757337/defining-read-only-properties-in-javascript</a
              ><br />
              See more:
              <a
                href="https://stackoverflow.com/questions/5515310/is-there-a-standard-function-to-check-for-null-undefined-or-blank-variables-in"
                >https://stackoverflow.com/questions/5515310/is-there-a-standard-function-to-check-for-null-undefined-or-blank-variables-in</a
              >
            </div>
        </article>
		
		<article class="subject-article">
          <h3 class="subject-title">Array Constructor Methods</h3>
            
            <h4>Array.from()</h4>
            <p>
              The Array.from() method returns an Array object from any object
              with a length property or an iterable object.
            </p>

            <h4>Array.isArray()</h4>
            <div class="link"
              >More about <b>shallow</b> vs <b>deep</b> copy:
              <a
                href="https://www.freecodecamp.org/news/copying-stuff-in-javascript-how-to-differentiate-between-deep-and-shallow-copies-b6d8c1ef09cd/"
                >https://www.freecodecamp.org/news/copying-stuff-in-javascript-how-to-differentiate-between-deep-and-shallow-copies-b6d8c1ef09cd/</a
              ></div
            >
        </article>        

        <article class="subject-article">
          <h3 class="subject-title">Spread & Rest Operator</h3>
		  
			<h4>Spread operator</h4>
            <p> 
              The spread operator will take an array/object or any iterable and expand its containing elements into a collection of the containing items. The spread operator allows us to expand all the values in an iterable collection into a new iterable by simply applying the three dots <span class="emphasize-gray-wide">...</span> operator. The spread operator will work with any iterable including strings. If using spread with a string or a collection of numbers it will create an array of the characters and elements.   
			</p>
			<div class="code-container">
				<div class="comment-oneline">We use spread on a string</div>
				<code>
					let str = "World"								<br />
					let strToArr = [...str]							<br />
					console.log(strToArr) <span class="comment-outcome">--> ['W','o','r','l','d']	</span><br />	
				</code>	
			</div>
			
			<p>
			  If we simply copied an array into an existing array we would end up with a multidimensional array(nested array). Using spread on the other hand will expand the items in to another array resulting in one single dimensional array. Basically merging both collections into one single collection. 
			</p>
			<div class="code-container">
				<div class="comment-oneline">We use spread to concatenate two arrays</div>
				<code>
					const arr1 = ["Hello"]							<br />
					const arr2 = ["World"]							<br />
					const nestedArrays = [arr1, ...arr2]			<br />
					console.log(nestedArrays) <br />
					<!--let numbers = [33,44,55]					<br />
					let moreNumbers = [11,22, ...numbers]			<br />
					console.log(moreNumbers) [11,22,33,44,55]	<br />-->
				</code>	
			</div>

			<p>			  
			  spread will take all the elements of an array or object and expand them into the new merged entity. Using the spread operator to expand an existing empty array/object will also create a real copy of the original entity. The spread operator can be used when calling a function as well in an array- or object literal. 
			</p>
				
            <div class="code-container">
				<div class="comment-oneline">We use spread in a function call</div>
				<code>
				let numbers = [11,22,33,44,55]	<br />
				Math.max(...numbers) <span class="comment-outcome">--> 55	</span><br />					
				</code>					
				
				<div class="comment-oneline">We concat two objects</div>
				<code>
                myObj = { name: "John" } 							<br />
                newObj = { ...myObj, surname: "Doe" } <span class="code-comment">// We add props from myObj to new Obj </span><br />
                const myFunc = (...args) => { <br />
                <span class="example">return `All arguments ${args}`; </span
                ><br />
                } <br />                
                console.log(myFunc(1,2,3,4)) <span class="comment-outcome">--> All arguments 1,2,3,4</span>
              </code>									
			    
			  </div>
			  
			  <b>Spread to make a real copy</b><br />
            <p>
              When using the spread operator to copy an objects properties to a
              new object we make a real copy of the original. It's
              important to understand the same goes for arrays, in other words we do not copy the pointer/reference as is the case when we assign an object or
              array to a new variable. With spread we can avoid the issue
              of an object that is manipulated affecting another object with the same pointer/reference. As such the spread operator allows us to copy an object in a immutable way. 
            </p>
			
			<div class="code-container">
				<div class="comment-oneline">We make a real copy of array 'greet'</div>
				<code>
					const greet = ['Hello world']				<br />
					const copy_greet = [...greet']				<br />
					const greet = [Bye world!]					<br />
					console.log(copy_greet) <span class="comment-outcome">--> 'Hello world'	</span><br />					
				</code>
			</div>
			
			 <div class="note-comment">
              <span class="first-word">Note: </span>spread will only make a shallow copy of an array.
            </div>
			
			  			
			<h4>rest operator</h4>
			<p>
			 The rest operator is used to create an array from a collection of arguments passed to a function. It works similar to the built in arguments object used to get all arguments passed to a function. Unlike the arguments object, the rest operator will return a real array allowing for the use of higher-order-functions as <span class="emphasize-gray">forEach()</span> and <span class="emphasize-gray">map()</span> among others. 
			 </p>
			<div class="code-container">
				<code>
					let allNumbers = [11,22,33,44,55]			<br /><br />
					function timesTwo(...arguments) {			<br />	
					<span class="example">let sum = arguments.reduce( (acc,cv)=> acc + cv, 0)	</span><br />
					<span class="example">return sum	</span><br />
				}	<br />	
				console.log( timesTwo(...allNumbers) )	<br />				
				</code>
			</div>			
        </article>
		
        <article class="subject-article">
          <h3 class="subject-title">Destructuring</h3>
            <p>
              When using destructuring we can pull out elements from arrays or
              properties from objects and assign them to variables.
              When it comes to arrays it is very straight forward and we we can
              use any variable name. The order matters tough.
              When it comes to objects the order doesn't matter since we use the
              corresponding property name as variable name.
            </p>

            <div class="code-container">
              <code>
                const personArray = ["John", "Lisa"]<br />
                const [a, b] = ["John", "Lisa"] <span class="code-comment">// We assign the items to variables a and b
                </span><br /><br />
                const person = { name: "John", age: 28 }<br />
                const {name} = { name: "John", age: 28} <span class="code-comment">// We assign 'John' to name variable</span>
              </code>
            </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Default Values</h3>
            <p>
              With ES6 support was added for the use of default values. To assign a default value we just assign a value to a function
              parameter. If no argument/s is given when calling the function it will be given its default value.
              This also works for destructuring where we can assign default values for variables.
            </p>

            <div class="code-container">
              <div class="comment-oneline">We assign default values to the parameters</div>
              <code>
                function withDefaultValues(a=10, b=20) { <br />
                  <span class="example">let sum = a + b; </span><br />
                  <span class="example">return sum;</span><br />
                  <span>}</span><br />
                  <span>withDefaultValues() <span class="comment-outcome">--> 30</span></span><br />
              </code><br />
              <div class="comment-oneline">We add an empty array as default value</div>
              
              <code>
                function addNumbers(numArr = []) { <br />
                <span class="example">let sum = 0; </span><br />
                <span class="example">numArr.forEach( num => { </span><br />
                <span class="example2"> sum += num; </span><br />
                <span class="example">}) </span><br />
                <span class="example">return sum; </span><br />
                } <br />

                addNumbers() <span class="comment-outcome">--> 0</span> <span class="code-comment">// We get no error despite calling the function with no arguments.</span>
              </code>
            </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Classes</h3>
            <p>
              With ES6, classes was introduced to Javascript. Classes in Javascript are in reality only syntactical sugar offering an alternative syntax to existing prototype-based inheritance. Or in other words <em>constructor functions</em> that we looked at in the previous chapter. A class is a special type of funtion that uses the keyword class and as with constructor functions the name is capitalized by convention. 
			  A constructor method for creating and initializing an object can
              be specified in the class. If this is not done a default constructor method -
              basically an empty function - is used functioning as an empty object for
              a base class.
            </p>

            <h4><em>constructor functions</em> vs. <em>classes</em></h4>
            <p>
              In most cases they are quite similar and they do the same thing
              but there are a some things that differs. A constructor requires
              the keyword <i>new</i> to work. While we still can call a
              constructor function without the keyword new this will throw an
              error when trying to do the same with a class. A class will in
              contrast to constructor functions create a constructor method by
              default if not given one. While constructor functions are hoisted
              this is not the case with class declarations. Another important
              difference is that everything that is written inside a class is
              typed in strict mode. With ECMAScript2019 we also got some new important
              features when it comes to classes. It is now possible to create
              private properties and methods using the <span class="emphasize-gray-wide">#</span> prefix.
              There is also the possibility to initialize public properties at
              the top of a class before specifying a constructor. There are some
              important benefits to this that I will not go deeper in to here,
              for those that are interested to dwell more into all that classes
              offers I have added some links down here that explains the concept
              more in depth.
            </p>
            
            <div class="link"
              >See more:
              <a
                href="https://www.sitepoint.com/javascript-private-class-fields/"
                >https://www.sitepoint.com/javascript-private-class-fields/</a
              >
              <br />
              See more:
              <a
                href="https://dmitripavlutin.com/javascript-classes-complete-guide/"
              >
                https://dmitripavlutin.com/javascript-classes-complete-guide/ </a
              ><br /></div
            ><br />

            <div class="code-container">
			<div class="comment-oneline">A standard <em>constructor function</em></div>
              <code>
                var Person = function(name,gender,age) { <br />
                <span class="example">this.name = name; </span><br />
                <span class="example">this.gender = gender; </span><br />
                <span class="example">this.age = age; </span><br />
				}					<br />
			
				Person.prototype.getName = function() {		<br />
				<span class="example">return this.name</span><br />
				}					<br />
				</code>
				
              <div class="comment-oneline">We use the <em>class</em> syntax to rewrite the Person constructor function</div>
			  <code>
				class Person {												<br />
					<span class="example">constructor(name,gender,age) {	</span><br />
					<span class="example2">this.name = name; 				</span><br />
					<span class="example2">this.gender = gender; 			</span><br />
					<span class="example2">this.age = age; 					</span><br />
					<span class="example">}									</span><br />
					<span class="example2">getName() {						</span><br />
						<span class="example3">return this.name				</span><br />
					<span class="example">}									</span><br />		
				}															<br />
			  </code>			  
			  
			  <div class="comment-oneline">We extend the Person class</div>
			  <code>
				OldPerson.extends Person {					<br />
					<span class="example">...				</span><br />
				}											<br />
			  </code>		
            </div>
        </article>
		
		<article class="subject-article">
          <h3 class="subject-title">More Features</h3>
		
		<h4>The <em>Set</em> Data Type</h4>
		<p>
		Set data type is of type object consisting of collections of data that are iterable. The main difference with an array is that the Set type only can hold unique values. This allows for a simple and lean syntax for removing duplicates in arrays. The Set type has its own methods and property as <em>size</em>. The former adds values to a Set collection and the latter returns the length of the same. We can also use the spread operator to create an array consisting of the elements in the Set collection (see code example).
		</p>		

		<div class="code-container">
		<div class="comment-oneline">We remove duplicates from an array</div>
			<code>
				const messyArray = [33,11,22,11,44,33]		<br />
				const fixedSet = new Set(messyArray)		<br />
				console.log(fixedSet.size) <span class="comment-outcome">--> 4			</span><br />
		</code>
	<div class="comment-oneline">We use Array.from() to convert our collection to an array</div>
		<code>
				const fixedArray = Array.from(fixedSet)					<br />	
				console.log(fixedArray) <span class="comment-outcome">--> [33,11,22,44]	 				</span><br />
			</code>	
		<div class="comment-oneline">We use Set and the <em>spread</em> operator to do the same</div>
			<code>
				const fixedArray = [... new Set(messyArray)]	<br />
				console.log(fixedArray)	<span class="comment-outcome">--> [33,11,22,44]					</span><br />
			</code>
		</div>
		</article>
        
      </div>
      <!-- End Tutorial part 2 -->

      <span id="questions-part"></span>
      <div class="tutorial-part">
        <h1 class="tutorial-title">Interview Questions</h1>
        <br />

        <div class="question">
          <h3>Fundamentals</h3>
            <h4>Explain:</h4>
            <div class="example">
              <p>primitive datatypes</p>
              <p>
                How come we can use properties and methods on primitives as with
                objects?
              </p>
              <p>'undefined'</p>
              <p>Difference between undefined and null</p>
              <p>hoisting</p>
              <p>
                Explain the behaviour of function -expressions vs -declarations
                when it comes to hoisting
              </p>
              <p>global scope vs functional scope</p>
              <p>lexical scope</p>
				<p>difference of 'let' vs. 'var'</p>
             <p>When do we use 'const'?</p>            
            </div>
            </div>
           

            <h4>Type coercion and comparison</h4>
            <br />
            <div class="example">
              <p>What do we get?</p>
              
			  <div class="code-container">
                <code>
                  4 + "2" <br />
                  8-"2"*3 <br />
                  (4 + true + "2")/5 <br />
                  4*(3-2)/false <br />
                  Boolean("") <br />
                  true == "1" <br />
                  14%10 > 2 <br />
                  10 - "KYH" <br />
                  "0" == false <br />
					</code>
				<div class="comment-oneline">"0" is converted to a 'falsy' value but what does it
                    mean?</div><br />
				<code>
					NaN == NaN <br />
                  isNaN("Hello World") <br />
                  (true &lt; 3 &lt; 5) <br />
                  (8 &gt; 5 &gt; 3) <br />
                  (false || Boolean) <br />
                  (33 || false && true) <br />
                  (1 === 1 && "Hello") <br />
                </code>
                <span class="comment-oneline">33 and "Hello" are converted to 'truthy' values but what
                    does it mean?</span>
              </div>
            </div>
          <br />

          <article class="subject-article">
            <h3 class="subject-title">'use strict'</h3>
              <p>
                Why would we use 'use strict' statement in a Javascript file and
                what are the consequences/benefits?
              </p>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Reverse a String</h3>
              <i
                >Return the following string in reverse "Frontend Developer".</i
              >
              <br />
              <i
                >Extra: Show another way to achieve the same result. If not done
                already don't use the reverse method.</i
              >
              <i>Extra: Reverse a collection of type number.</i>
              <br />
              <span>Tip: reverse method only works with arrays.</span><br />
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Arrow functions</h3>
              <p>Explain arrow functions</p>
              <i
                >Convert the function to an arrow function and display the
                shortest possible version.</i
              >
              <div class="code-container">
                <code>
                  function doSomething(arg) { <br />
                  <span class="example">return arg * 2</span><br />
                  } <br />
                </code>
              </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Remove Duplicates from an Array</h3>
              <i
                >Show if possible two ways to remove duplicates from an
                array.</i
              >
              <i
                >Extra: If not done already, use an object constructor method to
                remove the duplicates.</i
              ><br />
              <span>Note: All results most consist of an array.</span
              ><br /><br />
              <span>Tip: ES6 datatype 'Set' can only hold unique values.</span
              ><br />
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Sort an Array</h3>
              <p>
                Sort the array so the lowest number comes first and the highest
                last.
              </p>
			  
              <div class="code-container">
                <code> let numbers = [114,22,4,5,11,41]<br /> </code>
              </div>
          </article>

		<article class="subject-article">
            <h3 class="subject-title">Compare two arrays</h3>
              <p>
                Create a function that compares two arrays and returns <em>true</em> if they are the same and <em>false</em> if not. 
              </p>
			  
			  <!-- JSON.stringify(array1) === JSON.stringify(array2);-->
			  
              <div class="code-container">
                <code> let numbers = [114,22,4,5,11,41]<br /> </code>
              </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Duplicate an Array</h3>
              <i>Duplicate the array, both in pre ES6 as well as ES6.</i>
              <div class="code-container">
                <code> const numbers = [2,4,6,8] <br /> </code>
              </div>
              <i
                >Explain the importance/difference of using the spread operator
                to copy the props of an object -or the elements in an array- vs
                just assigning the object to a new variable?</i
              ><br />
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Keyword this</h3>
              <i
                >Explain how 'this' work when used in a stand-alone function
                (not; obj.method).</i
              >
              <i>How does 'this' work when used inside an arrow function?</i
              ><br />
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Destructuring</h3>
              <i><b>Destructure (solely) the last item from the array</b></i>
              
			  <div class="code-container">
                <code>
                  <span>const letters = ["A","B","C"] </span>
                </code>
                <br />
              </div>

              <i><b>What is the value of variables; a,c,d ?</b></i>
              <div class="code-container">
                <code>
                  <span>numberArr = [12,4,7] </span><br />
                  <span>const [a=5,, c, d=12] = [...numberArr] </span>
                </code>
              </div>
              <i><b>What do we get?</b></i>
              <div class="code-container">
                <code>
                  <span>const add = (a, b=5, c) => a + b</span><br />
                  <span>add(4)</span>
                  <br />
                </code>
              </div>
              <i><b>How can this be fixed without declaration?</b></i>
              <div class="code-container">
                <code>
                  {a, b} = { a: "Hello", b: "World" } <br />
                  console.log(a,b) // unexpected token... <br />
                </code>
              </div>
          </article>
		  
		  <article>
		  <h3>Array Constructor</h3>
		  <p>...</p>
		  </article>

          <article class="subject-article">
            <h3 class="subject-title">Objects and Object Constructor</h3>
              <p>Array.from() ...</p>
              <ul>
                <li>Extra 1: Use the Array.from() callback/mapfunction to
                manipulate each item.
				</li>
				<li>Extra 2: How can you check if a passed value is an array?
				</li>
              <li
                >Extra 3: What does it mean when you do a 'shallow copy' of an
                existing array or object?
				</li>
				</ul>

  		    <!--
            <i><b>Get the keys and values from the object</b></i
            ><br />
            <i>myObj = { str1: "Hello", str2: "World" }</i><br />

            <i>Extra 1; Good, now show an alternative solution.</i>
            <i
              >Extra 2; Extend your original answer and get the length(quantity)
              of the properties.</i
            >
            <i
              >Extra 3; For what can you use the constructor method
              'hasOwnProperty' and what will it return?</i
            ><br />

            <span
              >Notes: The Object.keys/values will return an array.<br />
              The Object.entries returns an array of arrays.<br />
              An easy way to check if an object is empty is to check the length
              of the 'keys' property in the Object constructor<br />
              You can define how/if a prop can be accessed/changed by using the
              corresponding Object constructor method. </span
            ><br />

            <span
              >Note: 1) Can be done with for/in as well but then it will also
              show props that are inherited by the prototype.</span
            ><br />
            <span
              >Note: 2) The length property on the Object constructor will
              return undefined.</span
            ><br />
            <span
              >Note: 3) It will return(true) for all declared properties even
              those with no value.</span
            >-->


              <p>
                <b
                  >What could cause a problem when using typeof foo === "object" to determine if foo is an object?</b
                >
              </p>
              <p>Show how to resolve the problem/s</p>
              <br />
              <p>
                <b>Pass the values of the car object to the showCar function</b>
              </p>
              <p>
                Note: the function needs to cope with an unknown numbers of
                arguments
              </p>
			  
              <div class="code-container">
                <code>
                  car = { model: "Volvo", color: "blue", year: "2018" }
                  <br /><br />
                  ??? <br />
                  showCar = (???)=> { <br />
                  <span class="example">return ???; </span><br />
                  } <br />
                  console.log(showCar(???)); // Display car features/values
                </code>
              </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">FizzBuzz</h3>
              <i
                >Pretty common question(worth to google it...) present if
                possible 2 solutions</i
              >
              <p>
                Iterate over a 100 numbers.<br />
                When modulus 3 (remainder 0) return Buzz and when modulus 5
                return Fizz.<br />
                If both modulus 3 and 5 return FizzBuzz.
              </p>
          </article>
        </div>
      <div class="go-top"><a href="#top">To the Top</a><br /></div>
                    </div>
                    <script>
                        // TOGGLE COLOR THEME
                        const btnChangeColor = document.querySelector(".btn-change-color");
                        const codeContainers = document.querySelectorAll(".code-container");
                        const changeCodeColor = () => {
                            Array.from(codeContainers, container => {
                                container.classList.toggle("code-container-mod");
                            });
                        };
                        btnChangeColor.addEventListener("click", changeCodeColor);
                        // END TOGGLE


                        /*** EXCERCISES ***/

                        // CLASSES		
                        class Area {
                            constructor(width, height) {
                                this.width = width;
                                this.height = height;
                            }
                            calcArea() {
                                return this.width * this.height;
                            }
                            get Area() {
                                return this.calcArea();
                            }
                        }

                        // STANDARD ARRAY/OBJECT
                        const employees = [{
                            name: "John",
                            role: "Accountant",
                            age: 44,
                            salary: 10000
                        }, {
                            name: "Lisa",
                            role: "Adminstrator",
                            age: 22,
                            salary: 8000
                        }, {
                            name: "Tom",
                            role: "Janitor",
                            age: 53,
                            salary: 7000
                        }, {
                            name: "Patty",
                            role: "Manager",
                            age: 37,
                            salary: 14000
                        }, {
                            name: "Sally",
                            role: "Sale",
                            age: 23,
                            salary: 9000
                        }, {
                            name: "Rex",
                            role: "Guard",
                            age: 3,
                            salary: 'T-bone'
                        }];

                        // Lets suppose that the data above is returned as an object consisting of objects.
                        // How would we proceed to get the same data and filter as above?
                        // ... we need Object constructor methods.  

                        // OBJECT OF OBJECTS		
                        const objectArray = {
                            john: {
                                name: "John",
                                role: "Accountant",
                                age: 44,
                                salary: 10000
                            },
                            lisa: {
                                name: "Lisa",
                                role: "Adminstrator",
                                age: 22,
                                salary: 8000
                            },
                            tom: {
                                name: "Tom",
                                role: "Janitor",
                                age: 53,
                                salary: 7000
                            },
                            patty: {
                                name: "Patty",
                                role: "Manager",
                                age: 37,
                                salary: 14000
                            },
                            sally: {
                                name: "Sally",
                                role: "Sale",
                                age: 23,
                                salary: 9000
                            },
                            rex: {
                                name: "Rex",
                                role: "Guard",
                                age: 3,
                                salary: 'T-bone Steak'
                            }
                        }

                        //	WE CREATE AN ARRAY WITH ALL SALARIES AND USE REDUCE TO GET TOTAL
                        let allSalaries = employees
                            .map(employee => employee.salary)
                            .reduce((acc, cv) => !isNaN(cv) ? acc + cv : acc + 0, 0)
                        console.log(allSalaries)

                        let allSalariesMapFilterReduce = employees
                            .map(employee => employee.salary)
                            .filter(salary => !isNaN(salary))
                            .reduce((acc, cv) => acc + cv, 0)
                        console.log(allSalariesMapFilterReduce)

                        // FILTER
                        let richKids = employees.filter(employee => employee.salary > 9000)
                        let oldKids = employees.filter(employee => employee.age > 30)

                        // THE OBJECT CONSTRUCTOR
                        // we use object constructor to get values before filter  		
                        let arrValues = Object.values(objectArray).filter(obj => obj.age > 32)
                        console.log("Test: ", arrValues)

                        // more verbose solutions...
                        for (let prop in objectArray) {
                            if (objectArray[prop].age > 37) {
                                console.log(objectArray[prop])
                            }
                        }

                        const getOld = () => {
                            let foo = []
                            for (let prop in objectArray) {
                                if (objectArray[prop].age > 30) {
                                    foo.push(objectArray[prop])
                                }
                            }
                            return foo
                        }

                        // REDUCE
                        let numbers = [10, 11, 22, 33, 44];
                        let accNumbers = numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 33)
                        console.log(accNumbers)

                        // SORT	
                        let sortedEmployees = employees.sort(employee => employee.name)
                        console.log(sortedEmployees)
                        let letters = ['f', 'g', 'w', 't', 'a']
                        let sortedLetters = letters.sort()
                        console.log(sortedLetters)

                        // REST
                        let allNumbers = [11, 22, 33, 44, 55]
                            // we dont know how many arguments will be entered
                        function timesTwo(...arguments) {
                            let sum = arguments.reduce((acc, cv) => acc + cv, 0)
                            return sum
                        }
                        console.log(timesTwo(...allNumbers))

                        // CONSTRUCTOR FUNCTION
                        function Car(model, color, year, doors) {
                            this.model = model
                            this.color = color
                            this.year = year
                            this.doors = doors
                        }
                        //We add a method to the constructor prototype
                        Car.prototype.allData = function() {
                            car_data = "The car model is " + this.model + " and was built " + this.year + " and has the color " + this.color;
                            return car_data
                        }

                        let cool = "Olle"
                        let myLit = doSmth `Here I insert ${cool}`

                        function doSmth(arg) {
                            return arg
                        }
                        console.log(myLit)


                        // REMOVE DUPLICATES IN AN ARRAY 
                        // And display new array with unique values
                        const messyArray = [33, 11, 22, 11, 44, 33]
                        const setCollection = new Set(messyArray)

                        let foo = Array.from(setCollection)
                        console.log(foo)
                        const fixedArray = [...new Set(messyArray)]
                        console.log(fixedArray)
                        console.log(fixedArray.size) //--> undefined // fixedArray is not of type Set

                        const persons = ['John', 'Doe']
                        console.log(...persons)
                        const fooSpread = [...persons]
                        console.log(fooSpread)

                        // We compare two arrays 				
                        const testArr1 = [2, 3, 4, 5]
                        const testArr2 = [2, 3, 4, 5, 6]

                        // can be a slow method for larger sample data
                        console.log(JSON.stringify(testArr1) === JSON.stringify(testArr2));


                        var str2 = "KYH Frontend"
                        console.log(str2.indexOf("F"))

                        var foo2 = str2.split(" ")
                        console.log(typeof foo2)
                        console.log(foo2.sort())

                        var first = foo2.slice(0, 1)
                        foo2.push(first.join())
                        console.log(foo2)

                        var str3 = "KYH Frontend"
                        console.log(str3.indexOf("F"))

                        let testArray = [1, 2, 3, 4]
                        let foo33 = testArray.toString()
                        console.log(testArray)
                        console.log(foo33)
						
						console.log(+"5" === 5)
                    </script>
                    <noscript>Your browser does not support JavaScript!</noscript>
</body>

</html>