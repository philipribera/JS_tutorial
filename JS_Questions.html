<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content="Free Javascript Guide with Questions" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="author" content="Philip R" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Javascript Questions</title>
	<!-- GOOGLE FONTS -->
	<link href="https://fonts.googleapis.com/css?family=Montserrat&display=swap" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Merriweather+Sans|Montserrat&display=swap" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
    <style>
	<link href="https://fonts.googleapis.com/css?family=Poppins&display=swap" rel="stylesheet">
	<!-- END FONTS -->
	<style>
      * {
        box-sizing: border-box;
        outline: none;
        padding: 0;
        margin: 0;
      }
      body {
        font-family: helvetica, roboto, sans-serif;
        background-color: rgb(222,222,222);
		z-index: -999;
		margin: 0;
      }
      header {
		width: 100%;
        height: 68px;
        position: fixed;
        top: 0;		
        background-color: rgb(232, 141, 82);
		background-color: rgb(189,189,189);
        box-shadow: 1px 1px 1px 1px rgb(132, 132, 132);
        z-index: 9999;		
      }
	  
      .header-container {
		display: flex;
        flex-wrap: wrap;
        align-items: center;
        padding: 0 5%;
      }
      .header-title {		
        margin-right: auto;
		flex: 1 0 472px;
      }
      .header-title h3 {
        font-size: 1.4rem;
		color: rgb(109,109,109);
        color: rgb(254, 254, 254);        
		text-shadow: 1px 1px rgb(155,155,155);
      }
	  .header-menu {
		display: flex;
		justify-content: flex-end;
		flex: 1 0 310px;
		
	  }
	  .header-menu ul {
		margin: 0;
	  }
      .header-menu li {
        padding: 14px;
      }
      .header-menu a {
		font-family: "Montserrat", roboto, sans-serif;
        color: rgb(247, 247, 247);
        color: rgb(47, 47, 47);
		font-weight: 600;
      }
      .header-menu ul li {
        display: inline;
        cursor: pointer;
      }
      .header-menu ul a:hover {		
        color: rgb(255, 159, 32);
		color: rgb(255,255,255);
      }
      .wrapper {
		position: relative;
        display: block;		
        width: 100%;
        max-width: 964px;
        background-color: rgba(255, 255, 255, 1);
        color: rgb(35, 35, 35);
        padding: 24px;
        margin: 42px auto;
      }
	  
      /*** GENERICS ***/
      p {
  		font-family: 'Merriweather Sans', roboto, helvetica, sans-serif;
  		font-family: roboto, helvetica, sans-serif;
  		font-family: 'Poppins', roboto, helvetica, sans-serif;
        color: rgb(15,15,15);
      }
      h1,
      h2,
      h3 {
		font-family: 'Montserrat', roboto, helvetica, sans-serif;
        color: rgb(242, 147, 38);
      }
      h1 {
        font-size: 2rem;
      }
      h3 {
        font-size: 1.5rem;
      }
	  h3 {
  		font-family: 'Merriweather Sans', 'Montserrat', roboto, helvetica, sans-serif;
	  }
      h4 {
		font-family: 'Poppins', 'Merriweather Sans', 'Montserrat', roboto, helvetica, sans-serif;
        font-size: 1.15rem;
        color: rgb(27,27,27);
		margin: 32px 0 12px 0;
      }
      ul {
        padding: 4px;
        margin-left: 14px;
      }
      li {
        list-style-type: none;
        padding: 0 4px;
      }
      a {
        color: rgb(133, 133, 133);
        text-decoration: none;
      }
      p,
      span,
      b {
        color: rgb(37, 37, 37);
        line-height: 1.55rem;
      }
      code {
		font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
			monospace;
        font-size: 1rem;
        line-height: 1.72rem;
        color: rgb(20, 61, 81);
      }

      /*** CLASSES ***/
	  .expand-text {
		font-size: 1.1rem;
		color: rgb(41, 54, 103);
	  }
      .tutorial-title {
        margin: 20px 0;
      }
	  .log-list-title {
		font-weight: 600;
	  }
	  .log-list {
		margin: 24px 0;
	  }
      .log-list li {
		display: flex;        
        border-bottom: 1px solid rgb(212, 212, 212);
      }
      .log-list li:first-child {
        font-weight: 600;
      }
	  .log-list li:last-child {
		flex: 1;
	  }
      .info-list {
        display: inline-block;
        min-width: 72px;
        margin-right: 14px;
      }
      .go-top {
		position: absolute;
		bottom: 0;
		left: 0;
        padding: 4px 0;
      }
      .go-top a {
        font-size: 1rem;
        font-weight: 600;
        text-decoration: none;
        cursor: pointer;
        background: rgb(222, 222, 222);
        color: rgb(42, 96, 117);
        padding: 4px 6px;
        border: 1px solid rgb(190, 190, 190);
      }
      .go-top a:hover {
        opacity: 0.95;
      }
      .tutorial-part {
        padding: 28px 28px 30px 28px;        
      }
      .tutorial-part:not(:first-of-type) {
        margin-top: 24px;
      }
      .tutorial-part:not(:nth-last-child(2)) {
	  	  border-bottom: 4px solid rgb(207, 207, 207);
	  }
      .subject-article {
        display: inline-block;
		width: 100%;
        margin: 18px 0 24px 0;
      }
      .subject-title {
        margin-bottom: 18px;
      }
      .example {
        margin-left: 14px;
      }
      .example2 {
        margin-left: 28px;
      }
	  .example3 {
		margin-left: 42px;
	  }
      .link {
        word-break: break-all;
        display: inline-block;
		background-color: rgb(253,247,237);
        color: rgb(123, 123, 123);
        font-weight: 600;
		padding: 2px;
        margin: 10px 0;
      }
      .code * {
        word-break: break-all;
      }
      .code-container {
        position: relative;
        background-color: rgb(238, 238, 238);
        padding: 20px 24px 24px 24px;
        margin: 20px 0 24px 0;
        overflow: auto;
      }
	 
      .code-container i {
        color: rgb(37, 63, 110);
        line-height: 2.15rem;
      }
      .code-container .comment-oneline {
        display: block;
        color: rgb(41, 54, 103);
        opacity: 0.95;
        font-weight: 600;
        margin: 22px 0 12px 0;
      }
	  .subject-article .code-container:first-child {
		margin-top: 0;
	  }	  
	  
	  .code-container .code-comment {
		color: rgb(109,109,112);		
		padding-left: 18px;
	  }
	  
      .code-container-mod {
        background-color: rgb(9, 9, 9);
      }
      .code-container-mod code,
      .code-container-mod code span {
        color: rgb(74, 249, 105);
		color: rgb(240, 158, 255);
		color: rgb(84, 231, 255);
      }
      .code-container-mod .comment-oneline, .code-container-mod i, .code-container-mod .expand-text {
        color: rgb(237, 238, 237);
		color: rgb(255, 175, 75);
      }
	  .code-container-mod .code-comment {
		color: rgb(228, 199, 63);
	  }
	  .code-container-mod span.comment-outcome {
		color: #62ff2e;
		color: rgb(212,200,80);
	  }
      .question {
        margin-bottom: 54px;
      }
      .btn-change-color {
        position: absolute;
        right: 0;
        top: 0;
        cursor: pointer;
        background: rgb(45, 45, 45);
        color: rgb(222, 222, 222);
        padding: 6px;
        border: 1px solid rgb(102, 102, 102);
      }
      #fundamentals,
      #es6,
      #questions-part {
        display: block;
        position: relative;
        top: -120px;
        visibility: hidden;
      }	 
	  	  
		code span.comment-outcome {
			white-space: nowrap;
			font-weight: 600;
			color: rgb(82,101,167);
			padding-left: 6px;
		}
	    .note-comment {
		    background-color: rgb(255,226,168);
		    padding: 16px 12px;
		    margin: 32px 0;
	    }
		.note-comment, .code-container {
			border-radius: 3px;
		}
	    .first-word {
		    color: rgb(37,37,37);
		    font-weight: 600;
	    }
		
		.falsy-list {
			width: 30%;
			padding: 12px 4px;
			margin: 4px 0;
		}
		.falsy-list li {
			background-color: rgb(249,249,249);
			padding: 5px 8px;
			border-left: 1px solid rgb(222,222,222);
			border-bottom: 1px solid rgb(241,241,241);
		}
		.falsy-list li:nth-child(odd), .log-list li:nth-child(even) {
			background-color: rgb(241,241,241);
		}
		.list-comment {
			padding-left: 12px;
		}

      /*** MEDIA QUERIES ***/
      @media only screen and (max-width: 990px) {
		header {
			height: auto;
		}
		.header-container {
			display: flex;
			justify-content: center;
			align-items: center;
			padding: 12px;
			margin: 0;
		}		
		header .header-menu, header .header-title {
			flex: 1 0 100%;
			margin: 0;
			text-align: center;
			justify-content: center;
		}
		.header-title h3 {
			margin: 10px 8px;
		}
		.wrapper {	  
			width: inherit;
			margin: 92px 0 0 0;
        }
        .tutorial-part {
          padding: 20px;
        }
        .code-container {
          padding: 20px;
        }
        h1 {
          font-size: 2rem;
        }
        h3 {
          font-size: 1.45rem;
        }
      }
      @media only screen and (max-width: 767px) {	
        .wrapper {
          padding: 12px;
        }
        .tutorial-part {
          padding: 6px;
        }
		.subject-article {
			margin: 20px 0;
		}
        .example {
			margin-left: 10px;
		}
		.example2 {
			margin-left: 22px;
		}
		.example3 {
			margin-left: 32px;
		}
        .code-container {
          padding: 20px 14px;
        }
        h1 {
          font-size: 1.95rem;
        }
        h3 {
          font-size: 1.4rem;
        }
        i {
          line-height: 1.6rem;
        }
		.info-list {
			margin-right: 6px;
		}
		.falsy-list {
			width: 70%;
			padding: 10px 2px;
			margin: 0;
		}
		.code-container .code-comment {
			padding-left: 8px;
		}
      }
      @media only screen and (max-width: 600px) {
		.wrapper {
          padding: 10px;
		  margin: 110px 0 0 0;
		}
        .header-container {
          display: flex;
          flex-wrap: wrap;
          text-align: center;
          justify-content: center;
          height: auto;
          padding: 10px;
        }
        .header-title {
          display: block;
          margin-bottom: 10px;
        }
        .header-title h3 {
          font-size: 1.15rem;
		  margin: 6px;
        }
        .header-menu {
          justify-content: center;
        }
        .header-menu ul,
        .header-menu li {
          padding: 12px 8px 4px 8px;
        }

        .collapsed-menu {
          display: block;
        }
        .wrapper {
          width: initial;
        }
        .code-container {
          padding: 18px 12px;
        }
        h1 {
          font-size: 1.8rem;
        }
        h3 {
          font-size: 1.37rem;
        }
        .example {
          margin-left: 0;
        }
      } 	  
    </style>
  </head>

  <body>
    <header >
		<div class="header-container">
      <div class="header-title">
        <h3>JAVASCRIPT FUNDAMENTALS WITH QUESTIONS</h3>
      </div>
      <div class="header-menu">
        <ul>
          <li><a href="#fundamentals">Fundamentals</a></li>
          <li><a href="#es6">ES6</a></li>
          <li><a href="#questions-part">Questions</a></li>
        </ul>
      </div>
	  </div>
    </header>

    <div class="wrapper">
      <span id="fundamentals"></span>
      <div class="tutorial-part">
        <h1 class="tutorial-title">Javascript Fundamentals</h1>

		<article class="subject-article">
          <h3 class="subject-title">Introduction</h3>
          <div class="example">
			<p>
			Javascript is the language of the web, it is an interpreted language that runs directly on the clients browser meaning that no compiler is needed. This is the core of Javascript; It was designed to be easy to use and easy to learn. It also explains some of its characteristics, strengths and drawbacks, that differentiate it from some of the most common programming languages. But Javascript has evolved a lot since its introduction and with the latest updates it has become a much more versatile language. Now days Javascript isn't limited to the browser either. With the help of <i>Node</i> it can be run on both the browser and on the server side.  
			</p>
			<p>
			This tutorial will not focus on basic syntax rules or how to name variables. There are already good tutorials that explains the core basic in detail. This tutorial will focus on the key concepts of the language to get a better understanding on how Javascript works. There is also a chapter dedicated to the ECMAScript 2015 (ES6) update and how to use some of the new features that was introduced. The ES6 update was probably the most important development of Javascript since its introduction making Javascript significantly more powerful and versatile.    
			</p>

		  <h4>Dynamically typed</h4>
            <p>
			 Javascript is what we call <i>dynamically typed</i> meaning the type of an variable is interpreted by the compiler. Javascript is also said to be <i>weakly typed</i> in contrast to languages that are <i>strongly</i> or <i>static</i> typed where a variable has to be given a type when it's declared. 
			 Javascript being dynamically typed means that variable types will be interpreted and if necessary even change implicitly at runtime. With runtime meaning when the program executes the commands. The type and value can be changed at any time both explicit in the code or implicitly by the Javascript engine. This behaviour can be confusing and give unexpected outcomes if not understood fully. Before looking deeper into this tough we need to get a better understanding on different data types and their behaviour in Javascript.      
			</p>
			
		<h4>Data Types</h4>
			<p>
			  Data types specify what kind of data can be stored and manipulated in the Javascript memory. Data types in Javascript are either objects or primitives. While there is only one <i>object</i> data type there are 7 primitive data types:
              <i>string, number, boolean, null, undefined, bigInt</i> and
              <i>symbol</i>. The fundamental difference between primitives and objects is that primitives can hold a single value while objects can hold a collection of data and values. Javascript being weakly typed means that we do not specify a certain type when declaring a variable (there are exceptions tough). But even if no type is implicitly given Javascript will give the variable a type depending on the value it was given when initialized. If the variable hasn't been initialized it will get a type as <i>undefined</i>. 
			</p>
			
			<div class="note-comment">
              <span class="first-word">Note: </span>
			  Javascript is case-sensitive; meaning that consistent capitalization of characters matters when it comes to keywords, variables- and function names.</div>
			
			<div class="note-comment">
              <span class="first-word">Note: </span>
			  The <i>var</i> keyword will be used in code examples until the section 'Variable Scope' where variable declarations are explained more in depth.</div>
			
			</div>			
		</article>
        
        <article class="subject-article">
          <h3 class="subject-title">Primitive Types</h3>
          <div class="example">		  
            <p>
              Primitive values can not have properties and methods since they
              are not objects. But Javascript can, depending on the circumstances, treat primitives as objects. Javascript does this by wrapping the value in an object kind of entity making it possible to apply properties and methods. One example is the 'length' property that can be applied on strings.
			</p>
			<p>
			But even if primitives can behave as objects there are some important differences when compared with objects. Apart from only being able to hold a single value they are also non-mutable. Meaning that assigning a value to a variable that already holds a value replaces this value with a new value it doesn't mutate/change the original value. This is the reason mutator methods - <i>methods that change the original value</i> - can not be applied on primitives. For example <i>push</i>, <i>reverse</i> and <i>sort</i>. Another difference is that primitive values are passed by <i>copying the value</i> unlike objects that <i>pass value by reference</i>. This means that if a primitive variable is assigned to a new variable its value is copied to the new variable and can be changed without affecting the value of the original variable.  
            </p>
			  
            <div class="code-container">
                <button class="btn-change-color">Change Theme</button>                
				<div class="comment-oneline">Values are passed by copying</div>
			  <code>
				var a = "Hello"								<br />
				var b = a 	<span class="code-comment">// we assign 'a' to 'b'	</span><br />
				b = "World"	 <span class="code-comment">// we give 'b' a new value	</span><br />
				console.log(a) <span class="comment-outcome"> --> Hello </span><span class="code-comment">// the value of 'a' doesn't  change	</span><br />			  
              </code>
				 <div class="comment-oneline">
                We use the length property/element
                </div>
                <code>
                var str = "Hello World"<br />
                console.log(str.length) <span class="comment-outcome"> --> 11</span> <span class="code-comment">// we get the numbers of characters</span><br />
                 </code> 
                <div class="comment-oneline">
                Primitive values do not mutate
                </div>
                <code>
                var foo = "Hello World" <br />
                console.log(foo.toUpperCase()) <span class="comment-outcome"> --> HELLO WORLD</span> <span class="code-comment">// we use a method on foo</span><br />
                console.log(foo) <span class="comment-outcome"> --> Hello World</span> <span class="code-comment"> // the original value is
                unchanged</span><br /> </code
              >				
              
  				<div class="comment-oneline">We can do this</div>
				<code>
               foo[0] <span class="comment-outcome"> --> H</span> <span class="code-comment">// we get the 1st character</span><br /> 
			   </code>
              <div class="comment-oneline">But not this...</div>
              <code>
                foo[0] = "T" <span class="code-comment">// we try to assign foo[0] a new value</span><br />
                console.log(foo) <span class="comment-outcome"> --> Hello World</span><span class="code-comment">// value of 'foo' doesn't change </span><br />
              </code>
            </div>
						
            <i class="link"
              >See more;
              <a
                href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive"
                >https://developer.mozilla.org/en-US/docs/Glossary/Primitive</a
              ></i
            ><br />
            
            <h4><i>string</i></h4>
            <p>The string type holds data that can be represented as text. String values consists of normal characters, special characters can be encoded using the escape character '\'. In Javascript strings can be denominated with both single and double quotes. With ES6 support was also added for 'template literals'. Template literals adds versatility and allows for variables and expressions to be embedded with string literals. (we will cover template literals further in the next chapter). 
			</p>
			
			<div class="code-container">			
				<div class="comment-oneline">Some common methods used with strings</div>
				<code>
                var greet = "Hello World"		 				<br />                
				greet.charAt(0) <span class="comment-outcome">--> H</span>	<br />
				greet[0] <span class="comment-outcome">--> H </span><span class="code-comment">// we use bracket notation</span><br />
				greet.indexOf("W")<span class="comment-outcome"> --> 6</span><br /><br />

                var str = new String("KYH Frontend") <span class="code-comment">// we use the string object constructor  				</span><br />
                typeof str <span class="comment-outcome">--> 'object'</span> <span class="code-comment">// we use the typeof operator</span><br />
            </code>
			</div>
			<div class="note-comment">
              <span class="first-word">Note: </span>Strings being primitives means we can't use mutator methods as push() and sort().
			</div>
			
            <h4><i>number</i></h4>         
            <p>
              In Javascript we only have one type for numbers. There is no
              distinction for integers, floats etc. 
			  The number data type also consist of so called, special numeric values as <i>NaN</i>, <i>Infinity</i> and <i>-infinity</i>.  
			</p>
			<p>			
			   If an arithmatic operation can't convert an argument to a number it returns <i>NaN</i>, meaning; not a number.
				To check for <i>NaN</i> do <b>not</b> compare; NaN === NaN, this returns false since type of <i>NaN</i> is number. The <i>isNaN</i> function has to be used instead, isNaN === NaN.
			</p>
			<div class="note-comment">
              <span class="first-word">Note: </span>
			  With ES6 we can use <i>Number.isNaN(value)</i> to check for <i>NaN</i>.
			  </div>
			  
            <span class="link"
              >See more;
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN"
                >https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN</a
              ></span
            >
			
            <div class="code-container">
			<div class="comment-oneline">The Math object in Javascript is
              used to perform mathematical tasks on numbers</div>
              <code>
                var floatNumber = 1.55 <br />
                Math.round(floatNumber) <span class="comment-outcome">--> 2</span> <span class="code-comment">// will round to closest integer</span>
                <br /><br />
                var num1 = 2.3 <br />
                var num2 = 1.4 <br />
                Math.floor(num1 + num2) <span class="comment-outcome">--> 3</span> <span class="code-comment">// will round downwards to closest integer </span><br /><br />
                Math.max(4,7,9,11) <span class="comment-outcome">--> 11</span><br />
                Math.min(4,7,9,11) <span class="comment-outcome">--> 4</span><br />
                var numbers = [4,7,9,11]; <br />
                Math.max(numbers) <span class="comment-outcome">--> NaN</span> <span class="code-comment">// Math max/min do not work with arrays</span><br />
              </code>

              <div class="comment-oneline">
                To solve this we can use ES6 features as spread or reduce
              </div>
              <code>
                Math.max(...numbers) <span class="comment-outcome">--> 11</span><br /><br />
                var rand; <br />
                Math.random(rand) <span class="comment-outcome">--> ?</span> <span class="code-comment">// returns a floating-point between 0 and 1</span>
              </code>
            </div>

            <h4><i>undefined</i></h4>
            <p>
              <i>undefined</i> is a primitive datatype and a so
              called <i>falsy</i> value. It's important to not confuse <i>falsy</i> as
              'false', the latter being of type Boolean. Javascript will
              automatically assign <i>undefined</i> to a variable that are not
              initialized. In other words a variable that has been declared but not given a value will always return undefined. 
              A function with no return statement will always return <i>undefined</i> as well. To check for <i>undefined</i> we use the
              <i>typeof</i> operator.<br />              
            </p>

            <div class="code-container">
              <div class="comment-oneline">
                If we try to use a variable before being declared
              </div>
              <code> console.log(a); --> referenceError <br /> 
			  </code>
              <div class="comment-oneline">
                If we don't initialize a variable
              </div>
              <code> var a; <span class="code-comment">// assign the value 'undefined' </span></code
              ><br />
              <div class="comment-oneline">But we can also do this</div>
              <code>
                var a = undefined; <span class="code-comment">// we assign the value 'undefined'</span><br />
                typeof a <span class="comment-outcome">--> 'undefined'</span> <br />
                if ( typeof a === 'undefined') <span class="comment-outcome">--> true</span> <span class="code-comment">// we check for
                <i>undefined</i>(note; the quotes!)</span></code
              >
			  </div>
			  
			<div class="note-comment">
              <span class="first-word">Note: </span><i>undefined</i> has its own type and is not to be considered an error, tough it's often the cause of bugs.
			</div>	            
           
            <h4><i>null</i></h4>
            <p>
              <i>null</i> is a primitive value and a keyword in JavaScript that means
              ‘no value’ or nonexistence of any value. null is also considered a <i>falsy</i> value. The type of null tough is
              object while <i>undefined</i> has its own type. The fact that null is considered a primitive value and its type is object (non-primitive) is a bug from the time Javascript was designed. The best way to understand null is to interpret it as something that does not exist. If the purpose is to give a variable an empty value it can be done by assign it the value null, representing no value. It could be said that null has the same purpose/functionality for objects as undefined for primitives with the difference that the latter has its own type while null hasn't.
            </p>
            
            <div class="code-container">
              <code>
                var b = null; <br />
                typeof b <span class="comment-outcome">--> object</span> <span class="code-comment">// null basically means empty object </span><br />
                if (b === null) <span class="comment-outcome">--> true </span><span class="code-comment">// we check for null </span></code
              >
            </div>
			
			<h4><i>Boolean</i></h4>
			<p>
			Boolean type has only two values <i>true</i> or <i>false</i>. Its primary use is for controlling program flow using conditional statements. Noteworthy; Any object that is not <i>undefined</i> or <i>null</i> will always evaluate to true. 			
			</p>			
			<div class="code-container">
			<div class="comment-oneline">A simple expression that evaluates to true</div>
				<code>
					if (10 > 5) {		<br />
					<span class="example">console.log('This is true')</span> // code block will execute	<br />
					}	<br />	
				</code>
				<div class="comment-oneline">We pass an object with a <i>falsy</i> value</div>
				<code>					
					const myObj = new Object(false)	<br />
					if(myObj) {													<br />
					<span class="example">console.log("I'm true") <span class="comment-outcome">--> "I'm true"  </span></span><br />
					}														<br />
				</code>
				<div class="comment-oneline">We pass a primitive with a false value</div>
				<code>
					const foo = 0	<span class="code-comment">// we assign a <i>falsy</i> value to 'foo'</span><br />
					if(foo) {						<br />
					<span class="example">console.log("nothingHappens") 	<span class="code-comment">// will not execute	
					</span></span><br />
					} else {													<br />
						<span class="example">console.log("I'm false")	<span class="comment-outcome">--> "I'm false"</span><span class="code-comment">// will execute</span></span><br />
					}				
				</code>				
			</div>
          </div>
        </article>
		
		<article class="subject-article">
          <h3 class="subject-title"><i>truthy</i> and <i>falsy</i></h3>
          <div class="example">
			<p>
			All values in Javascript can be said to be either <i>truthy</i> or <i>falsy</i> i a Boolean context. This should not be confused with <i>true</i> or <i>false</i> that are of type Boolean. <i>truthy</i> and <i>falsy</i> have no data type in its own, a value of type string for example is of type string no matter its inherent boolean value being either truthy or falsy. To simplify there are six <i>falsy</i> values and all other values are considered to be <i>truthy</i>.
			</p>
			
				<p class="log-list-title">Values considered falsy:</p> 
				<ul class="falsy-list">
				<li><i>false</i></li>
				<li><i>0</i></li>
				<li><i>undefined</i></li>
				<li><i>' '</i> or <i>" "</i><span class="list-comment">// empty string</span> </li> 
				<li><i>NaN</i></li>
				<li><i>null</i></li>
				</ul>
				
			<p>
			So why do we have <i>truthy</i> and <i>falsy</i> in Javascript?  
			In JavaScript all values, no matter its type, will be considered either true or false when encountered in a Boolean context. In other words; A condition where one or more values are set in a boolean context will result in either a true or false outcome. The typical situation being an if statement where a block of code will be excecuted depending on if the condition will be considered true or false. The boolean context can consist of values of any type but they will always have an inherent boolean value as either <i>truthy</i> or <i>falsy</i> and the condition where they are set will evaluate to either true or false.  
			</p>
			
			<div class="code-container">
				<code>
					if(1) {		<br />
							<span class="example">console.log("Hello") <span class="comment-outcome">--> Hello</span> <span class="code-comment">// 1 will be considered <i>truthy</i> </span></span><br />
					}				<br />	
					<br />
					var a;	<span class="code-comment">// 'a' is not initialized and will get the <i>falsy</i> value 'undefined'	<br />
					if(a) {		<br />
					<span class="example">	console.log("I'm true");  </span>	 <br />
					} else {	<br />
					<span class="example">console.log("I'm false")</span> <span class="comment-outcome">--> I'm false </span><span class="code-comment">// the condition evaluates to false</span><br />
					} <br />
				</code>
			</div>			
			</div>
			</article>
			
		<article class="subject-article">
          <h3 class="subject-title">Objects</h3>
          <div class="example">
		  <p>
		  All values in Javascript, except primitives, are objects. Objects can store collection of values while primitives are restricted to hold a single value. The easiest way to understand objects are to see them as a collection of key value pairs. In Javascript the correct term for keys are properties. Properties being the 'key' in a key value pair can also be seen as variable names inside objects. If the property holds a function expression we would call it a <i>method</i>.		  	  
		  </p>
		  <p>
		  Javascript has for a long time used constructor functions to create an object data type, basically a 'blueprint' for creating objects. With constructors we can create an object type that can be the base for creating an unlimited quantity of instances without having to redefine the same object. 	
		</p>
						  
		  <h4>Constructor functions</h4>		  
			<p>In general the properties and values have something in common as for example all car objects can be expected to have the properties color and model. IT therefore makes sense to create a function that can be used to create an unlimited quantity of instances of a certain object type. For example a constructor function for a <i>car</i> object.  			
			</p>
			<div class="code-container">
				<div class="comment-oneline">We create a 'car' constructor</div>
				<code>
					function Car(model, color, year, doors) {		<br />	
						<span class="example">this.model = model	</span><br />
						<span class="example">this.color = color	</span><br />
						<span class="example">this.year = year		</span><br />
						<span class="example">this.doors = doors	</span><br />
					}												<br />	
				</code>
			</div>
			
			<div class="note-comment">
        <span class="first-word">Note: </span>With the ES6 update classes was introduced to Javascript that performs basically the same operations as constructor functions. We will look more at classes in the next chapter.
		</div>	

		<h4>Arrays</h4>
			<p>Arrays are basically a variable consisting of a collection of values.
			The values are accessed by referring to its index number unlike objects where a value is assigned to a named property. That said it's important to remember that arrays are a special kind of objects with there own properties and methods.   
			</p>	          

            <div class="code-container">
			   <div class="comment-oneline">Some common Array methods</div>        
              <code>			  
                var greet = new String("Hello") <br />
                greet.charAt(greet.length-1) 	<br /><br />

                var str = "KYH Frontend" 		<br />
                typeof str 						<br />
                str.indexOf("F") 				<br /><br />

                var foo = str.split(" ") 		<br />
                typeof foo 						<br />
                foo.sort() 						<br /><br />

                var first = foo.slice(0,1)		<br />
                foo.push(first.join()) 			<br />
                console.log(foo) 				<br /><br />

                foo.constructor 
				</code>				
            </div>
			
            <div class="note-comment"
              ><span class="first-word">Note: </span>push and sort are so called mutator methods since they
              change the original array. Push for example adds item/s to the end
              of the array while returning the new length of the array. 
            </div>
            <div class="note-comment"><span class="first-word">Note: </span>We can use console.dir() to get more info about the
              constructor </div
            >
            <span class="link"
              >See more:
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Methods_2"
                >https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Methods_2</a
              ><br />
              <a
                href="https://www.tutorialrepublic.com/javascript-reference/javascript-array-object.php"
                >https://www.tutorialrepublic.com/javascript-reference/javascript-array-object.php</a
              ></span
            >		
		  </div>
	  </article>

		<article class="subject-article">
          <h3 class="subject-title">Pass by Value vs. Reference</h3>
          <div class="example">
            <p>
              When we assign an object to new variable we copy the reference to
              where that object or array is stored in memory.<br />The reference
              works in other words as a pointer to where the object is stored,
              it doesn't copy the value as is the case with primitive types.
              This means that if we change the value of a property/element it
              will impact all variables with a reference to the same location in memory. In other words an object that is assigned to another variable will have its value changed if the value of the original object is changed. 
            </p>

            <div class="code-container">
			<div class="comment-oneline">Primitive types, pass value by copying</div>
              <code>
                var a = "KYH" <br />
                var b = a <br />
                a = "Hello" <span class="code-comment">// we assign a new value to a </span><br />
                console.log(b) <span class="comment-outcome">--> "KYH"</span> <span class="code-comment">// we retain the copied value </span><br />
              </code>
            </div>
			
            <div class="code-container">
			<div class="comment-oneline">Objects, pass value by reference</div>
              <code>
                var objectA = {name: "Kal", lastname: "Doe"} <br />
                var objectB = objectA <br />
                objectA.name = "Ada" <span class="code-comment">// we change the value of prop name</span><br>
				</code>				
				<div class="comment-oneline">objectB points to the location of the original object.
              It's not a copy of objectA.</div>
			  <code>
                objectB.name <span class="comment-outcome">--> "Ada"</span> <span class="code-comment">// prop name has changed </span><br />
              </code>
            </div>
            <div class="note-comment">
              <span class="first-word">Note: </span>Function arguments are always passed by value and are copied
              into the function.
			  </div>
            
			<div class="note-comment"><span class="first-word">Note: </span>
            To make a real copy of an object/array we
              can use the spread operator(see more under ES6 features).
            </div>

            <span class="link"
              >See more:
              <a
                href="https://stackoverflow.com/questions/16880418/javascript-pas"
                >https://stackoverflow.com/questions/16880418/javascript-pas</a
              ></span
            >
          </div>
        </article>        
		
        <article class="subject-article">
          <h3 class="subject-title">Type Coercion</h3>
          <div class="example">
            <p>
              Type coercion is an important concept in Javascript not least
              considering that JavaScript is a loosely typed programming
              language, sometimes also described as a dynamic language.
              Javascript being loosely typed means that a variable can be
              assigned and reassigned any value of an existing data type. It can
              be a string to number, object to boolean, and so on. The process
              of converting a value from one type to another is called 'type
              coercion'.
            </p>            
            <h4>Implicit vs. explicit coercion</h4>
            <p>
              Type conversion can be done implicit and explicit. An example of
              implicit(automatic) type conversion is when using the loose
              equality operator. Since it only compares the values and not the
              type Javascript will seek to make a type coercion so both values
              also share the same type. As a developer such code should be
              avoided since it's often the reason for bugs. Explicit coercion on
              the other hand is done on purpose, for example by using
              Number(value) that seeks to convert the value to the type
              'number'.
            </p>
            
            <span class="link"
              >See more:
              <a
                href="https://www.freecodecamp.org/news/js-type-coercion-explained-27ba3d9a2839/"
                >https://www.freecodecamp.org/news/js-type-coercion-explained-27ba3d9a2839/</a
              >
            </span>
          </div>
        </article>
		
		<article class="subject-article">
          <h3 class="subject-title">Hoisting</h3>
          <div class="example">
            <p>
              The definition of hoisting in Javascript is that declarations of
              variables and functions are moved to the top of the code when
              compiled. This means that a variable or function can be used even
              before it has been initialized. It's important to remember that variables declared with <i>let</i> will not be hoisted. One of the benefits with hoisting is that functions are hoisted as well making it possible to use them anywhere in your code. The concept of Hoisting can be the source for confusion, not least since the written code is only moved in the memory, not physically. 
            </p>
            <p>
              If we call a variable declared with <i>var</i> before it has been initialized it's value will be <i>undefined</i> and <i>undefined</i> being a valid value, even having its own type, will not result in an error. The same applies for function expressions being an expression assigned to a variable. It's important to remember that it's only the declaration that is hoisted not the value of the variable.           
            </p>
            <span class="link"
              >See more;
              <a
                href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting"
                >https://developer.mozilla.org/en-US/docs/Glossary/Hoisting</a
              >
            </span>

            <div class="code-container">
              <div class="comment-oneline">
                Variable declarations are hoisted inside functions as well
              </div>
              <code>
                var testScope = function() { <br />
                <span class="example">console.log(y);</span><br />
                <span class="example">var y = 1; </span><br />
                } <br />
                testScope(); <span class="comment-outcome">--> undefined</span><br /> </code
              ><br />

              <div class="comment-oneline">
                Anonymous function expressions are not hoisted
              </div>
              <code>
                var y = 2; <br />
                var testScope = function() { <br />
                <span class="example">console.log(y); <span class="code-comment">// we try to access y before it has been initialized</span></span><br />
                <span class="example">var y = 1; </span><br />
                } <br />
                testScope(); <span class="comment-outcome">--> undefined </span><br />
              </code>

              <br />
			  <div class="comment-oneline">
                Here y is not redeclared inside the function
              </div>
              <code>			  
                var y = 2; <br />
                var testScope = function() { <br />
                <span class="example"> console.log(y);</span><br />
                } <br />
                testScope(); <span class="comment-outcome">--> 2</span><br />
              </code>			  
            </div>
          </div>
        </article>
		
		<article class="subject-article">
          <h3 class="subject-title">Variable Scope</h3>
          <div class="example">
            <p>
              When talking about variable scope we are in essence referring to
              which scope a variable is accessible. In other words where we can look/access variables or functions.
              For a long time Javascript variable declarations were either
              global or function scoped. The latter sometimes also called local
              scope. A variable accessible anywhere in our code is said to exist
              in the global scope while a variable accessible inside a function
              exist in the local scope of the function where it was declared. With the ES6 update and the introduction of the keyword <i>let</i> for declaring variables we now also have <i>block scope</i>. A variable declared with <i>let</i> will only be accessible inside the block where it was declared. This can for example be inside the block restricted by a for loop that exist inside a function.
			</p>            
            <p>
              When it comes to function scope it's also important to understand
              the concept of lexical scope sometimes also called Static
              scope. Lexical scope is the concept of a variable being accessible
              inside nested blocks, typically function or block scopes inside an outer function. 
              </p>
			  <div class="code-container">
			  
			  <div class="comment-oneline">Global Scope</div>
				<code>
				let a = "Hello"	<span class="code-comment">// we create a global variable	</span><br />
				
				function() {			<br />
				<span class="example">	console.log(a)	<span class="comment-outcome">--> "Hello"</span> <span class="code-comment">// a is accessible everywhere in our code </span></span><br />
				}	<br />
				</code>
				
				<div class="comment-oneline">Block Scope</div>
				<code>
				let numbers = [1,2,3,4,5]											<br />
				for(let i = 0; i &lt; numbers.length; i++) {						<br />
				<span class="example2">	console.log(numbers[i]) <span class="comment-outcome">--> 1,2,3,4,5		</span></span><br />	
				}											<br />
				console.log(i) <span class="comment-outcome">--> referenceError </span><span class="code-comment">// i does not exist outside its block scope </span><br />
				</code>
			  
			  <div class="comment-oneline">Lexical Scope</div>
			  <code>
                function outerFunction() { 							<br />
				<span class="example2">	var a = "I'm from outside";					</span><br />
				<span class="example2">	function innerFunction() {					</span><br />
				<span class="example3">		console.log(a)	<span class="comment-outcome">-->	I'm from outside	</span></span><br />
				<span class="example2"> }</span><br />
				}	
				</code>	
			</div>
		  </div>
        </article>       

         <article class="subject-article">
          <h3 class="subject-title">Operators</h3>
          <div class="example">
            <p>
              JavaScript has <i>operators</i> that perform some operation on a single or multiple <i>operands</i> (data value). 
              There are at least 10 different kinds of operators in Javascript, one being the assignment operator (=) which assign a value to a variable, another being arithmetic operators as (+,-,/), that performs arithmetic operations.
              In this tutorial we will look deeper into a few of these, among them <i>Comparison</i> operators due to their importance for understanding how Javascript handles <i>type coercion</i>.     
            </p>
            
            <h4>Comparison Operators</h4>
            <p>
              The rules for type conversions in Javascript can be confusing and give unexpected outcomes if not understood fully.               
              It's not least important to understand the difference between the
              double equality operator (<b>==</b>) and the tripple equality
              operator (<b>===</b>) when comparing values. Javascript have different rules for using the double equality operator often called 'loose' equality operator' versus the tripple one being the 'strict' equivalent. The loose equality operator compares the value but not
              the data type vs. the latter that compares both. There are no formal rule for
              which comparison to use but most safe is to use the tripple comparison. 
			  That said there can
              be situations where a non-strict comparison operator can have it's
              benefits. No matter which one is used it's important to understand
              how they work and the implications of using one over the other.
              The already mentioned operators can also be combined as follows; not equal to <b>!= !==</b>,
              greater or less than <b> &gt; &lt;, &gt;= &lt;=.</b>
            </p>

            <div class="code-container">
              <code>
                if(1 == "1") <span class="comment-outcome">--> true</span> <span class="code-comment">// will make a comparison after type conversion of "1" to 1 </span><br />
                <br />
                if(1 === "1") <span class="comment-outcome">--> false</span> <span class="code-comment">// strict equality will check for both value and type
                </span><br />
              </code>
            </div>
            
            <h4>Logical Operators</h4>
            <p>
              Logical operators are used to determine the logic between
              variables or values.
            </p>
            <ul class="log-list">
              <li>
                <span class="info-list">Operator</span
                ><span class="info-list"> </span>
				<span class="info-list"> Description</span>
              </li>
              <li>
                <span class="info-list">&&</span
                ><span class="info-list">and</span>
				<span class="info-list">Both values has to evaluate to true</span>
              </li>
              <li>
                <span class="info-list">||</span
                ><span class="info-list">or</span>
				<span class="info-list">One value has to evaluate to true</span>
              </li>
              <li>
                <span class="info-list">!</span
                ><span class="info-list">not</span>
              </li>
            </ul>
			<div class="code-container">			
			<div class="comment-oneline">The <span class="expand-text">||</span> (or) operator will return true if either operand is true</div>
			<code>
				let a = true;	<br />
				let b = false; 	<br />
				( a || b ) <span class="comment-outcome">--> true</span><br />   
			</code>
			<div class="comment-oneline">The <span class="expand-text">&&</span> (and) operator will return true if both operands are true</div>
			<code>
				let a = true;	<br />
				let b = false; 	<br />
				( a && b ) <span class="comment-outcome">--> false</span><br />   
			</code>
			<div class="comment-oneline">Logical (&&) operator will return second operand if both operands are true</div>			
			<code>
				let age = 20;	<br />
				let allowedAge = 15; <br />
				( (age > allowedAge) && "You can enter")<span class="comment-outcome">--> "You can enter."</span>
			</code>
			</div>
			
			<h4>Conditional Operator, <i>Ternary</i></h4>			
			<p>The ternary operator assigns a value to a variable based on some condition. If the condition is true the first value is assigned to the variable else the second one. Ternary operators can be seen as a leaner way to write code than the if/else conditionally approach.</p>
			<div class="code-container">
			<code>
				let age = 12	<br />
				let message = age > 15 ? "Horror movie." : "It's Disney for you." <br />
				message <span class="comment-outcome">--> "It's Disney for you."</span>
			</code>		
			<div class="comment-oneline">Ternary operator combined wth logical operator</div>
			<code>
			let age = 20;												<br />
			let allowedAge = 15											<br />
			let result = allowedAge ? ( age && "Welcome!" ) : null		<br />	
			result	<span class="comment-outcome">--> "Welcome" 		</span><br />
			</code>			
			</div>			
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Functions as Callbacks</h3>
          <div class="example">
		  <p>In Javascript functions are first class objects meaning that functions can be passed as arguments into other functions just as any other object. When a function receives another function as an argument that function is called a higher order function. And the function you pass in is called a callback. The callback can access the containing functions variables meaning that callbacks works as closures. Noteworthy; It's good praxis to check if the passed in callback is a function.   
			  </p>
			  <div class="note-comment">
              <span class="first-word">Note: </span>to check if a callback indeed is a function; <i>typeof callBack === 'function'</i>.
            </div>
			
			  <div class="code-container">
			  <div class="comment-oneline">We pass a function into another function</div>
				<code>
					const greet = ()=> "Hello"								<br />
																			<br />
					const doSmth = (callback)=> {								<br />
					<span class="example">if(typeof callback === 'function') {	</span><br />
					<span class="example2">	console.log(`${callback()} World`)	</span><br />
					<span class="example">} else {							</span><br />
					<span class="example2">	return false;					</span><br />
					<span class="example">}									</span><br />
					}														<br />
					doSmth(greet)		<span class="comment-outcome">--> "Hello World" </span><br />
				</code>
			  </div>		  
		  </div>
		  </article>


        <article class="subject-article">
          <h3 class="subject-title">Closures</h3>
          <div class="example">
		     <p>
			A closure is technical when a function is using a variable outside its own function scope, Usually we refer to a nested function having access to variables in its parent scope. This is also what is called Lexical Scope. As such a closure gives the enclosed function access to an outer function’s scope. Closures in practice are used for creating object data privacy. When using closures the enclosed variables are only in scope within the containing function making them non-accessible from the outside. As such they are 'enclosed' and made private. In a few words; Closures can be seen as functions with preserved data.  
			</p>		
			
			<div class="code-container">
              <div class="comment-oneline">We create a closure</div>
				<code>
					let add = function(num) {							<br />
					<span class="example">	let b = 2					</span><br />
					<span class="example">	function addTo() {			</span><br />
					<span class="example2">console.dir(addTo) <span class="code-comment">// access the closure object	</span></span><br />					
					<span class="example2">		return num + b			</span><br />		
					}													<br />
					<span class="example">return addTo()				</span><br />
				}														<br />
				add()	<span class="code-comment">// we call <i>add</i> creating a closure for 'num' and 'b'	</span><br />
				</code>
			</div>
			
			<div class="note-comment">
              <span class="first-word">Note: </span>To access the closure object; <i>console.dir(add)</i>.
            </div>
			
            <span class="link"
              >See more:
              <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures</a></span
            ><br />
          </div>
        </article>
		
		 <article class="subject-article">
          <h3 class="subject-title">Promises</h3>
			<div class="example">
				<p>
			Javascript is 'single threaded' meaning that only one thing/task can happen at a time.
			This leads often to what is known as <i>blocking code</i> where the Javascript engine is processing some task while the main thread is blocked. The solution to blocking code is asynchronous code that can run on multiple threads at the same time. To write asynchronus code is getting easier and modern browsers will allow certain operations to be run asynchronously. One way of writing asynchronous code is to use <i>promises</i> that allow processing of another operation while waiting for the 'promise' to resolve.  
			</p>			
            <p>
              A promise in Javascript is just as in real life; a promise/commitment to do something at some point in the future. The
              promise will then be resolved, or rejected. In programming context
              the Promise object represents the eventual completion (or failure)
              of an asynchronous operation and its resulting value. Promises in
              Javascript is a way to avoid what often is called 'callback hell'
              where callbacks are nested in an ever growing code structure.
            </p>
            <p>
              A Promise consist of an resolved and rejected callback. Depending
              on if the promise is resolved or not the corresponding callback i
              executed. The resolve and reject functions, when called, resolve
              or reject the promise. With Promises we can organize our code with
              chained then() and catch() methods depending on if the promise is
              resolved or rejected.
            </p>

            <div class="code-container">
              <code>
                const myPromise = new Promise(function(resolve, reject) { <br />
              </code>
              <div class="comment-oneline">The promise will be either resolved or rejected</div>
              <code>
                <span class="example">let studied = true; </span><br />
                <span class="example">if(studied) { </span><br />
                <span class="example2">resolve("Success"); </span><br />
                <span class="example">} else { </span><br />
                <span class="example2">reject('Failed') </span><br />
                <span class="example"> } </span><br />
                }) <br />
              </code>
              <div class="comment-oneline">If the promise is fullfilled we pass the resolved argument
                  'value'</div>
              <code>
                myPromise.then(function(value) { <br />
                <span class="example"
                  >console.log(`It's done: ${value}`); <span class="comment-outcome">--> It's done: Study
                  Javascript</span></span
                ><br />
              </code>
              <div class="comment-oneline">If rejected we use a catch </div>
              <code>
                }).catch(function(rejected) { <br />
                <span class="example"
                  >console.log(`It's not done: ${value}`); <span class="comment-outcome">--> It's not done:
                  Study Javascript </span></span
                ><br />
                }) <br />
              </code>
            </div>
            
            <span class="link">
              See more:
              <a  href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises">
                https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises</a>
                </span>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">fetch API</h3>
          <div class="example">
            <p>
              The Fetch API is a Javascript built in new standard for making
              server requests. It provides a JavaScript interface for accessing
              and manipulating parts of the HTTP pipeline, such as requests and
              responses. It also provides a global fetch() method that provides
              an easy, logical way to fetch resources asynchronously across the
              network.
            </p>
            <p>
              The fetch() method takes one mandatory argument, the
              <b>path(url)</b> to the resource you want to fetch. By default it
              will make a 'get request' and return a <b>Promise</b> containing a
              response object. We then have to extract the actual body content,
              can for example be the json() method to extract JSON body content.
              The fetch() method can optionally accept a second parameter
              consisting of an init object that gives the possibility to add
              configuration options for the request object.
            </p>

            <div class="code-container">
              <div class="comment-oneline">We make a fetch request from API Open Weather Data</div>
              <code>
                const url =
                <a
                  href="http://api.openweathermap.org/data/2.5/weather?q=London&APPID=8674cbad0da4e9ccd435f2442a4dcda7&units=metric"
                  >API OPEN WEATHER DATA</a
                >;
                <br />
                fetch(url).then(response => { <br />
                <span class="example">return response.json() </span><br />
                <span class="example">.then(response => { </span><br />
                <span class="example2">console.log(response.main.temp) </span
                ><br />
                <span class="example">}) </span><br />
                <span class="example">.catch(error => { </span><br />
                <span class="example2">console.log('Error') </span><br />
                <span class="example2">console.error(error) </span><br />
                <span class="example">}); </span><br />
                }); <br /><br />
              </code>
              <div class="comment-oneline">We configure the options for a POST request</div>  
				<code>			  
				const urlPost =
                <a href="https://jsonplaceholder.typicode.com/posts"
                  >JSON PLACEHOLDER</a
                >;
                <br />
                const options = { <br />
                <span class="example">method:"POST", </span><br />
                <span class="example">headers: { </span><br />
                <span class="example2"
                  >"Accept": "application/json; text/plain, */*",</span
                ><br />
                <span class="example2">"Content-type": "application/json" </span
                ><br />
                <span class="example">}, </span><br />
                <span class="example">body: JSON.stringify({ </span><br />
                <span class="example2">title: 'New Post', </span><br />
                <span class="example2">body: 'Lorem ipsum...!', </span><br />
                <span class="example2">id: 1 </span><br />
                <span class="example">}) </span><br />
                } <br />

                <br />
                fetch(urlPost, options) <br />
                <span class="example">.then(response => response.json()) </span
                ><br />
                <span class="example"
                  >.then(jsonResponse => console.log(jsonResponse)) </span
                ><br />
                <span class="example">.catch(error => { </span><br />
                <span class="example2">console.log(error) </span><br />
                <span class="example">}); </span><br />
              </code>
            </div>
            <span class="link"
              >See more:
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch"
                >API OPEN WEATHER DATA</a
              >
            </span>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">async/await</h3>
          <div class="example">
            <p>
              A special syntax is required to work with promises called
              “async/await”. It can be seen as a more easy to understand syntax
              compared to the then()/catch() methods. Using the keyword 'async'
              before a function means that the function always will return a
              promise. This is also required to be able to use 'await' inside
              async functions. The keyword await makes JavaScript wait until the
              promise is settled and first thereafter returns its result.
            </p>
            
            <div class="code-container">
              <code>
                const url =
                <a
                  href="http://api.openweathermap.org/data/2.5/weather?q=London&APPID=8674cbad0da4e9ccd435f2442a4dcda7&units=metric"
                  >API OPEN WEATHER DATA</a
                >; <br /><br />

                const getWeatherData = async function() { <br />
                <span class="example">const response = await fetch(url); </span
                ><br />
                <span class="example"
                  >const weatherData = await response.json();</span
                ><br />
                <span class="example">console.log(weatherData.main.temp) </span
                ><br />
                } <br />
                <br />
                getWeatherData().catch(error => { <br />
                <span class="example">console.error(error); </span><br />
                <span class="example">console.log('Error'); </span><br />
                }) <br />
              </code>
            </div>
            <span class="link"
              >See more:
              <a href="https://javascript.info/async-await"
                >https://javascript.info/async-await</a
              ></span
            ><br />
          </div>
        </article>
      </div>

      <!-- END TUTORIAL PART 1 -->

      <span id="es6"></span>
      <div class="tutorial-part">
        <h1 class="tutorial-title">ECMAScript 2015(ES6)</h1>

        <article class="subject-article">
          <h3 class="subject-title">Variable Declaration</h3>
          <div class="example">
            <br />
            <p>
              With the introduction of ES6 support was added for the key words <i>const</i> and <i>let</i> when declaring variables.
            </p>

            <h4>const</h4>
            <p>
              const is used for declaring variables where the intention is to
              not change its value. It could be said that the value will be read
              only. It's important tough to understand that it works different
              depending on the data type. For primitive types the value is set
              once and becomes read only. For objects it works differently since
              for example an array stored with const can still receive new
              elements tough it is impossible to change the data type of the
              value.
            </p>
            
            <h4>let vs. var</h4>
            <p>
              The main difference between <i>var</i> and <i>let</i> is that
              <i>var</i> has function scope and <i>let</i> has block scope. 
			  Meaning that <i>let</i> allows for block level variables to be created, for example inside an if branch or a for loop. Another difference is that <i>let</i> declarations are not hoisted unlike variables declared with <i>var</i>. Therefore a variable declared with <i>let</i> will not be accessible before it has been initialized, trying to will result in a reference error. While doing the same with a variable declared with <i>var</i> will return as <i>undefined</i>. Another difference is that a <i>let</i> declaration will not create a property on the global object as the case with <i>var</i> declarations. 
            </p>
			
			<div class="code-container">
              <div class="comment-oneline">The <i>iterator</i> is only accessible in its own scope while <i>b</i> is accessible everywhere inside the function.</div>
			  <code>
			  function blockScope(num) {									<br />
				<span class="example">for(let i = 1; i &lt; num; i++) {		</span><br /> 
				<span class="example2">console.log(i) <span class="comment-outcome">--> 1,2,3,4</span></span><br />
				<span class="example2">var b = "I exist in function scope"	</span><br />
				<span class="example">	}									</span><br />
				<span class="example">console.log(b) <span class="comment-outcome">--> 	I exist in function scope		</span></span><br />
				<span class="example">console.log(i) <span class="comment-outcome">--> 	ReferenceError, i is not defined</span></span><br />
				}	<br />
				blockScope(5);	<br />
              </code>
			  </div>
			
            <div class="note-comment">
              <span class="first-word">Note: </span><i>var</i> will allow you to re-declare a variable in the same scope while a variable declared with <i>let</i> raises a SyntaxError.
            </div>
            <p>
              <span class="link"
                >See more:
                <a
                  href="https://stackoverflow.com/questions/762011/whats-the-difference-between-using-let-and-var"
                  >https://stackoverflow.com/questions/762011/whats-the-difference-between-using-let-and-var</a
                >
              </span>
            </p>

            <div class="code-container">
              <code>
                function checkScope() { <br />
                <span class="example"
                  >console.log(foo) <span class="comment-outcome">--> ReferenceError</span> <span class="code-comment">// foo is not hoisted </span></span
                ><br />
                <span class="example"
                  >console.log(bar) <span class="comment-outcome">--> undefined </span><span class="code-comment">// variable declaration is
                  hoisted </span></span
                ><br />
                <span class="example">let foo = "Hello" </span><br />
                <span class="example">var bar = "World" </span><br />
                <br />
                <span class="example">for(var i = 0; i &lt; 5; i++) {</span
                ><br />
                <span class="example2">console.log(i) <span class="comment-outcome">--> 0,1,2,3,4</span></span><br />
                <span class="example">}</span><br />
                <span class="example">for(let j = 0; j &lt; 5; j++) {</span
                ><br />
                <span class="example2">
                  console.log(j) <span class="comment-outcome">--> 0,1,2,3,4</span></span
                ><br />
                <span class="example">}</span><br />

                <span class="example"
                  >console.log(i); <span class="comment-outcome">--> 5</span></span
                ><br />
                <span class="example"
                  >console.log(j); <span class="comment-outcome">--> ReferenceError</span> <span class="code-comment">//
                  can not be accessed outside its scope</span></span
                ><br />
                } 	<br />
                checkScope();
              </code>
            </div>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Arrow Functions</h3>
          <div class="example">
            <p>
              Arrow functions are anonymous functions that allows us to write
              shorter more leaner code. An arrow function can omit the
              parenthesis if there is no more than one argument. It can also
              omit the square brackets and the keyword 'return' if the function
              only consist of an return statement.
            </p>

            <div class="code-container">
              <div class="comment-oneline">
                  A named function, the pre ES6 way to declare a function</div>
              <code>
                function doSmth(a) { <br />
                <span class="example"> return a * 2 </span><br />
                } <br />
              </code>
              <div class="comment-oneline">The same function refactored as an anonymous arrow function</div>
              <code> const doSmth = a => a * 2 <br /> </code>
            </div>

            <h4>Arrow functions and the keyword <i>this</i></h4>
            <p>
             One of the reasons for introducing arrow functions was the behaviour of the keyword <i>this</i>. 
			If not using arrow functions the value of <i>this</i> will depend on how the function is called. 
			To set the value of <i>this</i> and alter its default behavior inside a function, the bind() method has to be used.
            </p>
            <p>
              Arrow functions inherits <i>this</i> from the enclosing lexical scope. Meaning if <i>this</i> is not present in its current scope it will look for it in the enclosing scope. 			  
			  If <i>this</i> is used in a nested function or for example in a method of a class it will look for the value of this
              in the parent scope meaning the parent function or the class where the method was defined. 
			  In other words <i>this</i> will always represent the object that defined the
              arrow function. 
			  
			  With arrow functions the behaviour of <i>this</i> is consistent and do not change
              depending on where it is called.
            </p>
            <span class="link"
              >See more:
              <a
                href="https://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work"
                >https://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work</a
              ></span
            >
          </div>
        </article>

		<article class="subject-article">
          <h3 class="subject-title">Template Literals</h3>
          <div class="example">
            <p>
              Template Literals allows us to work with strings in a more agile
              and less ugly way. Not least the ability to use expressions gives
              lot of room for creating more dynamic code. Instead of quotes we
              use `backticks` to write string within it. We use ${variable or
              expression} instead of concatenation. Among the new features we
              also get a more agile syntax to define multiline strings.
            </p>

            <div class="code-container">
              <code>
                let firstName = "John" <br />
                let surName = "Doe" <br />
                const fullName = "John" + " " + "Doe" <span class="comment-outcome">--> John Doe</span> <span class="code-comment">// the pre ES6
                way to do it</span><br />
                <br />
                let firstName = "Lisa" <br />
                let surName = "Doe" <br />
                const fullName = `${firstName} ${surName}` <span class="comment-outcome">--> Lisa Doe</span> <span class="code-comment">// using
                template literals</span><br />
                <br />

                let divNumbers = `15 divided by 3 is ${15/3}` <span class="comment-outcome">--> 5</span> <span class="code-comment">// we insert
                an expression
				</span></code>
				<span class="comment-oneline">
                  Tagged templates allows for template literals to be parsed with functions.</span>
				  <code>
				  ...
              </code>
            </div>
			
            <span class="link"
              >See more:
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals"
                >https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals</a
              ></span>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Loops & Iteration</h3>
          <div class="example">
            <h4><i>forEach</i></h4>
            <p>
              forEach()is a higher order function that executes a callback for each element in an array. ForEach can take tree arguments, the value of the
              current elment, what is required as well as two optional
              arguments, the index for each element and the array object it
              self. The forEach method will always return undefined and is not chainable. It does not mutate the array on which it is called.
            </p>		 

            <div class="code-container">
                <span class="comment-oneline">Basic syntax </span>
                <code>
                array.forEach(function(currentValue, index, arr), thisValue)
                <br /><br />
                </code>
                <span class="comment-oneline">We loop through each name and add 'Doe'</span>
                <code>
                const myArr = ["John", "Lisa", "Tom"] <br /><br />
                myArr.forEach( name => { <br />
                <span class="example"
                  >console.log(`${name} Doe`) <span class="comment-outcome">--> John Doe, Lisa Doe...</span></span
                ><br />
                })
              </code>
            </div>
			
			<div class="note-comment">
              <span class="first-word">Note: </span>There is no way to break out from a forEach() loop, except throwing an exception.
            </div>

            <h4><i>for/in</i></h4>
            <p>
              The for/in statement iterates over all non-symbol properties of an object. The loop will iterate over all enumerable properties and those the object inherits from its constructor's prototype as well. If the intention is to only
              consider properties of the object itself and not its prototypes, use <i>getOwnPropertyNames()</i> or make sure to perform a <i>hasOwnProperty()</i> check.
            </p>
			<p>
			Tough the for/in statement can be used on arrays it's not recommended. The reason is that there is no guarantee that a for/in loop will return the values in certain order. When it comes to arrays the order of access is important unlike objects where the value is assigned to a certain property. 
			</p>
			
            <div class="code-container">
              <code>
                const myObj = { name: "John", surname: "Doe" } <br /><br />
                for(let prop in myObj) {<br />
                <span class="example">console.log(prop) <span class="comment-outcome">--> name, surname </span></span
                ><br />
                }
              </code>
			  <div class="comment-oneline">A nested for/in</div>
			  <code>
               const myObj = { test: {name: 'John Doe', age: 34 }};		<br /><br />
				for(let prop in myObj) {								<br />
				<span class="example">let innerObj = myObj[prop]		</span><br />
				<span class="example">for(let innerProp in innerObj) {	</span><br />
				<span class="example2">console.log(innerObj[innerProp])	<span class="comment-outcome">--> John Doe 34</span></span><br />
				<span class="example">	}								</span><br />
				}
              </code>
			  <div class="comment-oneline">forEach combined with for/in</div>
			  <code>
			  const employees = [							<br />			  
			  <span class="example">{name: "Lisa", role: "Adminstrator", salary: 8000},</span><br />
			  <span class="example">{name: "Tom", role: "Janitor", salary: 7000},</span><br />
			  <span class="example">{name: "John", role: "Accountant", salary: 10000},</span><br />
			  <span class="example">{name: "Patty", role: "Manager", salary: 14000},</span><br />
			  <span class="example">{name: "Sally", role: "Sale", salary: 9000}</span><br />
			];	<br /><br />
		
		employees.forEach(employee => {	<br />
		<span class="example">for(let prop in employee) {					</span><br />
		<span class="example2">let data = `${prop}: ${employee[prop]}`		</span><br />
		<span class="example2">	console.log(`${data}`)						</span><br />
		<span class="example2">	}											</span><br />
		<span class="example">	console.log('')								</span><br />
		})																	<br />
			  </code>
            </div>

            <h4><i>for/of</i></h4>
            <p>
              The for/of statement loops over iterable objects. It loops
              through data structures that are iterable such as Strings, Arrays and array-like objects such NodeLists, Maps, Set etc. In every
              iteration the value of the next property is assigned to the
              variable. for/of is in general the preferred way to loop through iterable objects. It is more concise than a conventional for loop but can't be chained like forEach().
            </p>

            <div class="code-container">
              <code>
                const myNumbers = [11,22,33,44,55]<br /><br />

                for(let number of myNumbers) {<br />
                <span class="example">console.log(number) <span class="comment-outcome">--> 11,22,33...</span></span>
                <br />
                } <br />
              </code>
              <div class="comment-oneline">To access the index we have to use entries() </div>
              <code>
                const myArr = [a,b,c] <br /><br />
                for (const [index, val] of myArr.entries()) { <br />
                <span class="example"
                  >console.log(index +": "+ val`); <span class="comment-outcome">--> "0: a", "1: b", "2: c" </span
                ></span><br />
                } <br />
              </code>
            </div>

            <h4>Summary; which loop to use and when</h4>
			  <p>
			  There are many ways to iterate over arrays and loops and they all have there strengths and tradeof:s. 
			  The standard <i>for</i> and <i>for/in</i> loop constructs gives access to the index in the iterable object but not the element. To access the element we have to print
              out the, item[index]. With for/of and forEach() on the other hand we get access to the element itself and with the latter we can also invoke an optional index argument. Accessing the index with a for/of loop requires more effort but can be done by combining destructuring with the entries method. 	  
			  </p>
            <p>			
              In general tough the most safe way to loop through an array/object will be the <i>for/of</i> loop. If, on the other hand, the intention is to manipulate every element in an array the <i>for/each</i> loop is the best choice. The <i>for/in</i> loop should only be used to iterate through the properties of an object and avoided for arrays where the index order is of importance. If the intention is to manipulate or filter data from an array consisting of objects a built in callback function should do the job most effectively (see section; 'Higher order functions'). 
            </p>
            <span class="link">
              See more:
              <a
                href="https://thecodebarbarian.com/for-vs-for-each-vs-for-in-vs-for-of-in-javascript"
                >https://thecodebarbarian.com/for-vs-for-each-vs-for-in-vs-for-of-in-javascript</a
              >
            </span>
          </div>
        </article>
		
		<article class="subject-article">
          <h3 class="subject-title">Higher Order Functions</h3>
          <div class="example">			  
			  <p>
			  When a function receives another function as an argument that function is called a higher order function. And the function you pass in is called a callback. 			  
			  With ES6 several new higher order methods were added introducing new powerful tools for handling array-based data. A typical scenario where these methods can be used are when handling JSON data from a database. We can also chain them making them even more versatile. Noteworthy; These methods do not mutate/change the orignal array, this is the behaviour we in general desire. Many situations might require a combination of different methods to achieve the desired result. In the end, as with so much more, knowing what tool/s to use and how to use them will become easier with more experience.   
			  </p>
            <h4>The <i>map</i> method</h4>
			<p>
			The map method will return a new array with the result of the callback function. The callback will be called for every element in the array and the returned value will be added to the new array. 
			The callback function can take three parameters, the element, index and the array object. Only the element is required the others are optional.		
			The map method should only be used if the intention is to create a new array, if the intention is to alter the elements in the existing array the forEach function should be used instead.	
			</p>
			<div class="code-container">
					<div class="comment-oneline">We <i>map</i> the elements and double each value</div>	
				<code>					
					let numbers = [2,4,6,8,10]	<br />
	
					let numbersDoubled = numbers.map(number => {				<br />
					<span class="example">return number * 2						</span><br />
					})													<br />	
				console.log(numbersDoubled)	<span class="comment-outcome"> --> [4,8,12,16,20] </span><span class="code-comment">// we get a new array with all numbers doubled						</span><br />					
				</code>
				<div class="comment-oneline">Refactored short-hand version</div>
				<code>
					let numbersDoubleShort = numbers.map(number => number * 2)	<br />
					console.log(numbersDoubledShort)	<span class="comment-outcome"> --> [4,8,12,16,20]	</span><span class="code-comment">// we get the same result	</span><br />
				</code>
			</div>
			
            <h4>The <i>filter</i> method</h4>
			<p>			
			The filter method provides a callback that test each element in an array and creates a new array of all the values that passes the test. In other words returns as true as result of the test. provided by the callback function. Just as the map method it accepts three arguments. The element, the index and the array object. Only the element is required the others are optional.
			</p>	
			<div class="code-container">
				<code>
					let numbers = [10, 11, 22, 33, 44, 55]		<br />
					let filteredNumbers = filter.numbers( number => {					<br />
					<span class="example">	return number > 25		<span class="code-comment">// return all numbers larger than 25</span></span><br /> 
					})	<br /><br />
					console.log(filteredNumbers) <span class="comment-outcome">--> [33,44,55]</span>
				</code>
			</div>
            <h4><i>reduce()</i></h4>
			<p>
			The reduce method reduce the array to a single value. Reduce requires two arguments the accumulator and the current value. The accumulator is the total value accumulated from the elements in the array and the current value is the value for each element when the callback is executed. The reduce method will in other words return the total value from all the elements in the array. Reduce also have three optional arguments, index, array and an initial value. If no initial value is added the callback starts its loop at index 1, in practice meaning that the accumulator starts with the value 0.    
			</p>
			
			<div class="note-comment">
              <span class="first-word">Note: </span>It's good praxis to provide an initial value, <i>even if its 0</i>, to avoid unexpected outcomes.
            </div>
			<div class="code-container">
				<code>
				let numbers = [10, 11, 22, 33, 44]	<br />
				let accNumbers = numbers.reduce( (accumulator, currentValue) =>  {	<br />
				<span class="example">return accumulator + currentValuem, 0	<span class="code-comment">// we add initial value of 0	</span></span><br />
				}) 														<br /><br />
				console.log(accNumbers) <span class="comment-outcome">--> 120 </span><br />	
				</code>
				
			</div>
            <h4><i>Sort()</i></h4>
				<p>The <i>sort</i> method will sort the elements in an array in a descending order.</p> 
				<div class="code-container">
					<code>
						let letters = ['f','g','w','t','a']				<br />
						let sortedLetters = letters.sort()				<br />
						console.log(sortedLetters) --> [a,f,g,t,w]		<br />
					</code>
				</div>				
			
            <h4><i>find()</i></h4>
            <p>...</p>
            <h4><i>includes()</i></h4>
            <p>...</p>
			
			<h4>Handle array-based data containing objects</h4>
			<div class="code-container">
			
				<div class="comment-oneline">ARRAY CONTAINING OBJECTS</div>
				<code>
				const employees = [																	<br />
				<span class="example">  {name: "Tom", role: "Accountant", age: 44, salary: 10000},	</span><br />
				<span class="example">  {name: "Lisa", role: "Adminstrator", age: 22, salary: 8000},</span><br />
				<span class="example">  {name: "John", role: "Janitor", age: 53, salary: 7000},		</span><br />
				<span class="example">  {name: "Patty", role: "Manager", age: 37, salary: 14000},	</span><br />
				<span class="example">  {name: "Sally", role: "Sale", age: 23, salary: 9000},		</span><br />
				<span class="example">  {name: "Helen", role: "IT", age: 31, salary: 11000},		</span><br />
				<span class="example">  {name: "Rex", role: "Guard", age: 3, salary: 'T-Bone'}		</span><br />
				];																					<br />
			</code>
			<br />
			<div class="comment-oneline">We <i>map</i> the employees names</div>					
				<code>
					const employeeNames = employees.map(employee => employee.name)	<br />
					console.log(employeeNames) <span class="comment-outcome">--> ['John', 'Lisa', ...]</span> <span class="code-comment">// new array consisting of names					</span><br />
			</code>			
			
			<div class="comment-oneline">We use <i>filter</i> to filter out those with high salaries and older age</div>
			<code>
				let happyEmployees = employees.filter( employee => employee.salary > 9000)	<br />	
				console.log(happyEmployees)	<span class="comment-outcome"> --> [...]</span>	<span class="code-comment">// will return an array with 3 employees(objects) 	</span><br /><br />
				
				let olderEmployees = employees.filter(employee => employee.age > 30)	<br />
				console.log(olderEmployees)	<span class="comment-outcome">--> [...] </span> <span class="code-comment">// will return an array with 4 employees(objects) 								</span><br />
			</code>
			
			<div class="comment-oneline">We chain <i>map</i> and <i>reduce</i> to get total salaries</div>
			<code>				
				let allSalaries = 	employees	<br />
							<span class="example">.map(employee => employee.salary) </span><br />
							<span class="example">.reduce( (acc, cv) => !isNaN(cv) ? acc + cv : acc + 0, 0)	</span><br />								
				console.log(allSalaries) <span class="comment-outcome">--> 48000	</span>				
			</code>
			
			<div class="comment-oneline">We add <i>filter</i> to remove the condition inside <i>reduce</i></div>
			<code>
				let salariesMapFilterReduce = employees	<br />
							<span class="example">.map(employee => employee.salary) </span><br />
							<span class="example">.filter(salary => !isNaN(salary))	</span><br />
							<span class="example">.reduce((acc, cv) => acc + cv, 0)	</span><br />			
				console.log(salariesMapFilterReduce) <span class="comment-outcome">--> 48000</span>
			</code>
			
			<div class="comment-oneline">Here we use <i>sort</i> with a comparefunction to sort the employees in alphabetical order</div>	
			<code>
				let sortedEmployees = employees.sort( employee => employee.name )	<br />
				console.log(sortedEmployees) <span class="comment-outcome">--> [John, Lisa...]	</span><br />
			</code>				
			<div class="comment-oneline"><i>find()</i> method</div>
			<code>
				...
			</code>
			
			<div class="comment-oneline"><i>includes()</i> method</div>
			<code>
				...
			</code>
			
			</div>
			
            <span class="link"
              >See more:
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#"
                >https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#</a
              ></span
            >
			<span class="link">
			See more: <a href="https://www.youtube.com/watch?v=rRgD1yVwIvE">JavaScript Higher Order Functions & Arrays (Youtube: Traversy Media)</a>
			</span>
		  </div>
        </article>
		
		<article class="subject-article">
          <h3 class="subject-title">Object Constructor Methods</h3>
          <div class="example">
		  <p>
			We already now that to create an instance of an object we have to use an object constructor function. This is done by calling the constructor function with the <i>new</i> keyword. 
			This will at the same time create a constructor property for the Object. Referencing this property will return the Object constructor that created the instance object. 
		  <div class="code-container">
			<code>
				
			</code>
		  </div>
		  
		  <h4>Built in Object constructor methods</h4>

			<p><i>Object.keys()</i> and <i>Object.values()</i></p>
				<p>....</p>
				
			<h5>Object.entries()</h5>
			<p>...</p>
	
			<h5>hasOwnProperty()</h5>
			<p>...</p>
			
		  <!--
            <i><b>Get the keys and values from the object</b></i
            ><br />
            <i>myObj = { str1: "Hello", str2: "World" }</i><br />

            <i>Extra 1; Good, now show an alternative solution.</i>
            <i
              >Extra 2; Extend your original answer and get the length(quantity)
              of the properties.</i
            >
            <i
              >Extra 3; For what can you use the constructor method
              'hasOwnProperty' and what will it return?</i
            ><br />

            <span
              >Notes: The Object.keys/values will return an array.<br />
              The Object.entries returns an array of arrays.<br />
              An easy way to check if an object is empty is to check the length
              of the 'keys' property in the Object constructor<br />
              You can define how/if a prop can be accessed/changed by using the
              corresponding Object constructor method. </span
            ><br />

            <span
              >Note: 1) Can be done with for/in as well but then it will also
              show props that are inherited by the prototype.</span
            ><br />
            <span
              >Note: 2) The length property on the Object constructor will
              return undefined.</span
            ><br />
            <span
              >Note: 3) It will return(true) for all declared properties even
              those with no value.</span
            >-->
            <span class="link"
              >See more:
              <a
                href="https://stackoverflow.com/questions/7757337/defining-read-only-properties-in-javascript"
                >https://stackoverflow.com/questions/7757337/defining-read-only-properties-in-javascript</a
              ><br />
              See more:
              <a
                href="https://stackoverflow.com/questions/5515310/is-there-a-standard-function-to-check-for-null-undefined-or-blank-variables-in"
                >https://stackoverflow.com/questions/5515310/is-there-a-standard-function-to-check-for-null-undefined-or-blank-variables-in</a
              >
            </span>
          </div>
        </article>
		
		<article class="subject-article">
          <h3 class="subject-title">Array Constructor Methods</h3>
          <div class="example">
            <br />
            <h4>Array.from()</h4>
            <p>
              The Array.from() method returns an Array object from any object
              with a length property or an iterable object.
            </p>
            <br />

            <h4>Array.isArray()</h4>
            <span class="link"
              >More about <b>shallow</b> vs <b>deep</b> copy:
              <a
                href="https://www.freecodecamp.org/news/copying-stuff-in-javascript-how-to-differentiate-between-deep-and-shallow-copies-b6d8c1ef09cd/"
                >https://www.freecodecamp.org/news/copying-stuff-in-javascript-how-to-differentiate-between-deep-and-shallow-copies-b6d8c1ef09cd/</a
              ></span
            >
          </div>
        </article>        

        <article class="subject-article">
          <h3 class="subject-title">Spread & Rest Operator</h3>
          <div class="example">
            <p>
              The spread operator will essentially take either an array or an
              object and expands it into its set of items.<br />
              The rest operator is used to create an array from a collection of
              arguments passed to a function.<br />
              It works similar to the built in arguments object used to get all
              arguments passed to a function.
            </p>

            <h4>Copying an object</h4>
            <p>
              When using the spread operator to copy an objects properties to a
              new object we make a real copy of the original.<br />It's
              important to understand the same goes for arrays, in other words
              spread can be used to make a real copy of an array. We do not copy
              the pointer/reference as is the case when we assign an object or
              array to a new variable.<br />With spread we can avoid the issue
              of an object that is manipulated affecting another object stored
              in a variable with the same pointer/reference. In other words;
              with the spread operator we copy an object in a immutable way and
              not just the pointer/reference to the same.
            </p>

            <div class="code-container">
              <code>
                const myArr = [1,2,3]; <br />
                const newArr = [...myArr,4,5] <span class="code-comment">// newArray will consist of
                [1,2,3,4,5]
                </span><br /><br />
                myObj = { name: "John" } <br />
                newObj = { ...myObj, surname: "Doe" } <span class="code-comment">// We add props from myObj
                to new Obj </span><br />
                <br />
                const myFunc = (...args) => { <br />
                <span class="example">return `All arguments ${args}`; </span
                ><br />
                } <br />
                <br />
                console.log(myFunc(1,2,3,4)) <span class="comment-outcome">--> All arguments 1,2,3,4</span>
              </code>
            </div>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Destructuring</h3>
          <div class="example">
            <p>
              When using destructuring we can pull out elements from arrays or
              properties from objects and assign them to variables.
              When it comes to arrays it is very straight forward and we we can
              use any variable name. The order matters tough.
              When it comes to objects the order doesn't matter since we use the
              corresponding property name as variable name.
            </p>

            <div class="code-container">
              <code>
                const personArray = ["John", "Lisa"]<br />
                const [a, b] = ["John", "Lisa"] <span class="code-comment">// We assign the array items to
                variables a and b
                </span><br /><br />
                const person = { name: "John", age: 28 }<br />
                const {name} = { name: "John", age: 28} <span class="code-comment">// We destructure 'John' to name variable</span>
              </code>
            </div>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Default Values</h3>
          <div class="example">
            <p>
              With ES6 support was added for the use of default values. To assign a default value we just assign a value to a function
              parameter. If no argument/s is given when calling the function it will be given its default value.
              This also works for destructuring where we can assign default values for variables.
            </p>

            <div class="code-container">
              <div class="comment-oneline">We assign default values to the parameters</div>
              <code>
                function withDefaultValues(a=10, b=20) { <br />
                  <span class="example">let sum = a + b; </span><br />
                  <span class="example">return sum;</span><br />
                  <span>}</span><br />
                  <span>withDefaultValues() <span class="comment-outcome">--> 30</span></span><br />
              </code><br />
              <div class="comment-oneline">We add an empty array as default value</div>
              
              <code>
                function addNumbers(numArr = []) { <br />
                <span class="example">let sum = 0; </span><br />
                <span class="example">numArr.forEach( num => { </span><br />
                <span class="example2"> sum += num; </span><br />
                <span class="example">}) </span><br />
                <span class="example">return sum; </span><br />
                } <br />

                addNumbers() <span class="comment-outcome">--> 0</span> <span class="code-comment">// We get no error despite calling the function with no arguments.</span>
              </code>
            </div>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Classes</h3>
          <div class="example">
            <p>
              With ES6 classes was introduced to Javascript. In reality it is only
			syntactical sugar offering an alternative syntax to existing prototype-based
              inheritance. Another word for it would be 'constructor functions' that we looked in to in the previous chapter. A class is a special type of funtions that uses the keyword class and as with constructor functions the name is capitalized by convention. 
			  A constructor method for creating and initializing an object can
              be specified in the class. If this is not done a default constructor method -
              basically an empty function - is used functioning as an empty object for
              a base class.
            </p>

            <h4>'constructor functions' vs classes</h4>
            <p>
              In most cases they are quite similar and they do the same thing
              but there are a some things that differs. A constructor requires
              the keyword <i>new</i> to work. While we still can call a
              constructor function without the keyword new this will throw an
              error when trying to do the same with a class. A class will in
              contrast to constructor functions create a constructor method by
              default if not given one. While constructor functions are hoisted
              this is not the case with class declarations. Another important
              difference is that everything that is written inside a class is
              typed in strict mode. With ECMAScript2019 we also got some new important
              features when it comes to classes. It is now possible to create
              private properties and methods using the # prefix.
              There is also the possibility to initialize public properties at
              the top of a class before specifying a constructor. There are some
              important benefits to this that I will not go deeper in to here,
              for those that are interested to dwell more into all that classes
              offers I have added some links down here that explains the concept
              more in depth.
            </p>
            
            <span class="link"
              >See more:
              <a
                href="https://www.sitepoint.com/javascript-private-class-fields/"
                >https://www.sitepoint.com/javascript-private-class-fields/</a
              >
              <br />
              See more:
              <a
                href="https://dmitripavlutin.com/javascript-classes-complete-guide/"
              >
                https://dmitripavlutin.com/javascript-classes-complete-guide/ </a
              ><br /> </span
            ><br />

            <div class="code-container">
              <code>
                let Person = function(name,gender,age) { <br />
                <span class="example">this.name = name; </span><br />
                <span class="example">this.gender = gender; </span><br />
                <span class="example">this.age = age; </span><br />
				<span class="example">this.getName = function() { return this.name }; </span><br />
                }; <br />
              </code>
            </div>
          </div>
        </article>
        
      </div>
      <!-- End Tutorial part 2 -->

      <span id="questions-part"></span>
      <div class="tutorial-part">
        <h1 class="tutorial-title">Interview Questions</h1>
        <br />

        <div class="question">
          <h3>Fundamentals</h3>
          <br />
          <div class="example">
            <h4>Explain the concepts:</h4>
            <div class="example">
              <p>primitive datatypes</p>
              <p>
                How come we can use properties and methods on primitives as with
                objects?
              </p>
              <p>'undefined'</p>
              <p>Difference between undefined and null</p>
              <p>hoisting</p>
              <p>
                Explain the behaviour of function -expressions vs -declarations
                when it comes to hoisting
              </p>
              <p>global scope vs functional scope</p>
              <p>lexical scope</p>
            </div>
            <br /><br />

            <h4>Variable declaration</h4>
            <div class="example">
              <p>Explain the difference of 'let' vs. 'var'</p>
              <p>When do we use 'const'?</p>
            </div>
            <br /><br />

            <h4>Type coercion and comparison</h4>
            <br />
            <div class="example">
              <p>What do we get?</p>
              
			  <div class="code-container">
                <code>
                  4 + "2" <br />
                  8-"2"*3 <br />
                  (4 + true + "2")/5 <br />
                  4*(3-2)/false <br />
                  Boolean("") <br />
                  true == "1" <br />
                  14%10 > 2 <br />
                  10 - "KYH" <br />
                  "0" == false <br />
					</code>
				<div class="comment-oneline">"0" is converted to a 'falsy' value but what does it
                    mean?</div><br />
				<code>
					NaN == NaN <br />
                  isNaN("Hello World") <br />
                  (true &lt; 3 &lt; 5) <br />
                  (8 &gt; 5 &gt; 3) <br />
                  (false || Boolean) <br />
                  (33 || false && true) <br />
                  (1 === 1 && "Hello") <br />
                </code>
                <span class="comment-oneline">33 and "Hello" are converted to 'truthy' values but what
                    does it mean?</span>
              </div>
            </div>
          </div>
          <br />

          <article class="subject-article">
            <h3 class="subject-title">'use strict'</h3>
            <div class="example">
              <p>
                Why would we use 'use strict' statement in a Javascript file and
                what are the consequences/benefits?
              </p>
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Reverse a String</h3>
            <div class="example">
              <i
                >Return the following string in reverse "Frontend Developer".</i
              >
              <br />
              <i
                >Extra: Show another way to achieve the same result. If not done
                already don't use the reverse method.</i
              >
              <i>Extra: Reverse a collection of type number.</i>
              <br />
              <span>Tip: reverse method only works with arrays.</span><br />
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Arrow functions</h3>
            <div class="example">
              <p>Explain arrow functions</p>
              <i
                >Convert the function to an arrow function and display the
                shortest possible version.</i
              >
              <div class="code-container">
                <code>
                  function doSomething(arg) { <br />
                  <span class="example">return arg * 2</span><br />
                  } <br />
                </code>
              </div>
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Remove Duplicates from an Array</h3>
            <div class="example">
              <i
                >Show if possible two ways to remove duplicates from an
                array.</i
              >
              <i
                >Extra: If not done already, use an object constructor method to
                remove the duplicates.</i
              ><br />
              <span>Note: All results most consist of an array.</span
              ><br /><br />
              <span>Tip: ES6 datatype 'Set' can only hold unique values.</span
              ><br />
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Sort an Array</h3>
            <div class="example">
              <p>
                Sort the array so the lowest number comes first and the highest
                last.
              </p>
			  
              <div class="code-container">
                <code> let numbers = [114,22,4,5,11,41]<br /> </code>
              </div>
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Duplicate an Array</h3>
            <div class="example">
              <i>Duplicate the array, both in pre ES6 as well as ES6.</i>
              <div class="code-container">
                <code> const numbers = [2,4,6,8] <br /> </code>
              </div>
              <i
                >Explain the importance/difference of using the spread operator
                to copy the props of an object -or the elements in an array- vs
                just assigning the object to a new variable?</i
              ><br />
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Keyword this</h3>
            <div class="example">
              <i
                >Explain how 'this' work when used in a stand-alone function
                (not; obj.method).</i
              >
              <i>How does 'this' work when used inside an arrow function?</i
              ><br />
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Destructuring</h3>
            <div class="example">
              <i><b>Destructure (solely) the last item from the array</b></i>
              
			  <div class="code-container">
                <code>
                  <span>const letters = ["A","B","C"] </span>
                </code>
                <br />
              </div>

              <i><b>What is the value of variables; a,c,d ?</b></i>
              <div class="code-container">
                <code>
                  <span>numberArr = [12,4,7] </span><br />
                  <span>const [a=5,, c, d=12] = [...numberArr] </span>
                </code>
              </div>
              <i><b>What do we get?</b></i>
              <div class="code-container">
                <code>
                  <span>const add = (a, b=5, c) => a + b</span><br />
                  <span>add(4)</span>
                  <br />
                </code>
              </div>
              <i><b>How can this be fixed without declaration?</b></i>
              <div class="code-container">
                <code>
                  {a, b} = { a: "Hello", b: "World" } <br />
                  console.log(a,b) // unexpected token... <br />
                </code>
              </div>
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Objects and Object Constructor</h3>
            <div class="example">
              <p>Array.from() ...</p>
              <i
                >Extra 1: Use the Array.from() callback/mapfunction to
                manipulate each item.</i
              >
              <i>Extra 2: How can you check if a passed value is an array?</i>
              <i
                >Extra 3: What does it mean when you do a 'shallow copy' of an
                existing array or object?</i
              ><br />

              <p>
                <b
                  >What could cause a problem when using typeof foo === "object"
                  to determine if foo is an object?</b
                >
              </p>
              <p>Show how to resolve the problem/s</p>
              <br />

              <p>
                <b>Pass the values of the car object to the showCar function</b>
              </p>
              <p>
                Note: the function needs to cope with an unknown numbers of
                arguments
              </p>
			  
              <div class="code-container">
                <code>
                  car = { model: "Volvo", color: "blue", year: "2018" }
                  <br /><br />
                  ??? <br />
                  showCar = (???)=> { <br />
                  <span class="example">return ???; </span><br />
                  } <br />
                  console.log(showCar(???)); // Display car features/values
                </code>
              </div>
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">FizzBuzz</h3>
            <div class="example">
              <i
                >Pretty common question(worth to google it...) present if
                possible 2 solutions</i
              >
              <p>
                Iterate over a 100 numbers.<br />
                When modulus 3 (remainder 0) return Buzz and when modulus 5
                return Fizz.<br />
                If both modulus 3 and 5 return FizzBuzz.
              </p>
            </div>
          </article>
        </div>
      </div>
      <div class="go-top"><a href="#top">To the Top</a><br /></div>
    </div>
    <script>
	
		// TOGGLE COLOR THEME
		const btnChangeColor = document.querySelector(".btn-change-color");
		const codeContainers = document.querySelectorAll(".code-container");
		const changeCodeColor = () => {
			Array.from(codeContainers, container => {
			container.classList.toggle("code-container-mod");
			});
		};
		btnChangeColor.addEventListener("click", changeCodeColor);
		// END TOGGLE
		
		
		// EXCERCISES 					
		class Area {
		  constructor(width, height) {
			this.width = width;
			this.height = height;
		  }		  
		  calcArea() {
			return this.width * this.height;
		  }		 
		  get Area() {
			return this.calcArea();
		  }		 
		}
				
		// STANDARD ARRAY/OBJECT
		const employees = [
			  {name: "John", role: "Accountant", age: 44, salary: 10000},
			  {name: "Lisa", role: "Adminstrator", age: 22, salary: 8000},
			  {name: "Tom", role: "Janitor", age: 53, salary: 7000},
			  {name: "Patty", role: "Manager", age: 37, salary: 14000},
			  {name: "Sally", role: "Sale", age: 23, salary: 9000},
			  {name: "Rex", role: "Guard", age: 3, salary: 'T-bone'}
			];			
		
		// Lets suppose that the data above is returned as an object consisting of objects.
		// How would we proceed to get the same data and filter as above?
		// for that we need Object constructor methods.  
		
		// OBJECT OF OBJECTS		
		const objectArray = {
			john: 	{name: "John", role: "Accountant", age: 44, salary: 10000},
			lisa: 	{name: "Lisa", role: "Adminstrator", age: 22, salary: 8000},
			tom:  	{name: "Tom", role: "Janitor", age: 53, salary: 7000},
			patty:  {name: "Patty", role: "Manager", age: 37, salary: 14000},
			sally:  {name: "Sally", role: "Sale", age: 23, salary: 9000},
			rex:	{name: "Rex", role: "Guard", age: 3, salary: 'T-bone Steak'}
		}
	
		//	WE CREATE AN ARRAY WITN ALL SALARIES AND THEN USE REDUCE TO GET THE TOTAL
		let allSalaries = employees
			.map(employee => employee.salary)
			.reduce( (acc, cv) => !isNaN(cv) ? acc + cv : acc + 0, 0)
			console.log(allSalaries)
			
		let allSalariesMapFilterReduce = employees
			.map(employee => employee.salary)
			.filter(salary => !isNaN(salary))
			.reduce((acc, cv) => acc + cv, 0)
			console.log(allSalariesMapFilterReduce)	
	
		// FILTER
		let richKids = employees.filter( employee => employee.salary > 9000)		
		let oldKids = employees.filter(employee => employee.age > 30)
		
		// THE OBJECT CONSTRUCTOR
		// we use object constructor to get values before filter  		
		let arrValues = Object.values(objectArray).filter(obj => obj.age > 32)			
		console.log("Test: ", arrValues)
		
		// more verbose solutions...
		for(let prop in objectArray) {
			if(objectArray[prop].age > 37) {
				console.log(objectArray[prop])
			}
		}
		
		const getOld = ()=> {
			let foo = []
			for(let prop in objectArray) {
				if(objectArray[prop].age > 30) {
					foo.push(objectArray[prop])
				}			
			}
			return foo
		}
				
		// REDUCE
		let numbers = [10, 11, 22, 33, 44];
		let accNumbers = numbers.reduce( (accumulator, currentValue) => accumulator + currentValue, 33)
		console.log(accNumbers)

		// SORT	
		let sortedEmployees = employees.sort( employee => employee.name )	
		console.log(sortedEmployees)		
		let letters = ['f','g','w','t','a']
		let sortedLetters = letters.sort()
		console.log(sortedLetters) 
		
		// BOOLEAN
		const myObj = new Object(false)
		if(myObj) {
			console.log("I evaluate to true")
		}
		
		if (10 > 5) {
						console.log('This is true')//--> true
					}
    </script>
    <noscript>Your browser does not support JavaScript!</noscript>
  </body>
</html>
