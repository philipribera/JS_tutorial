<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="description" content="Free Javascript Guide with Questions">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta name="author" content="Philip R">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">   
   <title>Javascript Questions</title>
   <style>
		*  {
			box-sizing: border-box;
			outline: none;
			padding: 0;
			margin: 0;			
		}
		body {
			font-family: Arial, Helvetica, sans-serif;
			background-color: rgb(101, 101, 101);
		}		
       .wrapper {			
           width: 72%;
           background-color: rgb(240, 240, 240);
           color: rgb(35, 35, 35);
           padding: 24px;
           margin: 0 auto;
       }
	   h1, h3 {
			color: rgb(242, 147, 38);
			margin: 12px 0 32px 0;
	   }
	   h1 {
			font-size: 2.1rem;
	   }
	   h3 {
			font-size: 1.55rem;
	   }
	   ul {
		padding: 4px;
		margin-left: 14px;
	   }
	   li {
		list-style-type: none;
		padding: 0 4px;		
	   }
	   	   
	   i {			
			display: block;						
	   }   
		p,i,span {
			line-height: 1.5rem;
			color: rgb(37,37,37);
			margin: 6px 0 2px 0;
		}	   
	   code {
			font-size: 1.22rem;
			line-height: 1.45rem;
			color: rgb(20, 64, 86);			
	   }
	   .log-list li {
			width: 202px;
			border-bottom: 1px solid rgb(192,192,192);
	   }
	   .log-list li:first-child {
			font-weight: 600;
	   }
	   .info-list {
			display: inline-block;
			min-width: 72px;
			margin-right: 14px;
	   }
	   	   
	   	.go-top {
			
			padding: 4px 0;			
		}				   
	   .go-top a {			
			font-size: 1rem;
			font-weight: 600;
			text-decoration: none;
			cursor: pointer;
			background: rgb(222,222,222);
			color: rgb(42, 96, 117);
			padding: 4px 6px;
			border: 1px solid rgb(190,190,190);
	   }
	   .go-top a:hover {
			opacity: 0.95;
		}	   
	   
	   .tutorial-part {
           background-color: rgb(250, 252, 252);
           padding: 30px;
           border: 2px solid rgb(202, 202, 202);
       }	  
	   .example {			
			margin: 22px 0 22px 14px;
	   }
	   .link {
			color: rgb(123, 123, 123);
			font-weight: 600;
			padding: 4px 8px;
	   }
	   .code-container {
			position: relative;
			width: 84%;
			background-color: rgb(7,7,7);
			color: rgb(247,247,247);
			padding: 26px 24px;
			margin: 12px 0 18px 0;
	   }
	   .code-container code, .code-container code span {
			color: rgb(74, 249, 105);
	   }
	   .code-container-mod code, .code-container-mod code span {
			color: rgb(255, 192, 89);
	   }
	   
	   	.code-container i {
			color: rgb(245,245,245);
		}
	   .code-container div {
			margin-left: 14px;
	   }	

		.btn-change-color  {
			position: absolute;
			right: 0;
			top: 0;
			cursor: pointer;
			background: rgb(45,45,45);
			color: rgb(222,222,222);
			padding: 6px;	
			border: 1px solid rgb(102,102,102);
		}
		
		  
		/*** MEDIA QUERIES ***/	
	   @media only screen and (max-width: 1280px) {
			.wrapper {
				width: 85%;
				padding: 20px;
			}	
			.code-container {
				width: 92%;
			}				
	   }	   
	   @media only screen and (max-width: 990px) {
			.wrapper {
				width: 100%;
				padding: 20px;
			}			
			.tutorial-part {
	           padding: 20px;
			}
			.code-container {
				width: 99%;
			}			
			h1 {
				font-size: 2rem;
			}
			h3 {
				font-size: 1.45rem;
			}				
	   }
	   @media only screen and (max-width: 767px) {
			.wrapper {				
				padding: 7px;
			}
			.tutorial-part {
	           padding: 12px;
			}						  	 
			.example {
				margin: 0;
			}
			code {
				font-size: 1.12rem;		
				line-height: 1.4em;	
			}
			h1 {
				font-size: 1.95rem;
			}
			h3 {
				font-size: 1.4rem;
			}						
	   }	  
   </style>
</head>

<body>
   <div class="wrapper">	   
       <div class="tutorial-part">           
	   
           <h1 id="top">Javascript Fundamentals with Questions</h1>		
		   <br>						  
          			
			<h3>Primitive Types</h3>
		   <div class="example">
			
			<h4>Fundamentals</h4><br>
			<span>There are 6 primitive data types: string, number, boolean, null, undefined, symbol  </span><br>
			<span>Primitive values are passed by copying the value</span><br>			
			<span>Assigning a value to a variable gives it a new value, does not mutate the original value as with objects</span>
			
		    <i>Understanding the above lets proceed...</i>		   	
			<br>

			<i><b>Primitive types are immutable! But what does it really mean?</b></i>	
		   
		   <div class="code-container">
		   <code>
			<button class="btn-change-color">Change Color</button>			

			let foo = "Hello World"	<br>		
			foo.toUpperCase() --> 'HELLO WORLD' // we use a method on foo<br>	
			console.log(foo) --> 'Hello World'  // but the original value is unchanged<br>			
			</code><br>
						
			<i><b>/*** We can do this ***/</b></i>
			<code> console.log(foo[0]) --> H // we get the 1st character
			</code>			
			<i><b>/*** But not this... ***/</b></i><code> foo[0] = "T" -->	"Hello World" // value doesn't change
			</code>
			</div>
			<i><b>How come we can use properties and methods on primitives as with objects?</b></i>  		
			<br>
			<span>Note: Primitives being immutable is the reason we can't use mutator methods on strings. For example push, reverse and sort.
			</span><br>
			<i class="link">See more; https://developer.mozilla.org/en-US/docs/Glossary/Primitive</i><br>	
			<br>
			
			<h4>Datatype 'number' and the Math object</h4><br>			
			<p>In Javascript we only have one type for numbers. There is no distinction for decimals.... etc.</p>
			<p>The Math object in Javascript is used to perform mathematical tasks on numbers</p>
			<span>Note: If a Math function can't convert an argument to a number it returns NaN.</span><br>
			<span>Note: To check for 'NaN' do not compare; NaN === NaN, this returns false since typeof NaN is number...!<br>
			With ES6 we can use, 'Number.isNaN(value)' to check for NaN,</span><br>
			<i class="link">See more; https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN</i>
			
			<p>Some common methods of the Math object:</p>

			<div class="code-container">
				<code>
				let floatNumber = 1.55			<br> 
				Math.round(floatNumber)	--> 2 // will round to closest integer	<br><br>
				
				let num1 = 2.3					<br>
				let num2 = 1.4					<br>
				Math.floor(num1 + num2)	--> 3	// will round downwards to closest integer	<br><br>
				
				Math.max(4,7,9,11)	--> 11		<br>			
				Math.min(4,7,9,11)	--> 4		<br>
				let numbers = [4,7,9,11];		<br>				
				Math.max(numbers)	--> NaN	// Math max/min do not work with arrays.<br>					
				</code>	 
				<i><b>// To solve this we can use ES6 features as spread or reduce </b></i>
				<code><br>				
				
				let rand;							<br>
				Math.random(rand) --> ? // returns a floating-point between 0 and 1.</b></i>
				</code>
			</div><br>					
			
			<h4>Understanding 'undefined'</h4><br>		   
		   
		   <div class="code-container">		   
		   <i><b>// If we try to use a variable before being declared</b></i>
		   <code>
		   console.log(a);		// Gives a reference error	<br>
		   </code>	 
			<i><b>// If we don't initialize a variable</b></i>
			<code>
		   let a; // This will give 'a' the value undefined.
		   </code>
		   <i><b>// But we can also do this</b></i>		   
		   <code>
		   let a = undefined;	// we assign the value 'undefined'<br>   
		   typeof a --> 'undefined'	<br>
		   if ( typeof a === 'undefined') --> true // We check for 'undefined'
		   </code><br>		   		
			</div>	
			
			<span>Notes: 'undefined' is of datatype 'undefined' and a so called 'falsy' value.<br> 
			Important: 'falsy' is not the same as 'false'. The latter being of datatype Boolean.<br>
			'undefined' is <b>not an error</b> in it self, tough it's often the cause of errors/bugs.<br>
			A function that doesn't return a value will always return 'undefined'.<br>
		   Javascript will automatically assign 'undefined' to a variable that are not initialized. </span><br>		   
		   <br><br>		
			
			<h4>Understanding 'null'</h4><br> 
			<div class="code-container">
			<code>
			let b = null;							<br>
			typeof b --> object 	// null basically means empty object		
		   </code><br>		   
		   </div>
		   <span>Note: The type of null is object while undefined has its own type.<br>If the purpose is to give a variable an empty value is can be done by assign it the value null, representing no value.</span><br>   		   
		   <br>		  
			</div><br>
							
			<h3>Pass by Value vs Reference</h3>
			<div class="example">
			<p>When we assign an object to new variable we copy the reference to where that object or array is stored in memory.<br>The reference works in other words as a pointer to where the object is stored, it doesn't copy the value as is the case with primitive types.<br>			
			This means that if we change the value of a property/element it impacts all variables with a reference to the same object/array.</p>						
			<br>
			<i>Primitive types, pass value by copying</i>
			<div class="code-container">			
			<code>
				let a = "KYH"		<br>
				let b = a 			<br>
				a = "Hello"  // We assign a new value to a	<br>
				console.log(b) --> "KYH"  // We retain the copied value	<br>
			</code>
			</div><br>

			<i>Objects, pass value by reference</i>
					
			<div class="code-container">			
			<code>					
				let objA = { name: "Kal", lastname: "Doe" }	<br>
				let objB = objA								<br>
				objA.name = "Ada"	// we change the value of prop name<br>
				console.log(objB.name) --> "Ada"  // prop name has changed <br>			
			</code>			
			</div>	
			<i><b>objB</b> here points to the location of the original object. It's <b>not</b> a copy of objA.</i><br> 	
			<span>Note: Function arguments are always passed by value and are copied into the function.</span><br>				
			<span>Noteworthy: If you want to make a real copy of an object/array we can use the spread operator(see more in next chapter).</span><br><br>		
			
			<span class="link">See more about passing values by reference: 
			https://stackoverflow.com/questions/16880418/javascript-pas</span><br>   			
			</div><br>

			<h3>Type Coercion & Comparisons</h3>
			<div class="example">
			<p>Javascript use type coercion to convert a value from one type to another. It can be a string to number, object to boolean, and so on.</p>
			<br>			
			
			<h4>Comparison Operators</h4>
			<p>The rules for type conversions can be confusing and it's not least important to understand the difference between <b>==</b> and <b>===</b>,<br> the former often called 'loose' equality operator' since it only compares the values and not the type and the latter being the 'strict' equivalent that compares both.</p>
			<p>The other comparison operators are; not equal to <b>!= !==</b>, greater or less than <b>> <, >= <=.</b>
			</p>
			<div class="code-container">
			<code>					
				if(1 == "1") -> true // will make a comparison after type conversion of "1" to 1 <br>
				<br>
				if(1 === "1") -> false // strict equality will check for both value and type.	
				<br>					
			</code>
			</div><br>			
			
			<h4>Logical Operators</h4>
			<p>Logical operators are used to determine the logic between variables or values. </p>
			<ul class="log-list">
				<li><span class="info-list">Operator</span><span class="info-list"> Description</span> 
				<li><span class="info-list">&&</span><span class="info-list">and</span></li>
				<li><span class="info-list">||</span><span class="info-list">or</span></li>
				<li><span class="info-list">!</span><span class="info-list">not</span></li>
			</ul>			
			<br><br>
			
			<h4>Implicit vs. explicit coercion</h4>	<br>	
			<p>Type conversion can be done implicit and explicit.</p>
			<p>
			An example of implicit(automatic) type conversion is when using the loose equality operator.<br> Since it only compares the values and not the type Javascript will seek to make a type coercion so both values also share the same type. <br>As a developer such code should be avoided since it's often the reason for bugs.</p> 			
			<p>Explicit coercion on the other hand is done on purpose, for example by using Number(value) that seeks to convert the value to the type 'number'.</p>
			<br>
				<span class="link">See more about type coercion: https://www.freecodecamp.org/news/js-type-coercion-explained-27ba3d9a2839/
			</span><br>		
			</div><br>
				 
				 
			<h3>Global vs Function Scope</h3>
			   <div class="example">
			   <i>Explain the concepts</i>
			   <i>Explain <b>lexical scope</b> in Javascript</i><br>	   		
			   </div>
			   <br>		   	   
		   
			<h3>Hoisting</h3>
			<div class="example">	
				<i>Explain the concept</i>
				<i>Explain as well the behaviour of function -expressions vs -declarations when it comes to hoisting</i>
				<br>
				
				<i><b>Check: </b></i>
				<div class="code-container">
				<code>
					1)							<br>
				   var testScope = function()	{ <br>							
				<span class="example">console.log(y);</span><br>
				<span class="example">var y = 1;	 </span><br>
				   }							<br>						
				   testScope();					<br>
				   
				   </code>
				   <i><b>// 1) Variable declarations are hoisted inside functions as well</b></i>					
				<br>
				
				<code>				
					2)<br>
					var y = 2;						<br>
													<br>
					var testScope = function() { 	<br>
					<span class="example">console.log(y);	</span><br>
					<span class="example">var y = 1;		</span><br>
					}								<br>
					testScope();					<br>
					
					</code>
					<i><b>// 2) Anonymous function expressions are not hoisted</b></i><br>	
					
					<code>
					3)<br>
					var y = 2;						<br>
													<br>
					var testScope = function() { 	<br>
					<span class="example">	console.log(y);</span><br>	
					}								<br>
					testScope();					<br>
					</code>	
					</div>
			</div><br>
			<br>
			
			<h3>Usage of common String and Array methods</h3>
			<div class="example">		   
			<b>Explain and show how to use these methods.</b>
			<p>push, split, slice, join, sort, indexOf, charAt</p><br>
		   
		   <i><b>What does this gives us?</b></i>
			
			<div class="code-container">
			<code>		   
		    let greet = new String("Hello")	<br>					
			typeof greet 					<br>
			greet.charAt(greet.length-1)	<br><br>
			
			let str = "KYH Frontend"		<br>
			typeof str 						<br>						
			str.indexOf("F")				<br><br>
			
			let foo = str.split(" ")		<br>
			typeof foo 						<br>
			foo.sort()						<br><br>
						
			let first = foo.slice(0,1)		<br>			
			foo.push(first.join())			<br>
			console.log(foo)				<br><br>				
			
			foo.constructor 				
			</code><br>
			</div>				
			<span>Note: push and sort are so called mutator methods since they change the original array. Push for example adds item/s to the end of the array while returning the new length of the array. Mutator methods can't be used with strings because... ( you know why! )
			<i>...since primitive types are immutable.</i>
			</span>
			<span>Note: We can use console.dir() to get more info about the constructor
			</span><br>			
			<br>	
			<span class="link">More about strings: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Methods_2</span>			
			<br>
			
			<span class="link">More about arrays: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype#Methods</span><br>		
			</div><br>
			
			<h3>Promises</h3>	
			<div class="example">
			<i>Explain promises in Javascript</i> 
			<br>
			<span class="link">More about promises: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises</span>
			</div><br>	
			
			<h3>Closures</h3>	
			<div class="example">
			<i>Explain closures in Javascript</i><br>
			
			<span class="link">More about closures: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures</span>
			</div><br>								
			
		</div><br><!-- END TUTORIAL PART 1 -->           	   
		   
		<div class="tutorial-part">
           <h1>ES6 Features</h1>
		   <br><br>
		   
		   <h3>Arrow functions</h3>
		   <div class="example">
		   <i>1) Convert the function to an arrow function.<br>
		   2) Display the shortest possible version.</i>	
			<div class="code-container">
			<code>		   
				function doSomething(arg) {	<br>
					<span class="example">return arg * 2</span><br>
				}	<br>
			</code>
			</div>
		   </div><br>
		   
		   <h3>Default values</h3>
		   <div class="example">			
		   <p>To assign a default value we can just assign a value to a function parameter<br> 
			This also works for destructuring where we can assign default values for variables.</p>
		   <br>
		   <div class="code-container">
			<code>
				
				function addNumbers(numArr = []) {	// We add an empty array as default value<br>
					<span class="example">let sum = 0;	</span><br>
					<span class="example">numArr.forEach( num => {	</span><br>
					<span class="example">	sum += num;			</span><br>
					<span class="example">})					</span><br>
					<span class="example">return sum;			</span><br></span>
				}									<br>
				
				addNumbers() -> 0	// We get no error despite calling the function with no arguments.
												
			</code>
			</div>			
				
		   </div><br>
		   
           <h3>Key word 'this'</h3>
		   <div class="example">			
			<i>What gets returned when we call 'this'?</i>			
			<i>Explain how 'this' work when used in a stand-alone function (not; obj.method).</i>
			<i>How does 'this' work when used inside an arrow function?</i><br>
			<span>Note: if 'use strict' mode is enabled 'this' in a stand-alone function will return 'undefined'.</span><br> 
			<span class="link">See more: https://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work</span><br>
			</div><br>
		
			<h3>Higher order functions</h3>
			<div class="example">
			<i>Explain how to use with examples</i><br>

            <h4>map</h4>
		    <h4>filter</h4>		   		   
            <h4>reduce</h4><br>		 
			
			<h4>find</h4>
			<h4>includes</h4><br>
						
		    <span>Note: These methods do not mutate/change the orignal array (in general a good thing!)</span><br>
			<span class="link">See more: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#</span><br>
			</div>		   
            <br>
		   		   
		   <h3>Loops & Iteration</h3>
		   <div class="example">
           <i>Explain how and when to use with examples</i><br>
           <h4>forEach</h4>
           <h4>for/in</h4>
           <h4>for/of</h4>
		   </div>
           <br>
		  		   
		   <h3>Template Literals</h3>
		   <div class="example">
		   <p>Template Literals allows us to work with strings in a different way compared to earlier.<br>
		   It's a more agile and less ugly way to write code but not least the ability to use expressions gives lot of room for creating more dynamic code.</p>
		   
		   <p>Instead of quotes we use `backticks` to write string within it.
		   We use ${variable or expression} instead of concatenation.	<br>		
		   Among the new features we also get a more agile syntax to define multiline strings.<br> 
		   
			
		   <div class="code-container">
			<code>
				let firstName = "John"	<br>
				let surName = "Doe"		<br>
				const fullName = "John" + " " + "Doe"	-> John Doe // The pre ES6 way to do it.<br>
				<br>
				let firstName = "Lisa"	<br>
				let surName = "Doe"		<br>
				const fullName = `${firstName} ${surName}` -> Lisa Doe // Using template literals<br> <br>
				
				let divNumbers = `15 divided by 3 is ${15/3}` -> 5 // We insert an expression 				
			</code>			
			</div>		  
			<span class="link">See more: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals 
			</span><br>
		   </div>
		   <br>
		   
		   <h3>Classes</h3>
		   <div class="example">
			
			<i>Rewrite the constructor function with ES6 alt ES7 class syntax</i>
			<i>+ Add a method that returns all the class properties</i>
			<div class="code-container">
			<code>
			let Person = function(name,gender,age) {	<br>
			<span class="example">this.name = name;		</span><br>
			<span class="example">this.gender = gender;	</span><br>
			<span class="example">this.age = age;		</span><br>
			};								<br>							
			</code>			
			</div>			
		   </div><br>		   
		    
		   <h3>Spread & Rest Operator</h3>
		   <div class="example">
		   <p>The spread operator will essentially take either an array or an object and expands it into its set of items.<br>	
		   The rest operator is used to create an array from a collection of arguments passed to a function.<br> It works similar to the built in arguments object used to get all arguments passed to a function.</p>
		   <br><br>
		   
		   <h4>Understanding the impact of the spread operator when copying an object</h4>
		   <p>When using the spread operator to copy an objects properties to a new object we make a real copy of the original.<br>It's important to understand the same goes for arrays, in other words spread can be used to make a real copy of an array. We do not copy the pointer/reference as is the case when we assign an object or array to a new variable.<br>With spread we can avoid the issue of an object that is manipulated affecting another object stored in a variable with the same pointer/reference.<br> In other words; with the spread operator we copy an object in a immutable way and not just the pointer/reference to the same.</p><br>				
		   <div class="code-container">
			<code>		   				
				const myArr = [1,2,3]; <br>
				const newArr = [...myArr,4,5] // newArray will consist of [1,2,3,4,5]
									<br><br>
				myObj = {	name: "John"	}			<br>							
				newObj = {	...myObj, surname: "Doe" }	// We add props from myObj to new Obj <br> 				
				<br>				
				const myFunc = (...args) => {			<br>
					return `All arguments ${args}`;		<br>
				}										<br>										<br>							
				console.log(myFunc(1,2,3,4)) -> All arguments 1,2,3,4
				
			</code>
			</div>		   
		   </div><br>		   
		   
		   <h3>Destructuring</h3>		   		   
		   <div class="example">
		   
		   <p>When using destructuring we can pull out elements from arrays or properties from objects and assign them to variables.<br>
		   When it comes to arrays it is very straight forward and we we can use any variable name. The order matters tough.<br> 
		   When it comes to objects the order doesn't matter since we use the corresponding property name as variable name.</p>
		   
   		   <div class="code-container">

		   <code>
			const [a, b] = ["John", "Lisa"] // We assign the array items to variables a and b.
			<br>
			const {name} = { name: "John", age: 28} // We assign the name prop to variable name.
		   </code>
			</div><br>					
		   </div>
		           
		   <h3>Array constructor methods</h3>
		   <div class="example">		   
           <i><b>Array.from(), Explain what it does</b></i><br>		   
			<i>Extra 1: Use the Array.from() callback/mapfunction to manipulate each item.</i>					   
		   <i>Extra 2: How can you check if a passed value is an array?</i>
		   <i>Extra 3: What does it mean when you do a 'shallow copy' of an existing array or object?</i><br>
		   <span class="link">More about <b>shallow</b> vs <b>deep</b> copy: https://www.freecodecamp.org/news/copying-stuff-in-javascript-how-to-differentiate-between-deep-and-shallow-copies-b6d8c1ef09cd/</span><br>
	   	</div><br>
			
	   <h3>Object constructor methods</h3>
		<div class="example">
			<i><b>Get the keys and values from the object</b></i><br>
		    <i>myObj = { str1: "Hello", str2: "World" }</i><br>
			
		    <i>Extra 1; Good, now show an alternative solution.</i>			
			<i>Extra 2; Extend your original answer and get the length(quantity) of the properties.</i>
			<i>Extra 3; For what can you use the constructor method 'hasOwnProperty' and what will it return?</i><br> 
				
			<span>Notes: The Object.keys/values will return an array.<br>		
			The Object.entries returns an array of arrays.<br>		
			An easy way to check if an object is empty is to check the length of the 'keys' property in the Object constructor<br>
			You can define how/if a prop can be accessed/changed by using the corresponding Object constructor method.
			</span><br>	  
			
			<span class="link">More about define access to props:  https://stackoverflow.com/questions/7757337/defining-read-only-properties-in-javascript
			</span><br> 
			
			<span class="link">See more; https://stackoverflow.com/questions/5515310/is-there-a-standard-function-to-check-for-null-undefined-or-blank-variables-in
			</span><br><br>
						
			<span>Note: 1) Can be done with for/in as well but then it will also show props that are inherited by the prototype.</span><br>
			<span>Note: 2) The length property on the Object constructor will return undefined.</span><br>
			<span>Note: 3) It will return(true) for all declared properties even those with no value.</span>
			<br>	  
	   </div>		   
	   </div><br><!-- End Tutorial part 2 --> 	   	   
	   
	   <div class="tutorial-part">  
	   <h1>Interview Questions</h1><br>
	   	   
		<h3>Fundamentals</h3>
	   <div class="example">		
		<span><b>Explain the concepts below:</b></span><br>
		
		<i>The difference of 'let' and 'var' when declaring variables</i>
		<i>How does 'const' work</i>
		<i>The concept of 'undefined'.</i>
		<i>The difference between 'undefined' and 'null'.</i>		   
		<i>The concept of hoisting</i>
		<i>The concept of global scope vs functional scope</i>
		<i>The concept of lexical scope</i>
		</div><br>	 
		
		<h3>Type coercion</h3>
	   <div class="example">	
		<i><b>What do we get?</b></i>		
			<div class="code-container">
			<code>
			4 + "2"					<br>					
			8-"2"*3 				<br>
			(4 + true + "2")/5 		<br>			
			4*(3-2)/false 			<br>
			Boolean("") 			<br>
			true == "1" 			<br>
			44%10 > 2				<br>								
			10 - "KYH" 				<br>
			"0" == false 			<br>
			</code>			
			<b>// "0" is converted to a 'falsy' value. What does it mean?</b>
			<br><br>
			<code>
			(true &lt; 3 &lt; 5)	<br>
			(8 &gt; 5 &gt; 3)		<br>
			(false || Boolean)		<br>		
			(33 || false && true) 	<br>
			(1 === 1 && "Hello")	<br>			
			</code>
			<b>// 33 and "Hello" are converted to 'truthy' values. What does it mean?</b>
			<br>			
			</div>				
		</div><br>
			
		<h3>'use strict'</h3>
	   <div class="example">
	   <p>	
		Why would we use 'use strict' statement in a Javascript file and what are the consequences/benefits?</p> 
		</div>		
		<br>			
			
	   <h3>Reverse a String </h3>
			<div class="example">
			 <i>Return the following string in reverse "KYH Frontend Developer".</i>
			 <br>
			 <i>Extra: Show another way to achieve the same result. If not done already don't use reverse().</i>			 
			 <i>Extra: Reverse a collection of type number.</i>
			 <br>
			 <span>Tip: reverse method only works with arrays.</span><br>
			</div><br>
			
			<h3>Duplicate an Array</h3>
			<div class="example">
			<i>Show how to do it both in pre ES6 as well as ES6.</i>	
			</div><br>
			
			<h3>Sort an Array with numerical values</h3>           			
			<div class="example">
			<p>let numbers = [114,22,4,5,11,41]</p>
			<br>
			<i>Extra: Get the highest number.</i><br>			
			</div>
		   <br>
						   
           <h3>Remove Duplicates from an Array</h3>
   		   <div class="example">
           <i>Show if possible two ways to remove duplicates from an array.</i>
		   <i>Extra: If not done already, use an object constructor method to remove the duplicates.</i><br>
		   <span>Note: All results most consist of an array.</span><br><br>
   		   <span>Tip: ES6 datatype 'Set' can only hold unique values.</span><br>  </div><br>	   
		   
		   <h3>Spread and rest</h3>
		   <div class="example">
		   <i>Use the spread operator to copy the properties of an object into a new object.</i>
			<i>Explain the importance/difference of using the spread operator to copy the props of an object vs just assigning the object to a new variable?</i>
			</div><br>
			
			<h3>Destructuring</h3>
			<div class="example">
					   
		   <i><b>Destructure (solely) the last item from the array</b></i>  
		   <div class="code-container">
		   <code>
		   	<span>const letters = ["A","B","C"]	</span>
		   </code>
		   <br>
		   </div>
		   
		   <i><b>What is the value of variables; a,c,d ?</b></i>
		   <div class="code-container">
		   <code>
		   <span>numberArr = [12,4,7]	</span><br>	   
			<span>const [a=5,, c, d=12] = [...numberArr] </span>	   	
			</code>
			</div>
			<i><b>What do we get?</b></i>
		   <div class="code-container">		   
		   <code>	   		   
		   <span>const add = (a, b=5, c) => a + b</span><br>	   		   
		   <span>add(4)</span>
		   <br>
   		   </code>
		   </div>
			<i><b>How can this be fixed without declaration?</b></i>
			<div class="code-container">
			<code>
			{a, b} = { a: "Hello", b: "World" }			<br>
			console.log(a,b)	// unexpected token...	<br>
			</code>
			</div>		   
			</div><br>
					
					
		<h3>Objects and Object Constructor</h3>
		<div class="example">
		<p>
		What could cause a problem when using typeof foo === "object" to determine if foo is an object? 
		</p>
	   	<p>Show how to resolve the problem/s</p>    
		<br>

		<i><b>Pass the values of the car object to the showCar function</b></i>
		<i>Note: the function needs to cope with an unknown numbers of arguments</i>
		<div class="code-container">
		<code>	   
		car = { model: "Volvo", color: "blue", year: "2018" } <br><br>
			???	<br>			
			showCar = (???)=> {			<br>			
			<span class="example">return ???;	</span><br>
			}							<br>			
			console.log(showCar(???)); // Display car features/values
			</code>			
			</div><br>
							
		   <h3>FizzBuzz</h3>
		   <div class="example">
		   <i>Pretty common question(worth to google it...) present if possible 2 solutions</i>
           <p>Iterate over a 100 numbers.<br>
		   When modulus 3 (remainder 0) return Buzz and when modulus 5 return Fizz.<br>
		   If both modulus 3 and 5 return FizzBuzz.</p>
			</div>
			<br>
	   </div>
	   	   
	   <div class="go-top"><a href="#top">To the Top</a><br>
	   </div>
	   
	   </div>
       <script>	
			
			// Toggles code color between green and orange
			const btnChangeColor = document.querySelector('.btn-change-color');
			const codeContainers = document.querySelectorAll('.code-container');						
			const changeCodeColor = ()=> {
				Array.from(codeContainers, container => {
					container.classList.toggle('code-container-mod');
				})
			}
			btnChangeColor.addEventListener('click', changeCodeColor);			
			
			
			function addNumbers(numArr = []) {  
				let sum = 0;
				numArr.forEach( num => {
				sum += num;
				})
				return sum;
				}
				
				console.log( addNumbers([1,4,6]) )
						
	   </script>
	   <noscript>Your browser does not support JavaScript!</noscript>
	   </body>
	   </html>