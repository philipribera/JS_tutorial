<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content="Free Javascript Guide with Questions" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="author" content="Philip R" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Javascript Questions</title>
    <style>
      * {
        box-sizing: border-box;
        outline: none;
        padding: 0;
        margin: 0;
      }
      body {
        font-family: "Montserrat", Helvetica, sans-serif;
        background-color: rgb(215,215,215);
      }
      header {
        width: 100%;
        height: 72px;
        position: fixed;
        top: 0;
        z-index: 9999;
        background-color: rgb(77, 77, 77);
        box-shadow: 1px 1px 2px 1px rgb(102, 102, 102);
      }
      .header-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: flex-end;
        align-items: center;
        padding: 0 5%;
      }
      .header-title {
        margin-right: auto;
      }
      .header-title h3 {
        font-size: 1.4rem;
        color: rgb(244, 244, 244);
      }
	  .header-menu ul {
		margin: 0;
	  }
      .header-menu li {
        padding: 14px;
      }
      .header-menu a {
        color: rgb(247, 247, 247);
      }
      .header-menu ul li {
        display: inline;
        cursor: pointer;
      }
      .header-menu ul a:hover {
        color: rgb(255, 159, 32);
      }
      .wrapper {
        display: block;
        width: 100%;
        max-width: 984px;
        background-color: rgb(252, 252, 252);
        color: rgb(35, 35, 35);
        padding: 26px;
        margin: 42px auto;
      }

      /*** GENERICS ***/
      p {
        color: rgb(17, 17, 17);
      }
      h1,
      h2,
      h3 {
        color: rgb(242, 147, 38);
      }
      h1 {
        font-size: 2.1rem;
      }
      h3 {
        font-size: 1.55rem;
      }
      h4 {
        font-size: 1.15rem;
        color: rgb(39, 39, 39);
		    margin: 32px 0 12px 0;
      }
      ul {
        padding: 4px;
        margin-left: 14px;
      }
      li {
        list-style-type: none;
        padding: 0 4px;
      }
      a {
        color: rgb(132, 132, 132);
        text-decoration: none;
      }
      p,
      span,
      b {
        color: rgb(37, 37, 37);
        line-height: 1.55rem;
      }
      code {
		font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
			monospace;
        font-size: 1rem;
        line-height: 1.72rem;
        color: rgb(20, 64, 86);
      }

      /*** CLASSES ***/
	  .expand-text {
		font-size: 1.1rem;
	  }
      .tutorial-title {
        margin: 20px 0;
      }
	  .log-list {
		margin: 22px 0;
	  }
      .log-list li {
		display: flex;        
        border-bottom: 1px solid rgb(212, 212, 212);
      }
      .log-list li:first-child {
        font-weight: 600;
      }
	  .log-list li:last-child {
		flex: 1;
	  }
      .info-list {
        display: inline-block;
        min-width: 72px;
        margin-right: 14px;
      }
      .go-top {
        padding: 4px 0;
      }
      .go-top a {
        font-size: 1rem;
        font-weight: 600;
        text-decoration: none;
        cursor: pointer;
        background: rgb(222, 222, 222);
        color: rgb(42, 96, 117);
        padding: 4px 6px;
        border: 1px solid rgb(190, 190, 190);
      }
      .go-top a:hover {
        opacity: 0.95;
      }
      .tutorial-part {
        padding: 28px 28px 30px 28px;
        border-bottom: 4px solid rgb(207, 207, 207);
      }
      .tutorial-part:not(:first-of-type) {
        margin-top: 24px;
      }
      .subject-article {
        display: inline-block;
		width: 100%;
        margin: 24px 0;
      }
      .subject-title {
        margin-bottom: 18px;
      }
      .example {
        margin-left: 14px;
      }
      .example2 {
        margin-left: 28px;
      }
	  .example3 {
		margin-left: 42px;
	  }
      .link {
        word-break: break-all;
        display: inline-block;
        color: rgb(123, 123, 123);
        font-weight: 600;
        margin: 12px 0;
      }
      .code * {
        word-break: break-all;
      }
      .code-container {
        position: relative;
        background-color: rgb(236, 236, 236);
        color: rgb(247, 247, 247);
        padding: 22px 24px 24px 24px;
        margin: 22px 0 24px 0;
        overflow: auto;
      }
      .code-container code,
      .code-container code span {
        color: rgb(19, 76, 105);
      }
      .code-container i {
        color: rgb(37, 63, 110);
        line-height: 2.15rem;
      }
      .code-container .comment-oneline {
        display: block;
        color: rgb(41, 54, 103);
        opacity: 0.95;
        font-weight: 600;
        margin: 18px 0 12px 0;
      }
	  .subject-article .code-container:first-child {
		margin-top: 0;
	  }	  
	  
      .code-container-mod {
        background-color: rgb(9, 9, 9);
      }
      .code-container-mod code,
      .code-container-mod code span {
        color: rgb(74, 249, 105);
      }
      .code-container-mod .comment-oneline {
        color: rgb(237, 238, 237);
      }
	  .code-container-mod span.comment-outcome {
		color: #62ff2e;
	  }
      .question {
        margin-bottom: 54px;
      }
      .btn-change-color {
        position: absolute;
        right: 0;
        top: 0;
        cursor: pointer;
        background: rgb(45, 45, 45);
        color: rgb(222, 222, 222);
        padding: 6px;
        border: 1px solid rgb(102, 102, 102);
      }
      #fundamentals,
      #es6,
      #questions-part {
        display: block;
        position: relative;
        top: -120px;
        visibility: hidden;
      }	 
	  
		code span.comment-outcome {
			font-weight: 600;
			color: rgb(82,101,167);
		}
	    .note-comment {
		    display: inline-block;
			width: 100%;
		    background-color: rgb(255,226,168);
		    padding: 16px 12px;
		    margin: 20px 0;
	    }
	    .first-word {
		    color: rgb(37,37,37);
		    font-weight: 600;
	    }
		
		.falsy-list {
			width: 30%;
			padding: 12px 4px;
			margin: 4px 0;
		}
		.falsy-list li {
			padding: 4px;
			border-bottom: 1px solid rgb(242,242,242);
		}
		.falsy-list li:nth-child(odd) {
			background-color: rgb(240,240,240);
		}
		.list-comment {
			padding-left: 16px;
		}

      /*** MEDIA QUERIES ***/
      @media only screen and (max-width: 990px) {
        .tutorial-part {
          padding: 20px;
        }
        .code-container {
          width: 99%;
          padding: 20px;
        }
        h1 {
          font-size: 2rem;
        }
        h3 {
          font-size: 1.45rem;
        }
      }
      @media only screen and (max-width: 767px) {
        .wrapper {
          padding: 12px;
          margin: 94px 0 0 0;
        }
        .tutorial-part {
          padding: 6px;
        }
		.subject-article {
			margin: 20px 0;
		}
        .example {
			margin-left: 10px;
		}
		.example2 {
			margin-left: 22px;
		}
		.example3 {
			margin-left: 32px;
		}
        .code-container {
          width: 99%;
          padding: 20px 14px;
        }
        h1 {
          font-size: 1.95rem;
        }
        h3 {
          font-size: 1.4rem;
        }
        i {
          line-height: 1.6rem;
        }
		.falsy-list {
			width: 70%;
			padding: 10px 2px;
			margin: 0;
		}
      }
      @media only screen and (max-width: 600px) {
		.wrapper {
          padding: 10px;
		}
        .header-container {
          display: flex;
          flex-wrap: wrap;
          text-align: center;
          justify-content: center;
          height: auto;
          padding: 20px 14px 8px 14px;
        }
        .header-title {
          display: block;
          margin-bottom: 10px;
        }
        .header-title h3 {
          font-size: 1.15rem;
        }

        .header-menu {
          justify-content: center;
        }
        .header-menu ul,
        .header-menu li {
          padding: 9px;
        }

        .collapsed-menu {
          display: block;
        }
        .wrapper {
          width: initial;
        }
        .code-container {
          padding: 18px 12px;
        }
        h1 {
          font-size: 1.8rem;
        }
        h3 {
          font-size: 1.37rem;
        }
        .example {
          margin-left: 0;
        }
      } 	  
    </style>
  </head>

  <body>
    <header class="header-container">
      <div class="header-title">
        <h3>JAVASCRIPT FUNDAMENTALS WITH QUESTIONS</h3>
      </div>
      <div class="header-menu">
        <ul>
          <li><a href="#fundamentals">Fundamentals</a></li>
          <li><a href="#es6">ES6</a></li>
          <li><a href="#questions-part">Questions</a></li>
        </ul>
      </div>
    </header>

    <div class="wrapper">
      <br />
      <span id="fundamentals"></span>
      <div class="tutorial-part">
        <h1 class="tutorial-title">Javascript Fundamentals</h1>

		<article class="subject-article">
          <h3 class="subject-title">Introduction</h3>
          <div class="example">
			<p>
			Javascript is the language of the web, it is an interpreted language that runs directly on the clients browser meaning that no compiler is needed. This is the core of Javascript; It was designed to be easy to use and easy to learn. It also explains some of its characteristics, strengths and drawbacks, that differentiate it from some of the most common programming languages. But Javascript has evolved a lot since its introduction and with the latest updates it has become a much more versatile language. Now days Javascript isn't limited to the browser either. With the help of <i>Node</i> it can be run on both the browser and on the server side.  
			</p><br />
			<p>
			This tutorial will not focus on the rules for how to name variables or explain what an expression is. There are already good tutorials that explains the core basic in detail. With the exception of a few pointers on some basic facts, this tutorial will focus on the core concepts of the language to get a better understanding on how Javascript works. There is also a chapter dedicated to the ECMAScript 2015 update(ES6) and how to use some of the new features that was introduced. The ES6 update was probably the most important development of Javascript since its introduction making Javascript more powerful and versatile.   
			</p>

		  <h4>Dynamically typed</h4>
            <p>
			 Javascript is what we call <i>dynamically typed</i> meaning the type of an variable is interpreted by the compiler. Sometime Javascript is also called a <i>weakly typed</i> language in contrast to languages that are <i>strongly</i> or <i>static</i> typed where a variable has to be given a type when it's declared. 
			 Javascript being dynamically typed means that variable types will be interpreted and if necessary even change implicitly at runtime. With runtime meaning when the program executes the commands. The type and value can be changed at any time both explicit in the code or implicitly by the Javascript engine. This behaviour can be confusing and give unexpected outcomes if not understood fully. Before looking deeper into this tough we need to get a better understanding on different data types and their behaviour in Javascript.      
			</p>
			
		<h4>Data Types</h4>
			<p>
			  Data types specify what kind of data can be stored and manipulated in the Javascript memory. Data types in Javascript are either objects or primitives. While there is only one <i>object</i> data type there are 7 primitive data types:
              <i>string, number, boolean, null, undefined, bigInt</i> and
              <i>symbol</i>. The fundamental difference between primitives and objects is that primitives can hold a single value while objects can hold a collection of data and values. Javascript being weakly typed means that we do not specify a certain type when declaring a variable (there are exceptions tough). But even if no type is implicitly given Javascript will give the variable a type depending on the value it was given when initialized. If the variable hasn't been initialized it will get a type as <i>undefined</i>. 
			</p>
			
			<span class="note-comment">
              <span class="first-word">Note: </span>
			  Javascript is case-sensitive; meaning that consistent capitalization of characters matters when it comes to keywords, variables- and function names.</span>
			
			<span class="note-comment">
              <span class="first-word">Note: </span>
			  The <i>var</i> keyword will be used in code examples until the section 'Variable Scope' where variable declarations are explained more in depth.</span>
			
			</div>			
		</article>
        
        <article class="subject-article">
          <h3 class="subject-title">Primitive types</h3>
          <div class="example">		  
            <p>
              Primitive values can not have properties and methods since they
              are not objects. But Javascript can, depending on the circumstances, treat primitive values as objects. Javascript does this by wrapping the value in an object kind of entity making it possible to apply properties and methods on them. One example is the 'length' property that can be applied on strings.
			</p>
			<br />
			<p>
			But even if primitives can behave as objects there are some important differences when compared with objects. Apart from only being able to hold a single value they are also non-mutable. Meaning that assigning a value to a variable that already holds a value replaces this value with a new value. It does not mutate the original value as the case with objects. The fact that primitives are non-mutable is the reason mutator methods - <i>methods that change the original value</i> - can not be applied on strings. For example push, reverse and sort. Another difference is that primitive values are passed by <i>copying the value</i>. This means that if the value is assigned to a new variable it's copied and can be changed without affecting the value of the original variable. Objects on the other hand <i>pass value by reference</i>.
            </p>
			  
            <div class="code-container">
                <button class="btn-change-color">Change Theme</button>
                <div class="comment-oneline">
                We use the length property/element
                </div>
                <code>
                var str = "Hello World"<br />
                console.log(str.length) <span class="comment-outcome">--> 11</span>// We get the numbers of characters<br />
                <br />
                 </code> 
                <div class="comment-oneline">
                Primitive values do not mutate
                </div>
                <code>
                var foo = "Hello World" <br />
                foo.toUpperCase() <span class="comment-outcome">--> HELLO WORLD</span> // we use a method on foo<br />
                console.log(foo) <span class="comment-outcome">--> Hello World</span> // the original value is
                unchanged<br /> </code
              ><br />

              <div class="comment-oneline">We can do this</div>
              <code>
               foo[0]) <span class="comment-outcome">--> H</span> // we get the 1st character<br /> </code
              ><br />
              <div class="comment-oneline">But not this...</div>
              <code>
                foo[0] = "T" // We try to assign foo[0] a new value<br />
                console.log(foo) <span class="comment-outcome">--> Hello World</span> // value of 'foo' doesn't change <br />
              </code>
            </div>
						
            <i class="link"
              >See more;
              <a
                href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive"
                >https://developer.mozilla.org/en-US/docs/Glossary/Primitive</a
              ></i
            ><br />
            
            <h4><i>string</i></h4>
            <p>The string type holds data that can be represented as text. String values consists of normal characters, special characters can be encoded using the escape character '\'. In Javascript strings can be denominated with both single and double quotes. With ES6 support was also added for 'template literals'. Template literals also allows for variables and expressions to be embedded with string literals. (we will cover template literals further in the chapter 'ES6 Features'. 
			</p>
			
			<div class="code-container">			
				<div class="comment-oneline">Some common methods used with strings</div>
				<code>
                var greet = "Hello World"		 				<br />                
				greet.charAt(0) <span class="comment-outcome">--> H</span>	<br />
				greet[0] <span class="comment-outcome">--> H </span>// we use bracket notation<br />
				greet.indexOf("W")<span class="comment-outcome"> --> 6</span><br /><br />

                var str = new String("KYH Frontend") // we use the string object constructor  				<br />
                typeof str <span class="comment-outcome">--> 'object'</span> // we use the typeof operator<br />
            </code>
			</div>
			<span class="note-comment">
              <span class="first-word">Note: </span>Strings being primitives means we can't use mutator methods as push() and sort()
			</span>
			
            <h4><i>number</i></h4>         
            <p>
              In Javascript we only have one type for numbers. There is no
              distinction for integers, floats etc. 
			  The number data type also consist of so called, special numeric values as <i>NaN</i>, <i>Infinity</i> and <i>-infinity</i>.  
			</p>
			<br />
			
			<p>			
			   If a Math function can't convert an argument to a number it returns <i>NaN</i>.
				To check for <i>NaN</i> do <b>not</b> compare; NaN === NaN, this returns false since type of <i>NaN</i> is number. Instead the <i>isNaN</i> function is used, isNaN === NaN.
			</p>

			<span class="note-comment">
              <span class="first-word">Note: </span>
			  With ES6 we can use <i>Number.isNaN(value)</i> to check for <i>NaN</i>.</span>
			  
            <span class="link"
              >See more;
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN"
                >https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN</a
              ></span
            >
			
            <div class="code-container">
			<div class="comment-oneline">The Math object in Javascript is
              used to perform mathematical tasks on numbers</div>
              <code>
                var floatNumber = 1.55 <br />
                Math.round(floatNumber) <span class="comment-outcome">--> 2</span> // will round to closest integer
                <br /><br />
                var num1 = 2.3 <br />
                var num2 = 1.4 <br />
                Math.floor(num1 + num2) <span class="comment-outcome">--> 3</span> // will round downwards to closest
                integer <br /><br />
                Math.max(4,7,9,11) <span class="comment-outcome">--> 11</span><br />
                Math.min(4,7,9,11) <span class="comment-outcome">--> 4</span><br />
                var numbers = [4,7,9,11]; <br />
                Math.max(numbers) <span class="comment-outcome">--> NaN</span> // Math max/min do not work with
                arrays.<br />
              </code>

              <div class="comment-oneline">
                To solve this we can use ES6 features as spread or reduce
              </div>
              <code>
                Math.max(...numbers) <span class="comment-outcome">--> 11</span><br /><br />
                var rand; <br />
                Math.random(rand) <span class="comment-outcome">--> ?</span> // returns a floating-point between 0
                and 1.
              </code>
            </div>

            <h4><i>undefined</i></h4>
            <p>
              <i>undefined</i> is a primitive datatype and a so
              called <i>falsy</i> value. It's important to not confuse <i>falsy</i> as
              'false', the latter being of type Boolean. Javascript will
              automatically assign <i>undefined</i> to a variable that are not
              initialized. In other words a variable that has been declared but not given a value will always return undefined. 
              A function with no return statement will always return <i>undefined</i> as well. To check for <i>undefined</i> we use the
              <i>typeof</i> operator.<br />              
            </p>

            <div class="code-container">
              <div class="comment-oneline">
                If we try to use a variable before being declared
              </div>
              <code> console.log(a); --> Gives a reference error <br /> 
			  </code>
              <div class="comment-oneline">
                If we don't initialize a variable
              </div>
              <code> var a; // This will give 'a' the value undefined. </code
              ><br />
              <div class="comment-oneline">But we can also do this</div>
              <code>
                var a = undefined; // we assign the value 'undefined'<br />
                typeof a <span class="comment-outcome">--> 'undefined'</span> <br />
                if ( typeof a === 'undefined') <span class="comment-outcome">--> true</span> // We check for
                <i>undefined</i>(note; the quotes!)</code
              >
			  </div>
			  
			<span class="note-comment">
              <span class="first-word">Note: </span><i>undefined</i> has its own type and is not to be considered an error, tough it's often the cause of bugs.
			</span>	            
           
            <h4><i>null</i></h4>
            <p>
              <i>null</i> is a primitive value and a keyword in JavaScript that means
              ‘no value’ or nonexistence of any value. <i>null</i> is also as the case with <i>undefined</i> a so called falsy value. The type of null tough is
              object while <i>undefined</i> has its own type. The fact that <i>null</i> is considered a primitive value and its type is object (non-primitive) can be very confusing and more or less be seen as a bug inherited from the time Javascript was designed. The best way to understand <i>null</i> is to interpret it as something that does not exist. If the purpose is to give a variable an empty value it can be done by assign it the value null, representing no value. It could be said that <i>null</i> has the same purpose/meaning for objects as <i>undefined</i> for primitives with the difference that the latter has its own type while <i>null</i> hasn't.
            </p>
            
            <div class="code-container">
              <code>
                let b = null; <br />
                typeof b <span class="comment-outcome">--> object</span> // null basically means empty object
                <br />
                if (b === null) <span class="comment-outcome">--> true </span>// We check for null </code
              >
            </div>
			
			<h4><i>Boolean</i></h4>
			<p>
			Boolean types are either true or false and denominated by <i>true</i> or <i>false</i>.
			The major importance of boolean:s are as result of comparison. 
			</p>			
			
			<h4><i>truthy</i> and <i>falsy</i> values</h4>
			<p>All values in Javascript can be said to have an inherent boolean value. To simplify there are six <i>falsy</i> values and all other values are <i>truthy</i>. The falsy values are: 
				<ul class="falsy-list">
				<li><i>false</i></li>
				<li><i>0</i></li>
				<li><i>undefined</i></li>
				<li><i>' '</i> or <i>" "</i><span class="list-comment">// empty string</span> </li> 
				<li><i>NaN</i></li>
				<li><i>null</i></li>
				</ul>

			<br />
          </div>
        </article>
		
		<article class="subject-article">
          <h3 class="subject-title">Objects</h3>
          <div class="example">
		  <p>The easiest way to understand objects are to see them as a collection of key value pairs. In Javascript the correct term for keys are properties. Properties being the 'key' in a key value pair can also be seen as variable names inside objects. If the property holds a function expression we would call it a <i>method</i>. 		  	  
		  <p>
		  
		  <h4>Literal Objects</h4>
			<p>In general the properties and values have something in common as for example all car objects can be expected to have the properties color and model. 			
			</p>

		<h4>Arrays</h4>
			<p>Arrays are basically a variable consisting of a collection of values.
			The values are accessed by referring to its index number unlike objects where a value is assigned to a named property. That said it's important to remember that arrays are also objects but with there own properties and methods.   
			</p>	          

            <div class="code-container">
			   <div class="comment-oneline">Some common Array methods</div>        
              <code>			  
                let greet = new String("Hello") <br />
                greet.charAt(greet.length-1) 	<br /><br />

                let str = "KYH Frontend" 		<br />
                typeof str 						<br />
                str.indexOf("F") 				<br /><br />

                let foo = str.split(" ") 		<br />
                typeof foo 						<br />
                foo.sort() 						<br /><br />

                let first = foo.slice(0,1)		<br />
                foo.push(first.join()) 			<br />
                console.log(foo) 				<br /><br />

                foo.constructor 
				</code>				
            </div>
			
            <span class="note-comment"
              ><span class="first-word">Note: </span>push and sort are so called mutator methods since they
              change the original array. Push for example adds item/s to the end
              of the array while returning the new length of the array. 
            </span>
            <span class="note-comment"><span class="first-word">Note: </span>We can use console.dir() to get more info about the
              constructor </span
            ><br />
            <br />
            <span class="link"
              >See more:
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Methods_2"
                >https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Methods_2</a
              ><br />
              <a
                href="https://www.tutorialrepublic.com/javascript-reference/javascript-array-object.php"
                >https://www.tutorialrepublic.com/javascript-reference/javascript-array-object.php</a
              ></span
            >		
		  </div>
	  </article>

<article class="subject-article">
          <h3 class="subject-title">Pass by Value vs. Reference</h3>
          <div class="example">
            <p>
              When we assign an object to new variable we copy the reference to
              where that object or array is stored in memory.<br />The reference
              works in other words as a pointer to where the object is stored,
              it doesn't copy the value as is the case with primitive types.
              This means that if we change the value of a property/element it
              impacts all variables with a reference to the same spot in memory.
            </p>

            <div class="code-container">
			<div class="comment-oneline">Primitive types, pass value by copying</div>
              <code>
                let a = "KYH" <br />
                let b = a <br />
                a = "Hello" // We assign a new value to a <br />
                b <span class="comment-outcome">--> "KYH"</span> // We retain the copied value <br />
              </code>
            </div>
			
            <div class="code-container">
			<div class="comment-oneline">Objects, pass value by reference</div>
              <code>
                let objectA = {name: "Kal", lastname: "Doe"} <br />
                let objectB = objectA <br />
                objectA.name = "Ada" // we change the value of prop name<br>
				</code>				
				<div class="comment-oneline">objectB points to the location of the original object.
              It's not a copy of objectA.</div>
			  <code>
                objectB.name <span class="comment-outcome">--> "Ada"</span> // prop name has changed <br />
              </code>
            </div>
            <span class="note-comment">
              <span class="first-word">Note: </span>Function arguments are always passed by value and are copied
              into the function.
			  </span>
            <br />
			<span class="note-comment"><span class="first-word">Note: </span>
            To make a real copy of an object/array we
              can use the spread operator(see more under ES6 features).
            </span>
            <br />

            <span class="link"
              >See more:
              <a
                href="https://stackoverflow.com/questions/16880418/javascript-pas"
                >https://stackoverflow.com/questions/16880418/javascript-pas</a
              ></span
            >
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Operators</h3>
          <div class="example">
            <p>
              JavaScript has <i>operators</i> that perform some operation on a single or multiple <i>operands</i> (data value). 
              There are at least 10 different kinds of operators in Javascript, one being the assignment operator (=) which assign a value to a variable, another being arithmetic operators as (+,-,/), that performs arithmetic operations.
              In this tutorial we will look deeper into a few of these, among them <i>Comparison</i> operators due to their importance for understanding how Javascript handles <i>type coercion</i>.     
            </p>
            
            <h4>Comparison Operators</h4>
            <p>
              The rules for type conversions in Javascript can be confusing and give unexpected outcomes if not understood fully.               
              It's not least important to understand the difference between the
              double equality operator (<b>==</b>) and the tripple equality
              operator (<b>===</b>) when comparing operands(values).               
              Javascript have different rules for using the double equality operator often called
              'loose' equality operator' versus the tripple one being the 'strict'
              equivalent. The loose equality operator compares the value but not
              the data type vs. the latter that compares both. There are no formal rule for
              which comparison to use in your code but to ensure strict comparison the
              tripple equality operator is to be preferred. That said there can
              be situations where a non-strict comparison operator can have it's
              benefits. No matter which one is used it's important to understand
              how they work and the implications of using one over the other.
              The already mentioned operators can also be combined as follows; not equal to <b>!= !==</b>,
              greater or less than <b> &gt; &lt;, &gt;= &lt;=.</b>
            </p>

            <div class="code-container">
              <code>
                if(1 == "1") <span class="comment-outcome">--> true</span> // will make a comparison after type
                conversion of "1" to 1 <br />
                <br />
                if(1 === "1") <span class="comment-outcome">--> false</span> // strict equality will check for both
                value and type.
                <br />
              </code>
            </div>
            
            <h4>Logical Operators</h4>
            <p>
              Logical operators are used to determine the logic between
              variables or values.
              ....
            </p>
            <ul class="log-list">
              <li>
                <span class="info-list">Operator</span
                ><span class="info-list"> </span>
				<span class="info-list"> Description</span>
              </li>
              <li>
                <span class="info-list">&&</span
                ><span class="info-list">and</span>
				<span class="info-list">Both values has to evaluate to true</span>
              </li>
              <li>
                <span class="info-list">||</span
                ><span class="info-list">or</span>
				<span class="info-list">One value has to evaluate to true</span>
              </li>
              <li>
                <span class="info-list">!</span
                ><span class="info-list">not</span>
              </li>
            </ul>
			<div class="code-container">			
			<div class="comment-oneline">The <span class="expand-text">||</span> (or) operator will return true if either operand is true</div>
			<code>
				var a = true;	<br />
				var b = false; 	<br />
				( a || b ) <span class="comment-outcome">--> true</span><br />   
			</code>
			<div class="comment-oneline">The <span class="expand-text">&&</span> (and) operator will return true if both operands are true</div>
			<code>
				var a = true;	<br />
				var b = false; 	<br />
				( a && b ) <span class="comment-outcome">--> false</span><br />   
			</code>
			<div class="comment-oneline">Logical (&&) operator will return second operand if both operands are true</div>			
			<code>
				var age = 20;	<br />
				var allowedAge = 15; <br />
				( (age > allowedAge) && "You can enter")<span class="comment-outcome">--> "You can enter."</span>
			</code>
			</div>
			
			<h4>Conditional Operator, <i>Ternary</i></h4>			
			<p>The ternary operator assigns a value to a variable based on some condition. If the condition is true the first value is assigned to the variable else the second one. Ternary operators can be seen as a leaner way to write code than the if/else conditionally approach.</p>
			<div class="code-container">
			<code>
				var age = 12	<br />
				var message = age > 15 ? "Horror movie." : "It's Disney for you." <br />
				message <span class="comment-outcome">--> "It's Disney for you."</span>
			</code>		
			<div class="comment-oneline">Ternary operator combined wth logical operator</div>
			<code>
			var age = 20;		<br />
			var allowedAge = 15	<br />
			var result = allowedAge ? ( age && "Welcome!" ) : null				<br />	
			result	<span class="comment-outcome">--> "Welcome" </span><br />
			</code>			
			</div>			
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Type Coercion</h3>
          <div class="example">
            <p>
              Type coercion is an important concept in Javascript not least
              considering that JavaScript is a loosely typed programming
              language, sometimes also described as a dynamic language.
              Javascript being loosely typed means that a variable can be
              assigned and reassigned any value of an existing data type. It can
              be a string to number, object to boolean, and so on. The process
              of converting a value from one type to another is called 'type
              coercion'.
            </p>
            
            <h4>Implicit vs. explicit coercion</h4>
            <p>
              Type conversion can be done implicit and explicit. An example of
              implicit(automatic) type conversion is when using the loose
              equality operator. Since it only compares the values and not the
              type Javascript will seek to make a type coercion so both values
              also share the same type. As a developer such code should be
              avoided since it's often the reason for bugs. Explicit coercion on
              the other hand is done on purpose, for example by using
              Number(value) that seeks to convert the value to the type
              'number'.
            </p>
            <br />
            <span class="link"
              >See more:
              <a
                href="https://www.freecodecamp.org/news/js-type-coercion-explained-27ba3d9a2839/"
                >https://www.freecodecamp.org/news/js-type-coercion-explained-27ba3d9a2839/</a
              >
            </span>
          </div>
        </article>
		
		<article class="subject-article">
          <h3 class="subject-title">Variable Scope</h3>
          <div class="example">
            <p>
              When talking about variable scope we are in essence referring to
              which scope a variable is accessible. In other words where we can look/access variables or functions.
              For a long time Javascript variable declarations were either
              global or function scoped. The latter sometimes also called local
              scope. A variable accessible anywhere in our code is said to exist
              in the global scope while a variable accessible inside a function
              exist in the local scope of the function where it was declared. With the ES6 update and the introduction of the keyword <i>let</i> for declaring variables we now also have <i>block scope</i>. A variable declared with <i>let</i> will only be accessible inside the block where it was declared. This can for example be inside the block restricted by a for loop that exist inside a function.
			</p>            
            <br />
            <p>
              When it comes to function scope it's also important to understand
              the concept of lexical scope sometimes also called Static
              scope. Lexical scope is the concept of a variable being accessible
              inside nested blocks, typically function or block scopes inside an outer function. 
              </p>
			  <div class="code-container">
			  
			  <div class="comment-oneline">Global Scope</div>
				<code>
				let a = "Hello"	// we create a global variable		<br />
				
				function() {			<br />
				<span class="example">	console.log(a)	<span class="comment-outcome">--> "Hello"</span> // a is accessible everywhere in our code </span><br />
				}	<br />
				</code>
				
				<div class="comment-oneline">Block Scope</div>
				<code>
				let numbers = [1,2,3,4,5]											<br />
				for(let i = 0; i &lt; numbers.length; i++) {						<br />
				<span class="example2">	console.log(numbers[i]) <span class="comment-outcome">--> 1,2,3,4,5		</span></span><br />	
				}											<br />
				console.log(i) <span class="comment-outcome">--> referenceError </span>// i does not exist outside its block scope <br />
				</code>
			  
			  <div class="comment-oneline">Lexical Scope</div>
			  <code>
                function outerFunction() { 							<br />
				<span class="example2">	var a = "I'm from outside";					</span><br />
				<span class="example2">	function innerFunction() {					</span><br />
				<span class="example3">		console.log(a)	<span class="comment-outcome">-->	I'm from outside	</span></span><br />
				<span class="example2"> }</span><br />
				}	
				</code>	
			</div>
		  </div>
        </article>       

		<article class="subject-article">
          <h3 class="subject-title">Hoisting</h3>
          <div class="example">
            <p>
              The definition of hoisting in Javascript is that declarations of
              variables and functions are moved to the top of the code when
              compiled. This means that a variable or function can be used even
              before it has been initialized. It's important to remember that variables declared with <i>let</i> will not be hoisted. One of the benefits with hoisting is that functions are hoisted as well making it possible to use them anywhere in your code. The concept of Hoisting can be the source for confusion, not least since the written code is only moved in the memory, not physically. 
            </p>
            <br />
            <p>
              If we call a variable declared with <i>var</i> before it has been initialized it's value will be <i>undefined</i> and <i>undefined</i> being a valid value, even having its own type, will not result in an error. The same applies for function expressions being an expression assigned to a variable. It's important to remember that it's only the declaration that is hoisted not the value of the variable.           
            </p>
            <br />
            <span class="link"
              >See more;
              <a
                href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting"
                >https://developer.mozilla.org/en-US/docs/Glossary/Hoisting</a
              >
            </span>

            <div class="code-container">
              <div class="comment-oneline">
                Variable declarations are hoisted inside functions as well
              </div>
              <code>
                var testScope = function() { <br />
                <span class="example">console.log(y);</span><br />
                <span class="example">var y = 1; </span><br />
                } <br />
                testScope(); <span class="comment-outcome">--> undefined</span><br /> </code
              ><br />

              <div class="comment-oneline">
                Anonymous function expressions are not hoisted
              </div>
              <code>
                var y = 2; <br />
                var testScope = function() { <br />
                <span class="example">console.log(y); // we try to access y before it has been initialized</span><br />
                <span class="example">var y = 1; </span><br />
                } <br />
                testScope(); <span class="comment-outcome">--> undefined </span><br />
              </code>

              <br />
			  <div class="comment-oneline">
                Here y is not redeclared inside the function
              </div>
              <code>			  
                var y = 2; <br />
                var testScope = function() { <br />
                <span class="example"> console.log(y);</span><br />
                } <br />
                testScope(); <span class="comment-outcome">--> 2</span><br />
              </code>			  
            </div>
			<!--
			<span class="note-comment">
              <span class="first-word">Note: </span>Variables declared with the <i>let</i> keyword are not hoisted (see more under ES6 features).
			  </span>-->
          </div>
        </article>

         

        <article class="subject-article">
          <h3 class="subject-title">Closures</h3>
          <div class="example">
            <p>
			A closure is to use a few words a function enclosed in lexical scope. As such a closure gives the enclosed function access to an outer function’s scope. In JavaScript, closures are created every time a function is created, at function creation time.
			</p>
			<br />
			<p>
			Closures in practice are used for creating object data privacy. It's commonly used for event handlers and callback functions. When using closures the enclosed variables are only in scope within the containing function making them non-accessible from the outside.
			</p>
            <span class="link"
              >More about closures:
              <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures</a></span
            ><br />
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Promises</h3>
          <div class="example">
            <p>
              A promise in Javascript is just as in real life; a promise/commitment to do something at some point in the future. The
              promise will then be resolved, or rejected. In programming context
              the Promise object represents the eventual completion (or failure)
              of an asynchronous operation and its resulting value. Promises in
              Javascript is a way to avoid what often is called 'callback hell'
              where callbacks are nested in an ever growing code structure.
            </p>
            <br />
            <p>
              A Promise consist of an resolved and rejected callback. Depending
              on if the promise is resolved or not the corresponding callback i
              executed. The resolve and reject functions, when called, resolve
              or reject the promise. With Promises we can organize our code with
              chained then() and catch() methods depending on if the promise is
              resolved or rejected.
            </p>

            <div class="code-container">
              <code>
                var myPromise = new Promise(function(resolve, reject) { <br />
              </code>
              <div class="comment-oneline">The promise will be either resolved or rejected</div>
              <code>
                <span class="example">let studied = true; </span><br />
                <span class="example">if(studied) { </span><br />
                <span class="example2">resolve("Success"); </span><br />
                <span class="example">} else { </span><br />
                <span class="example2">reject('Failed') </span><br />
                <span class="example"> } </span><br />
                }) <br />
              </code>
              <div class="comment-oneline">If the promise is fullfilled we pass the resolved argument
                  'value'</div>
              <code>
                myPromise.then(function(value) { <br />
                <span class="example"
                  >console.log(`It's done: ${value}`); <span class="comment-outcome">--> It's done: Study
                  Javascript</span></span
                ><br />
              </code>
              <div class="comment-oneline">If rejected we use a catch </div>
              <code>
                }).catch(function(rejected) { <br />
                <span class="example"
                  >console.log(`It's not done: ${value}`); <span class="comment-outcome">--> It's not done:
                  Study Javascript </span></span
                ><br />
                }) <br />
              </code>
            </div>
            
            <span class="link">
              See more:
              <a  href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises">
                https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises</a>
                </span>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">fetch API</h3>
          <div class="example">
            <p>
              The Fetch API is a Javascript built in new standard for making
              server requests. It provides a JavaScript interface for accessing
              and manipulating parts of the HTTP pipeline, such as requests and
              responses. It also provides a global fetch() method that provides
              an easy, logical way to fetch resources asynchronously across the
              network.
            </p>
            <br />
            <p>
              The fetch() method takes one mandatory argument, the
              <b>path(url)</b> to the resource you want to fetch. By default it
              will make a 'get request' and return a <b>Promise</b> containing a
              response object. We then have to extract the actual body content,
              can for example be the json() method to extract JSON body content.
              The fetch() method can optionally accept a second parameter
              consisting of an init object that gives the possibility to add
              configuration options for the request object.
            </p>

            <div class="code-container">
              <div class="comment-oneline">We make a fetch request from API Open Weather Data</div>
              <code>
                const url =
                <a
                  href="http://api.openweathermap.org/data/2.5/weather?q=London&APPID=8674cbad0da4e9ccd435f2442a4dcda7&units=metric"
                  >API OPEN WEATHER DATA</a
                >;
                <br />
                fetch(url).then(response => { <br />
                <span class="example">return response.json() </span><br />
                <span class="example">.then(response => { </span><br />
                <span class="example2">console.log(response.main.temp) </span
                ><br />
                <span class="example">}) </span><br />
                <span class="example">.catch(error => { </span><br />
                <span class="example2">console.log('Error') </span><br />
                <span class="example2">console.error(error) </span><br />
                <span class="example">}); </span><br />
                }); <br /><br />
              </code>
              <div class="comment-oneline">We configure the options for a POST request</div>  
				<code>			  
				const urlPost =
                <a href="https://jsonplaceholder.typicode.com/posts"
                  >JSON PLACEHOLDER</a
                >;
                <br />
                const options = { <br />
                <span class="example">method:"POST", </span><br />
                <span class="example">headers: { </span><br />
                <span class="example2"
                  >"Accept": "application/json; text/plain, */*",</span
                ><br />
                <span class="example2">"Content-type": "application/json" </span
                ><br />
                <span class="example">}, </span><br />
                <span class="example">body: JSON.stringify({ </span><br />
                <span class="example2">title: 'New Post', </span><br />
                <span class="example2">body: 'Lorem ipsum...!', </span><br />
                <span class="example2">id: 1 </span><br />
                <span class="example">}) </span><br />
                } <br />

                <br />
                fetch(urlPost, options) <br />
                <span class="example">.then(response => response.json()) </span
                ><br />
                <span class="example"
                  >.then(jsonResponse => console.log(jsonResponse)) </span
                ><br />
                <span class="example">.catch(error => { </span><br />
                <span class="example2">console.log(error) </span><br />
                <span class="example">}); </span><br />
              </code>
            </div>
            <span class="link"
              >See more:
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch"
                >API OPEN WEATHER DATA</a
              >
            </span>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">async/await</h3>
          <div class="example">
            <p>
              A special syntax is required to work with promises called
              “async/await”. It can be seen as a more easy to understand syntax
              compared to the then()/catch() methods. Using the keyword 'async'
              before a function means that the function always will return a
              promise. This is also required to be able to use 'await' inside
              async functions. The keyword await makes JavaScript wait until the
              promise is settled and first thereafter returns its result.
            </p>
            
            <div class="code-container">
              <code>
                const url =
                <a
                  href="http://api.openweathermap.org/data/2.5/weather?q=London&APPID=8674cbad0da4e9ccd435f2442a4dcda7&units=metric"
                  >API OPEN WEATHER DATA</a
                >; <br /><br />

                const getWeatherData = async function() { <br />
                <span class="example">const response = await fetch(url); </span
                ><br />
                <span class="example"
                  >const weatherData = await response.json();</span
                ><br />
                <span class="example">console.log(weatherData.main.temp) </span
                ><br />
                } <br />
                <br />
                getWeatherData().catch(error => { <br />
                <span class="example">console.error(error); </span><br />
                <span class="example">console.log('Error'); </span><br />
                }) <br />
              </code>
            </div>
            <span class="link"
              >See more:
              <a href="https://javascript.info/async-await"
                >https://javascript.info/async-await</a
              ></span
            ><br />
          </div>
        </article>
      </div>

      <!-- END TUTORIAL PART 1 -->

      <span id="es6"></span>
      <div class="tutorial-part">
        <h1 class="tutorial-title">ECMAScript 2015(ES6)</h1>
        <br />

        <article class="subject-article">
          <h3 class="subject-title">Variable declaration; const and let</h3>
          <div class="example">
            <br />
            <p>
              With the introduction of ES6 support was added for the key words <i>const</i> and <i>let</i> when declaring variables.
            </p>

            <h4><i>const</i></h4>
            <p>
              const is used for declaring variables where the intention is to
              not change its value. It could be said that the value will be read
              only. It's important tough to understand that it works different
              depending on the data type. For primitive types the value is set
              once and becomes read only. For objects it works differently since
              for example an array stored with const can still receive new
              elements tough it is impossible to change the data type of the
              value.
            </p>
            
            <h4><i>let</i> vs. <i>var</i></h4>
            <p>
              The main difference between <i>var</i> and <i>let</i> is that
              <i>var</i> has function scope and <i>let</i> has block scope. 
			  Meaning that <i>let</i> allows for block level variables to be created, for example inside an if branch or a for loop. Another difference is that <i>let</i> declarations are not hoisted unlike variables declared with <i>var</i>. Therefore a variable declared with <i>let</i> will not be accessible before it has been initialized, trying to will result in a reference error. While doing the same with a variable declared with <i>var</i> will return as <i>undefined</i>. Another difference is that a <i>let</i> declaration will not create a property on the global object as the case with <i>var</i> declarations. 
            </p>
			
			<div class="code-container">
              <div class="comment-oneline">The <i>iterator</i> is only accessible in its own scope while <i>b</i> is declared with var and accessible everywhere inside the function.</div>
			  <code>
			  function blockScope(num) {									<br />
				<span class="example">for(let i = 1; i &lt; num; i++) {		</span><br /> 
				<span class="example2">console.log(i) <span class="comment-outcome">--> 1,2,3,4</span></span><br />
				<span class="example2">var b = "I exist in function scope"	</span><br />
				<span class="example">	}									</span><br />
				<span class="example">console.log(b) <span class="comment-outcome">--> 	I exist in function scope		</span></span><br />
				<span class="example">console.log(i) <span class="comment-outcome">--> 	ReferenceError, i is not defined</span></span><br />
				}	<br />
				blockScope(5);	<br />
              </code>
			  </div>
			
            <span class="note-comment">
              <span class="first-word">Note: </span><i>var</i> will allow you to re-declare a variable in the same scope while a variable declared with <i>let</i> raises a SyntaxError.
            </span>
            <br />
            <p>
              <span class="link"
                >See more:
                <a
                  href="https://stackoverflow.com/questions/762011/whats-the-difference-between-using-let-and-var"
                  >https://stackoverflow.com/questions/762011/whats-the-difference-between-using-let-and-var</a
                >
              </span>
            </p>

            <div class="code-container">
              <code>
                function checkScope() { <br />
                <span class="example"
                  >console.log(foo) <span class="comment-outcome">--> ReferenceError</span> // foo is not hoisted </span
                ><br />
                <span class="example"
                  >console.log(bar) <span class="comment-outcome">--> undefined </span>// variable declaration is
                  hoisted </span
                ><br />
                <span class="example">let foo = "Hello" </span><br />
                <span class="example">var bar = "World" </span><br />
                <br />
                <span class="example">for(var i = 0; i &lt; 5; i++) {</span
                ><br />
                <span class="example2">console.log(i) <span class="comment-outcome">--> 0,1,2,3,4</span></span><br />
                <span class="example">}</span><br />
                <span class="example">for(let j = 0; j &lt; 5; j++) {</span
                ><br />
                <span class="example2">
                  console.log(j) <span class="comment-outcome">--> 0,1,2,3,4</span></span
                ><br />
                <span class="example">}</span><br />

                <span class="example"
                  >console.log(i); <span class="comment-outcome">--> 5</span></span
                ><br />
                <span class="example"
                  >console.log(j); <span class="comment-outcome">--> ReferenceError</span> //
                  can not be accessed outside its scope</span
                ><br />
                } 
                checkScope();
              </code>
            </div>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Arrow functions</h3>
          <div class="example">
            <p>
              Arrow functions are anonymous functions that allows us to write
              shorter more leaner code. An arrow function can omit the
              parenthesis if there is no more than one argument. It can also
              omit the square brackets and the keyword 'return' if the function
              only consist of an return statement.
            </p>

            <div class="code-container">
              <div class="comment-oneline">
                  A named function, the pre ES6 way to declare a function</div>
              <code>
                function doSmth(a) { <br />
                <span class="example"> return a * 2 </span><br />
                } <br />
              </code>
              <div class="comment-oneline">The same function refactored as an anonymous arrow function</div>
              <code> const doSmth = a => a * 2 <br /> </code>
            </div>

            <h4>Arrow functions and the keyword <i>this</i></h4>
            <p>
             One of the reasons for introducing arrow functions was the behaviour of the keyword <i>this</i>. 
			If not using arrow functions the value of <i>this</i> will depend on how the function is called. 
			To set the value of <i>this</i> and alter its default behavior inside a function, the bind() method has to be used.
            </p>
            <br />
            <p>
              Arrow functions inherits <i>this</i> from the enclosing lexical scope. Meaning if <i>this</i> is not present in its current scope it will look for it in the enclosing scope. 			  
			  If <i>this</i> is used in a nested function or for example in a method of a class it will look for the value of this
              in the parent scope meaning the parent function or the class where the method was defined. 
			  In other words <i>this</i> will always represent the object that defined the
              arrow function. 
			  
			  With arrow functions the behaviour of <i>this</i> is consistent and do not change
              depending on where it is called.
            </p>
            <br />
            <span class="link"
              >See more:
              <a
                href="https://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work"
                >https://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work</a
              ></span
            >
          </div>
        </article>

		<article class="subject-article">
          <h3 class="subject-title">Template Literals</h3>
          <div class="example">
            <p>
              Template Literals allows us to work with strings in a more agile
              and less ugly way. Not least the ability to use expressions gives
              lot of room for creating more dynamic code. Instead of quotes we
              use `backticks` to write string within it. We use ${variable or
              expression} instead of concatenation. Among the new features we
              also get a more agile syntax to define multiline strings.
            </p>

            <div class="code-container">
              <code>
                let firstName = "John" <br />
                let surName = "Doe" <br />
                const fullName = "John" + " " + "Doe" <span class="comment-outcome">--> John Doe</span> // The pre ES6
                way to do it.<br />
                <br />
                let firstName = "Lisa" <br />
                let surName = "Doe" <br />
                const fullName = `${firstName} ${surName}` <span class="comment-outcome">--> Lisa Doe</span> // Using
                template literals<br />
                <br />

                let divNumbers = `15 divided by 3 is ${15/3}` <span class="comment-outcome">--> 5</span> // We insert
                an expression
				</code>
				<span class="comment-oneline">
                  Tagged templates allows for template literals to be parsed with functions.</span>
				  <code>
				  ...
              </code>
            </div>
			
            <span class="link"
              >See more:
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals"
                >https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals</a
              ></span>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Loops & Iteration</h3>
          <div class="example">
            <h4><i>forEach</i></h4>
            <p>
              forEach() executes a provided function once for each array
              element. It will always returns the value undefined and is not
              chainable. ForEach can take tree arguments, the value of the
              current elment, what is required as well as two optional
              arguments, the index for each element and the array object it
              self. As with other high order methods it does not mutate the
              array on which it is called.
            </p>

            <div class="code-container">
                <span class="comment-oneline">Basic syntax </span>
                <code>
                array.forEach(function(currentValue, index, arr), thisValue)
                <br /><br />
                </code>
                <span class="comment-oneline">We loop through each name and add 'Doe'</span>
                <code>
                const myArr = ["John", "Lisa", "Tom"] <br /><br />
                myArr.forEach( name => { <br />
                <span class="example"
                  >console.log(`${name} Doe`) <span class="comment-outcome">--> John Doe, Lisa Doe...</span></span
                ><br />
                })
              </code>
            </div>

            <h4><i>for/in</i></h4>
            <p>
              The for/in statement iterates over all non-symbol properties of an object. The loop will iterate over all enumerable properties of the object itself and those the object inherits from its constructor's prototype as well. If the intention is to only
              consider properties of the object itself and not its prototypes, use getOwnPropertyNames() or perform a hasOwnProperty() check.
            </p><br />
			<p>
			The for/in statement can be used for arrays but this is not recommended. The reason is that there are no guarantee that a for/in loop will return the values in certain order. When it comes to arrays the order of access is important unlike objects where the value is assigned to a certain property. 
			</p>
			
            <div class="code-container">
              <code>
                const myObj = { name: "John", surname: "Doe" } <br /><br />

                for(let prop in myObj) {<br />
                <span class="example">console.log(prop) <span class="comment-outcome">--> name, surname </span></span
                ><br />
                }
              </code>
			  <div class="comment-oneline">A nested for/in</div>
			  <code>
               const myObj = { test: {name: 'John Doe', age: 34 }};		<br /><br />
				for(let prop in myObj) {								<br />
				<span class="example">let innerObj = myObj[prop]		</span><br />
				<span class="example">for(let innerProp in innerObj) {	</span><br />
				<span class="example2">console.log(innerObj[innerProp])	<span class="comment-outcome">--> John Doe 34</span></span><br />
				<span class="example">	}								</span><br />
				}
              </code>
			  <div class="comment-oneline">for/in combined with forEach</div>
			  <code>
			  const employees = [
			  <span class="example">{name: "John", role: "Accountant", salary: 10000},</span><br />
			  <span class="example">{name: "Lisa", role: "Adminstrator", salary: 8000},</span><br />
			  <span class="example">{name: "Tom", role: "Janitor", salary: 7000},</span><br />
			  <span class="example">{name: "Patty", role: "Manager", salary: 14000},</span><br />
			  <span class="example">{name: "Sally", role: "Sale", salary: 9000}</span><br />
			];	<br /><br />
		
		employees.forEach(employee => {	<br />
		<span class="example">for(let prop in employee) {					</span><br />
		<span class="example2">let data = `${prop}: ${employee[prop]}`		</span><br />
		<span class="example2">	console.log(`${data}`)						</span><br />
		<span class="example2">	}											</span><br />
		<span class="example">	console.log('')								</span><br />
		})																	<br />
			  </code>
            </div>

            <h4><i>for/of</i></h4>
            <p>
              The for/of statement loops over iterable objects. The loops
              through data structures that are iterable such as Strings, Arrays
              and array-like objects such NodeLists, Maps, Set etc. In every
              iteration the value of the next property is assigned to the
              variable. for/of is in general the preferred way to loop through
              iterable objects. It is more concise than a conventional for loop
              but can't be chained like forEach().
            </p>

            <div class="code-container">
              <code>
                const myNumbers = [11,22,33,44,55]<br /><br />

                for(let number of myNumbers) {<br />
                <span class="example">console.log(number) <span class="comment-outcome">--> 11,22,33...</span></span>
                <br />
                } <br />
              </code>
              <div class="comment-oneline">To access the index we have to use entries() </div>
              <code>
                const myArr = [a,b,c] <br /><br />
                for (const [index, val] of myArr.entries()) { <br />
                <span class="example"
                  >console.log(index +": "+ val`); <span class="comment-outcome">--> "0: a", "1: b", "2: c" </span
                ></span><br />
                } <br />
              </code>
            </div>

            <h4>Summary; which loop to use and when</h4>
			<!--The standard <i>for</i> and <i>for/in</i> loop constructs gives access to the index in the iterable object
              but not the actual element. To access the element we have to print
              out the, item[index]. With forEach() and for/of on the other hand we get access to the element itself. -->
            <p>			
              There are many ways to iterate over arrays and loops and they all
              have there strengths and tradeof:s. In general the most robust/safe way to loop through an array/object will be the <i>for/of</i> loop. If the intention is to manipulate every element in an array the <i>for/each</i> loop is the best choice. The <i>for/in</i> loop should only be used to iterate through the properties of an object and avoided for arrays where the index order is of importance. If the intention is to manipulate or filter data from an array consisting of objects a callback function will probably do the job most effectively. It might also be necessary with a combination of different tools and methods.<!-- It can For example a higher order function as the <i>filter()</i> method if the intention is to filter data that correspond to a certain condition or maybe the <i>map()</i> method to render data in a list on a webpage.--> With experience the choice of tool/s will come natural depending on the circumstances.
            </p>
            <br />
            <span class="link">
              See more:
              <a
                href="https://thecodebarbarian.com/for-vs-for-each-vs-for-in-vs-for-of-in-javascript"
                >https://thecodebarbarian.com/for-vs-for-each-vs-for-in-vs-for-of-in-javascript</a
              >
            </span>
          </div>
        </article>
		
		<article class="subject-article">
          <h3 class="subject-title">Higher order functions</h3>
          <div class="example">
            <p>
              When a function receives another function as an argument that
              function is called a <b>higher order function</b>. And the
              function you pass in is called a <b>callback</b>. With ES6 several
              new higher order functions were introduced. With this the
              Javascript language got more flexible and developers got access to
              some new effective tools. Noteworthy; These methods do not
              mutate/change the orignal array (in general a good thing!).
            </p>
            <h4><i>map()</i></h4>
			<p>...</p>
            <h4><i>filter()</i></h4>
			<p>...</p>
            <h4><i>reduce()</i></h4>
			<p>...</p>
            <h4><i>sort()</i></h4>
            <p>...</p>
            <h4><i>find()</i></h4>
            <p>...</p>
            <h4><i>includes()</i></h4>
            <p>...</p>
			
			<div class="code-container">
			
				<div class="comment-oneline">ARRAY CONSISTING OF OBJECTS</div>
				<code>
				const employees = [																	<br />
				<span class="example">  {name: "John", role: "Accountant", age: 44, salary: 10000},	</span><br />
				<span class="example">  {name: "Lisa", role: "Adminstrator", age: 22, salary: 8000},</span><br />
				<span class="example">  {name: "Tom", role: "Janitor", age: 53, salary: 7000},		</span><br />
				<span class="example">  {name: "Patty", role: "Manager", age: 37, salary: 14000},	</span><br />
				<span class="example">  {name: "Sally", role: "Sale", age: 23, salary: 9000},		</span><br />
				<span class="example">  {name: "Helen", role: "IT", age: 31, salary: 11000},		</span><br />
				<span class="example">  {name: "Rex", role: "Guard", age: 3, salary: 'T-Bone'}		</span><br />
				];																					<br />
			</code>
			<br />
			<div class="comment-oneline">map()</div>
			<code>
				...
			</code>
			<div class="comment-oneline">filter()</div>
			<code>
				...
			</code>
			<div class="comment-oneline">reduce()</div>
			<code>
				...
			</code>
			<div class="comment-oneline">sort()</div>
			<code>
				...			
			</code>
			<div class="comment-oneline">find()</div>
			<code>
				...
			</code>
			
			<div class="comment-oneline">includes()</div>
			<code>
				...
			</code>
			
			</div>
			
            <span class="link"
              >See more:
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#"
                >https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#</a
              ></span
            >
			<span class="link">
			See more: <a href="https://www.youtube.com/watch?v=rRgD1yVwIvE">JavaScript Higher Order Functions & Arrays (Youtube: Traversy Media)</a>
			</span>
		  </div>
        </article>
		
		<article class="subject-article">
          <h3 class="subject-title">Object constructor methods</h3>
          <div class="example">
		  
		  <h4>Object; keys(), values(), entries()</h4>
		  <p>...</p>
		  <!--
            <i><b>Get the keys and values from the object</b></i
            ><br />
            <i>myObj = { str1: "Hello", str2: "World" }</i><br />

            <i>Extra 1; Good, now show an alternative solution.</i>
            <i
              >Extra 2; Extend your original answer and get the length(quantity)
              of the properties.</i
            >
            <i
              >Extra 3; For what can you use the constructor method
              'hasOwnProperty' and what will it return?</i
            ><br />

            <span
              >Notes: The Object.keys/values will return an array.<br />
              The Object.entries returns an array of arrays.<br />
              An easy way to check if an object is empty is to check the length
              of the 'keys' property in the Object constructor<br />
              You can define how/if a prop can be accessed/changed by using the
              corresponding Object constructor method. </span
            ><br />

            <span
              >Note: 1) Can be done with for/in as well but then it will also
              show props that are inherited by the prototype.</span
            ><br />
            <span
              >Note: 2) The length property on the Object constructor will
              return undefined.</span
            ><br />
            <span
              >Note: 3) It will return(true) for all declared properties even
              those with no value.</span
            >-->
            <span class="link"
              >See more:
              <a
                href="https://stackoverflow.com/questions/7757337/defining-read-only-properties-in-javascript"
                >https://stackoverflow.com/questions/7757337/defining-read-only-properties-in-javascript</a
              ><br />
              See more:
              <a
                href="https://stackoverflow.com/questions/5515310/is-there-a-standard-function-to-check-for-null-undefined-or-blank-variables-in"
                >https://stackoverflow.com/questions/5515310/is-there-a-standard-function-to-check-for-null-undefined-or-blank-variables-in</a
              >
            </span>
          </div>
        </article>
		
		<article class="subject-article">
          <h3 class="subject-title">Array constructor methods</h3>
          <div class="example">
            <br />
            <h4>Array.from()</h4>
            <p>
              The Array.from() method returns an Array object from any object
              with a length property or an iterable object.
            </p>
            <br />

            <h4>Array.isArray()</h4>
            <span class="link"
              >More about <b>shallow</b> vs <b>deep</b> copy:
              <a
                href="https://www.freecodecamp.org/news/copying-stuff-in-javascript-how-to-differentiate-between-deep-and-shallow-copies-b6d8c1ef09cd/"
                >https://www.freecodecamp.org/news/copying-stuff-in-javascript-how-to-differentiate-between-deep-and-shallow-copies-b6d8c1ef09cd/</a
              ></span
            >
          </div>
        </article>        

        <article class="subject-article">
          <h3 class="subject-title">Spread & Rest Operator</h3>
          <div class="example">
            <p>
              The spread operator will essentially take either an array or an
              object and expands it into its set of items.<br />
              The rest operator is used to create an array from a collection of
              arguments passed to a function.<br />
              It works similar to the built in arguments object used to get all
              arguments passed to a function.
            </p>

            <h4>
              Understanding the impact of the spread operator when copying an
              object
            </h4>
            <p>
              When using the spread operator to copy an objects properties to a
              new object we make a real copy of the original.<br />It's
              important to understand the same goes for arrays, in other words
              spread can be used to make a real copy of an array. We do not copy
              the pointer/reference as is the case when we assign an object or
              array to a new variable.<br />With spread we can avoid the issue
              of an object that is manipulated affecting another object stored
              in a variable with the same pointer/reference. In other words;
              with the spread operator we copy an object in a immutable way and
              not just the pointer/reference to the same.
            </p>

            <div class="code-container">
              <code>
                const myArr = [1,2,3]; <br />
                const newArr = [...myArr,4,5] // newArray will consist of
                [1,2,3,4,5]
                <br /><br />
                myObj = { name: "John" } <br />
                newObj = { ...myObj, surname: "Doe" } // We add props from myObj
                to new Obj <br />
                <br />
                const myFunc = (...args) => { <br />
                <span class="example">return `All arguments ${args}`; </span
                ><br />
                } <br />
                <br />
                console.log(myFunc(1,2,3,4)) <span class="comment-outcome">--> All arguments 1,2,3,4</span>
              </code>
            </div>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Destructuring</h3>
          <div class="example">
            <p>
              When using destructuring we can pull out elements from arrays or
              properties from objects and assign them to variables.
              When it comes to arrays it is very straight forward and we we can
              use any variable name. The order matters tough.
              When it comes to objects the order doesn't matter since we use the
              corresponding property name as variable name.
            </p>

            <div class="code-container">
              <code>
                const personArray = ["John", "Lisa"]<br />
                const [a, b] = ["John", "Lisa"] // We assign the array items to
                variables a and b
                <br /><br />
                const person = { name: "John", age: 28 }<br />
                const {name} = { name: "John", age: 28} // We destructure 'John' to name variable
              </code>
            </div>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Default values</h3>
          <div class="example">
            <p>
              With ES6 support was added for the use of default values. To assign a default value we just assign a value to a function
              parameter. If no argument/s is given when calling the function it will be given its default value.
              This also works for destructuring where we can assign default values for variables.
            </p>

            <div class="code-container">
              <div class="comment-oneline">We assign default values to the parameters</div>
              <code>
                function withDefaultValues(a=10, b=20) { <br />
                  <span class="example">let sum = a + b; </span><br />
                  <span class="example">return sum;</span><br />
                  <span>}</span><br />
                  <span>withDefaultValues() <span class="comment-outcome">--> 30</span></span><br />
              </code><br />
              <div class="comment-oneline">We add an empty array as default value</div>
              
              <code>
                function addNumbers(numArr = []) { <br />
                <span class="example">let sum = 0; </span><br />
                <span class="example">numArr.forEach( num => { </span><br />
                <span class="example2"> sum += num; </span><br />
                <span class="example">}) </span><br />
                <span class="example">return sum; </span><br />
                } <br />

                addNumbers() <span class="comment-outcome">--> 0</span> // We get no error despite calling the
                function with no arguments.
              </code>
            </div>
          </div>
        </article>

        <article class="subject-article">
          <h3 class="subject-title">Classes</h3>
          <div class="example">
            <p>
              With ES6 we got classes in Javascript. In reality it is only
              syntactical sugar or an alternative syntax to prototype-bases
              inheritance or in other words; Javascript constructor functions. A
              class is a special type of funtions that uses the keyword class.
              As with constructor functions the name is capitalized by
              convention. A constructor method for creating and initializing an object can
              be specified. If this is not done a default constructor method -
              basically an empty function - is used. This is an empty object for
              a base class.
            </p>

            <h4>'constructor functions' vs classes</h4>
            <p>
              In most cases they are quite similar and they do the same thing
              but there are a some things that differs. A constructor requires
              the keyword <i>new</i> to work. While we still can call a
              constructor function without the keyword new this will throw an
              error when trying to do the same with a class. A class will in
              contrast to constructor functions create a constructor method by
              default if not given one. While constructor functions are hoisted
              this is not the case with class declarations. Another important
              difference is that everything that is written inside a class is
              typed in strict mode. With ES2019 we also got a few new important
              features when it comes to classes. It is now possible to create
              private properties and methods inside classes using the # prefix.
              There is also the possibility to initialize public properties at
              the top of a class before specifying a constructor. There are some
              important benefits to this that I will not go deeper in to here,
              for those that are interested to dwell more into all that classes
              offers I have added some links down here that explains the concept
              more in depth.
            </p>
            
            <span class="link"
              >See more:
              <a
                href="https://www.sitepoint.com/javascript-private-class-fields/"
                >https://www.sitepoint.com/javascript-private-class-fields/</a
              >
              <br />
              See more:
              <a
                href="https://dmitripavlutin.com/javascript-classes-complete-guide/"
              >
                https://dmitripavlutin.com/javascript-classes-complete-guide/ </a
              ><br /> </span
            ><br />

            <div class="code-container">
              <code>
                let Person = function(name,gender,age) { <br />
                <span class="example">this.name = name; </span><br />
                <span class="example">this.gender = gender; </span><br />
                <span class="example">this.age = age; </span><br />
				<span class="example">this.getName = function() { return this.name }; </span><br />
                }; <br />
              </code>
            </div>
          </div>
        </article>
        
      </div>
      <!-- End Tutorial part 2 -->

      <span id="questions-part"></span>
      <div class="tutorial-part">
        <h1 class="tutorial-title">Interview Questions</h1>
        <br />

        <div class="question">
          <h3>Fundamentals</h3>
          <br />
          <div class="example">
            <h4>Explain the concepts:</h4>
            <div class="example">
              <p>primitive datatypes</p>
              <p>
                How come we can use properties and methods on primitives as with
                objects?
              </p>
              <p>'undefined'</p>
              <p>Difference between undefined and null</p>
              <p>hoisting</p>
              <p>
                Explain the behaviour of function -expressions vs -declarations
                when it comes to hoisting
              </p>
              <p>global scope vs functional scope</p>
              <p>lexical scope</p>
            </div>
            <br /><br />

            <h4>Variable declaration</h4>
            <div class="example">
              <p>Explain the difference of 'let' vs. 'var'</p>
              <p>When do we use 'const'?</p>
            </div>
            <br /><br />

            <h4>Type coercion and comparison</h4>
            <br />
            <div class="example">
              <p>What do we get?</p>
              
			  <div class="code-container">
                <code>
                  4 + "2" <br />
                  8-"2"*3 <br />
                  (4 + true + "2")/5 <br />
                  4*(3-2)/false <br />
                  Boolean("") <br />
                  true == "1" <br />
                  14%10 > 2 <br />
                  10 - "KYH" <br />
                  "0" == false <br />
					</code>
				<span class="comment-oneline">// "0" is converted to a 'falsy' value but what does it
                    mean?</span><br />
				<code>
					NaN == NaN <br />
                  isNaN("Hello World") <br />
                  (true &lt; 3 &lt; 5) <br />
                  (8 &gt; 5 &gt; 3) <br />
                  (false || Boolean) <br />
                  (33 || false && true) <br />
                  (1 === 1 && "Hello") <br />
                </code>
                <span class="comment-oneline">// 33 and "Hello" are converted to 'truthy' values but what
                    does it mean?</span>
              </div>
            </div>
          </div>
          <br />

          <article class="subject-article">
            <h3 class="subject-title">'use strict'</h3>
            <div class="example">
              <p>
                Why would we use 'use strict' statement in a Javascript file and
                what are the consequences/benefits?
              </p>
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Reverse a String</h3>
            <div class="example">
              <i
                >Return the following string in reverse "Frontend Developer".</i
              >
              <br />
              <i
                >Extra: Show another way to achieve the same result. If not done
                already don't use the reverse method.</i
              >
              <i>Extra: Reverse a collection of type number.</i>
              <br />
              <span>Tip: reverse method only works with arrays.</span><br />
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Arrow functions</h3>
            <div class="example">
              <p>Explain arrow functions</p>
              <i
                >Convert the function to an arrow function and display the
                shortest possible version.</i
              >
              <div class="code-container">
                <code>
                  function doSomething(arg) { <br />
                  <span class="example">return arg * 2</span><br />
                  } <br />
                </code>
              </div>
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Remove Duplicates from an Array</h3>
            <div class="example">
              <i
                >Show if possible two ways to remove duplicates from an
                array.</i
              >
              <i
                >Extra: If not done already, use an object constructor method to
                remove the duplicates.</i
              ><br />
              <span>Note: All results most consist of an array.</span
              ><br /><br />
              <span>Tip: ES6 datatype 'Set' can only hold unique values.</span
              ><br />
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Sort an Array</h3>
            <div class="example">
              <p>
                Sort the array so the lowest number comes first and the highest
                last.
              </p>
			  
              <div class="code-container">
                <code> let numbers = [114,22,4,5,11,41]<br /> </code>
              </div>
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Duplicate an Array</h3>
            <div class="example">
              <i>Duplicate the array, both in pre ES6 as well as ES6.</i>
              <div class="code-container">
                <code> const numbers = [2,4,6,8] <br /> </code>
              </div>
              <i
                >Explain the importance/difference of using the spread operator
                to copy the props of an object -or the elements in an array- vs
                just assigning the object to a new variable?</i
              ><br />
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Keyword this</h3>
            <div class="example">
              <i
                >Explain how 'this' work when used in a stand-alone function
                (not; obj.method).</i
              >
              <i>How does 'this' work when used inside an arrow function?</i
              ><br />
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Destructuring</h3>
            <div class="example">
              <i><b>Destructure (solely) the last item from the array</b></i>
              
			  <div class="code-container">
                <code>
                  <span>const letters = ["A","B","C"] </span>
                </code>
                <br />
              </div>

              <i><b>What is the value of variables; a,c,d ?</b></i>
              <div class="code-container">
                <code>
                  <span>numberArr = [12,4,7] </span><br />
                  <span>const [a=5,, c, d=12] = [...numberArr] </span>
                </code>
              </div>
              <i><b>What do we get?</b></i>
              <div class="code-container">
                <code>
                  <span>const add = (a, b=5, c) => a + b</span><br />
                  <span>add(4)</span>
                  <br />
                </code>
              </div>
              <i><b>How can this be fixed without declaration?</b></i>
              <div class="code-container">
                <code>
                  {a, b} = { a: "Hello", b: "World" } <br />
                  console.log(a,b) // unexpected token... <br />
                </code>
              </div>
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">Objects and Object Constructor</h3>
            <div class="example">
              <p>Array.from() ...</p>
              <i
                >Extra 1: Use the Array.from() callback/mapfunction to
                manipulate each item.</i
              >
              <i>Extra 2: How can you check if a passed value is an array?</i>
              <i
                >Extra 3: What does it mean when you do a 'shallow copy' of an
                existing array or object?</i
              ><br />

              <p>
                <b
                  >What could cause a problem when using typeof foo === "object"
                  to determine if foo is an object?</b
                >
              </p>
              <p>Show how to resolve the problem/s</p>
              <br />

              <p>
                <b>Pass the values of the car object to the showCar function</b>
              </p>
              <p>
                Note: the function needs to cope with an unknown numbers of
                arguments
              </p>
			  
              <div class="code-container">
                <code>
                  car = { model: "Volvo", color: "blue", year: "2018" }
                  <br /><br />
                  ??? <br />
                  showCar = (???)=> { <br />
                  <span class="example">return ???; </span><br />
                  } <br />
                  console.log(showCar(???)); // Display car features/values
                </code>
              </div>
            </div>
          </article>

          <article class="subject-article">
            <h3 class="subject-title">FizzBuzz</h3>
            <div class="example">
              <i
                >Pretty common question(worth to google it...) present if
                possible 2 solutions</i
              >
              <p>
                Iterate over a 100 numbers.<br />
                When modulus 3 (remainder 0) return Buzz and when modulus 5
                return Fizz.<br />
                If both modulus 3 and 5 return FizzBuzz.
              </p>
            </div>
          </article>
        </div>
      </div>
      <div class="go-top"><a href="#top">To the Top</a><br /></div>
    </div>
    <script>
	
		// TOGGLE COLOR THEME
		const btnChangeColor = document.querySelector(".btn-change-color");
		const codeContainers = document.querySelectorAll(".code-container");
		const changeCodeColor = () => {
			Array.from(codeContainers, container => {
			container.classList.toggle("code-container-mod");
			});
		};
		btnChangeColor.addEventListener("click", changeCodeColor);
		// END TOGGLE
		
		
		// EXCERCISES  
					
		class Area {
		  constructor(width, height) {
			this.width = width;
			this.height = height;
		  }		  
		  calcArea() {
			return this.width * this.height;
		  }		 
		  get Area() {
			return this.calcArea();
		  }		 
		}
				
		// STANDARD ARRAY/OBJECT
		const employees = [
			  {name: "John", role: "Accountant", age: 44, salary: 10000},
			  {name: "Lisa", role: "Adminstrator", age: 22, salary: 8000},
			  {name: "Tom", role: "Janitor", age: 53, salary: 7000},
			  {name: "Patty", role: "Manager", age: 37, salary: 14000},
			  {name: "Sally", role: "Sale", age: 23, salary: 9000},
			  {name: "Rex", role: "Guard", age: 3, salary: 'T-bone'}
			];			
		
		// Lets suppose that the data above is returned as an object consisting of objects.
		// How would we proceed to get the same data and filter as above?
		// for that we need Object constructor methods.  
		
		// OBJECT OF OBJECTS		
		const objectArray = {
			john: 	{name: "John", role: "Accountant", age: 44, salary: 10000},
			lisa: 	{name: "Lisa", role: "Adminstrator", age: 22, salary: 8000},
			tom:  	{name: "Tom", role: "Janitor", age: 53, salary: 7000},
			patty:  {name: "Patty", role: "Manager", age: 37, salary: 14000},
			sally:  {name: "Sally", role: "Sale", age: 23, salary: 9000},
			rex:	{name: "Rex", role: "Guard", age: 3, salary: 'T-bone Steak'}
		}
	

		let richKids = employees.filter( employee => employee.salary > 9000)		
		let oldKids = employees.filter(employee => employee.age > 30)
		
		// THE OBJECT CONSTRUCTOR
		// we use object constructor to get values before filter  		
		let arrValues = Object.values(objectArray).filter(obj => obj.age > 32)			
		console.log("Test: ", arrValues)
		
		// more verbose solutions...
		for(let prop in objectArray) {
			if(objectArray[prop].age > 37) {
				console.log(objectArray[prop])
			}
		}
		
		const getOld = ()=> {
			let foo = []
			for(let prop in objectArray) {
				if(objectArray[prop].age > 30) {
					foo.push(objectArray[prop])
				}			
			}
			return foo
		}
		
		//console.log(richKids)
		//console.log(oldKids)	
		//console.log("old: ", getOld())
		
    </script>
    <noscript>Your browser does not support JavaScript!</noscript>
  </body>
</html>
